%-----------------------------------------------------------------------------
%
%               Template for sigplanconf LaTeX Class
%
% Name:         sigplanconf-template.tex
%
% Purpose:      A template for sigplanconf.cls, which is a LaTeX 2e class
%               file for SIGPLAN conference proceedings.
%
% Guide:        Refer to "Author's Guide to the ACM SIGPLAN Class,"
%               sigplanconf-guide.pdf
%
% Author:       Paul C. Anagnostopoulos
%               Windfall Software
%               978 371-2316
%               paul@windfall.com
%
% Created:      15 February 2005
%
%-----------------------------------------------------------------------------


\documentclass{paper}

% The following \documentclass options may be useful:

% preprint      Remove this option only once the paper is in final form.
% 10pt          To set in 10-point type instead of 9-point.
% 11pt          To set in 11-point type instead of 9-point.
% authoryear    To obtain author/year citation style instead of numeric.

\usepackage{amsmath}


\begin{document}

\special{papersize=8.5in,11in}
\setlength{\pdfpageheight}{\paperheight}
\setlength{\pdfpagewidth}{\paperwidth}

\conferenceinfo{CONF 'yy}{Month d--d, 20yy, City, ST, Country} 
\copyrightyear{20yy} 
\copyrightdata{978-1-nnnn-nnnn-n/yy/mm} 
\doi{nnnnnnn.nnnnnnn}

% Uncomment one of the following two, if you are not going for the 
% traditional copyright transfer agreement.

%\exclusivelicense                % ACM gets exclusive license to publish, 
                                  % you retain copyright

%\permissiontopublish             % ACM gets nonexclusive license to publish
                                  % (paid open-access papers, 
                                  % short abstracts)

\titlebanner{banner above paper title}        % These are ignored unless
\preprintfooter{short description of paper}   % 'preprint' option specified.

\title{Title Text}
\subtitle{Subtitle Text, if any}

\authorinfo{Name1}
           {Affiliation1}
           {Email1}
\authorinfo{Name2\and Name3}
           {Affiliation2/3}
           {Email2/3}

\maketitle

\begin{abstract}
TODO
\end{abstract}

\category{CR-number}{subcategory}{third-level}

% general terms are not compulsory anymore, 
% you may leave them out
\terms
term1, term2

\keywords
keyword1, keyword2

\section{Introduction}


%% Word vommit
Why network configuration is hard:
\begin{itemize}
	\item Wide variety of considerations: Have preferences for certain routes over others, failure resistance, backups etc
	\item Configurations are implemented locally and in a distributed fashion even though network intent is global
	\item Often achieve intent through indirect means (i.e., backups through aggregation, preferences through MED, AS PATH length, local-pref values, filtering through communities)
	\item Networks are distributed, asynchronous systems where the environment can be unknown, failures can occur ... which makes it difficult to consider all scenarios
	\item Problems are compounded in inter-domain setting where factors like peering agreements and bad peer behavior need to be taken into account.
	\item Protocol-specific issues such as lack of convergence in BGP
\end{itemize}

We present a new language that allows operators to directly express and compile high-level routing policies (both inter and intra-domain) from a centralized point of view.

The language provides the operator with the abstraction that they can control the routes that all traffic through their network can take, even if the routes start and/or end in a different autonomous system.

The core language consists of regular expression constraints on the set of allowed routes along with a preference operator between routes, which is used to specify both routing preferences and backup paths.
On top of the core language, we provide a higher-level macro language to talk only about constraints on routes without specifying any particular route details.
	
A compiler takes a routing policy written in our language and synthesizes concrete, per-device configurations running BGP. Although the language is independent of any particular routing protocol, we target BGP due to its expressiveness, scalability, and use for both inter-domain and intra-domain routing.
The compiler either guarantees that the resulting configurations correctly implement the policy and remain correct under all possible network failure scenarios, or it returns a counterexample.
(Similar to SDN, you get centralized control, yet a distributed implementation that uses an existing, scalable, fault-tolerant protocol.)

To allow for more fine-grained control over control-plane details, our language permits additional constraints on control protocol details (e.g., maximum number of allowed routes, whether to use multipath etc).


Summary: 
	 (1) Centralized: (simpler reasoning, no copy paste error, more concise), 
	 (2) Synthesis: (no need for gory details, e.g., community values, local-pref, MED, ...),
	 (3) Expressive: (backup routing, preferences, waypointing, directly say things like no transit or cold-potato routing), 
	 (4) Correct: (implement the policy, even under all failure scenarios)


\section{Overview}

Sources of bugs we fix. (It seems like the main advantage of our approach is not just fixing bugs though - it is easily describing high-level intention). 
Perhaps the best way to do this is by going through a bunch of examples in section 2 and showing how you could easily introduce bugs:

\begin{itemize}
	\item Out of sync, or copy paste errors due to replicated configs (never an issue due to centralized control)
	\item Correct filtering to ensure no undesired traffic can flow through the network (e.g., best practices, like an AS should filter customers for their prefix, are implemented automatically )
	\item Failures can easily lead to unexpected behavior (e.g., a datacenter failure scenario w/instability.)
	\item Trying to do anything interesting, like get backups correct is difficult (e.g., setting up aggregation wrong)
	\item Related to the last point, things like aggregation can introduce black holes. We have the information needed to prevent this
\end{itemize}


Possible Examples:
\begin{itemize}
	\item Basic datacenter with spine preference
	\item Simple AS that prefers customers over peers over providers
	\item Combined internal backup routing with preference based entrance into the network using aggregation.
	\item Something like cold potato routing
\end{itemize}

\section{Language} 

\subsection{Syntax}
Define the grammar of each of the languages - regular language, the macro language on top of it, and maybe the IR language.

\subsection{Semantics} 
Give the semantics in terms of ranked paths.
Extension of regular expression semantics with the 
additional constraint that we take only valid topology paths and that their are no paths with 
repeated locations in the path. One tricky point is that we care about paths starting or ending at locations that are 
connected to end-hosts in some way. And we want the length of the path to be a secondary tie-breaker.

\subsection{Theory}
What are the properties of this language? Ideally, a proof here about its expressiveness. We can perhaps do everything 
BGP can do? We can't do shortest paths routing with BGP, but we could with OSPF though? Clearly we can only describe 
policies that are stable under all possible failure scenarios (at least internally stable, could still cause) routing 
loops with interactions with neighbors.


\section{Compilation}

\begin{itemize}
	\item Separate prefixes so they are disjoint
	
	\item For each prefix, build a DFA from each of the regular path constraints 
		  We do this using character classes and regular expression derivatives.
		  The accepting states are labeled with the particular preference.
	
	\item Build the constraint graph, which gives us valid paths through the network that satisfy one or 
		  more of the regular path constraints. We accept if we are in at least one of the accepting states 
		  for one or more of the DFAs. Add a new start and end node as well.
		  
	\item Minimize the constraint graph by removing nodes and edges that never contribute to a solution. 
		  Required for soundness. Removing these makes it easier to check if things are implementable using BGP (see next point).
		  We use several heuristics to make this faster (e.g., removing edges for dominated nodes)
		  
	\item Since our policy language can express things not implementable in BGP, we need a few checks.
		  First show some examples of what the problem is: why BGP cannot make a decision. 
		  The reasons this can happen are: 
		  (1) Single best path per router - no subset of paths specified is consistent (if A goes through B and C goes through A, then C goes through B).
		  (2) Failures - Have to make a decision without knowing what failures have occurred. Never want to prefer one peer over another and then not get a path when one was available

	\item We can check for these with a sufficient condition (that works often and is very fast), 

	\item For each router, build a preference pre-order, that defines the constraints between preferences.
	
	\item Finally, if we know BGP can make decision locally, then we can directly translate to local BGP configurations using 
		  information about the state machines from the neighbors. In particular, we tag (and test on) community values for the
		  corresponding state and set preferences accordingly (example will be needed)

	\item Running example will be helpful here.	
\end{itemize}


\subsection{Optimizations}

\begin{itemize}
	\item For performance, the main bottleneck will probably be the minimization step. We use a number of heuristics here to make this faster.
	\item For config readability and number of route maps/communities, we avoid community tagging/matching whenever possible with a number of tricks.
\end{itemize}



\section{Evaluation}

\begin{enumerate}
	\item Expressiveness of the policy language / BGP safe part of the language (maybe a proof earlier for this)
	\item Compactness of the policy language (how verbose/concise, maybe in loc)
	\item Intuitiveness of the policy language (how easy is it to understand? Not really a good way to evaluate this other than demonstrate earlier by example)
	\item Speed of compilation (does it take forever? what are the bottlenecks)
	\item Understandability of the resulting configurations (Can humans understand them?)
	\item Some measure of the size of the resulting configurations (e.g., the number of route maps. Is this actually ever an issue in BGP?)
\end{enumerate}


\section{Future Work}

\begin{itemize}
	\item Environments: Model environments using the same framework. (e.g., no-export allows certain paths that weren't before
	\item Verification: (Language serves as a high-level abstraction of the low-level details, so we can perform verification directly on the high-level policies)
	\item OSPF: language isn't inherently tied to BGP, and could use iBGP with OSPF or some other protocol. This would require different kinds of checks though.
\end{itemize}


\section{Related Work}

\begin{itemize}
	\item Regular path queries
	\item Lots of background on BGP
	\item Feamster rcc stuff
	\item Logic programming BGP configs
\end{itemize}

\section{Conclusions}

TODO

\appendix
\section{Appendix Title}

This is the text of the appendix, if you need one.

\acks

Acknowledgments, if needed.

% We recommend abbrvnat bibliography style.

\bibliographystyle{abbrvnat}

% The bibliography should be embedded for final submission.

\begin{thebibliography}{}
\softraggedright

\bibitem[Smith et~al.(2009)Smith, Jones]{smith02}
P. Q. Smith, and X. Y. Jones. ...reference text...

\end{thebibliography}


\end{document}

%                       Revision History
%                       -------- -------
%  Date         Person  Ver.    Change
%  ----         ------  ----    ------

%  2013.06.29   TU      0.1--4  comments on permission/copyright notices

