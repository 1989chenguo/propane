\documentclass[twocolumn, openany]{sig-alternate-10pt}
%\documentclass[twocolumn]{article}
%\documentclass[10pt]{sigalternate052015}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{xcolor}
\usepackage{url}
\usepackage{times}
\usepackage{xspace}
\usepackage{listings}
\usepackage{code}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\usepackage{tikz}
\usetikzlibrary{arrows,automata,positioning}
\let\proof\relax
\let\endproof\relax
\usepackage{amsthm}
\usepackage{subcaption}
\usepackage{balance}
\usepackage[ampersand]{easylist}
\usepackage{textcomp}
\usepackage{pifont}
\newcommand{\cmark}{\ding{51}}
\newcommand{\xmark}{\ding{55}}

\definecolor{princetonorange}{RGB}{255,143,0}
\definecolor{tmlblue}{RGB}{0,58,120}  % tmlblue == Toronto Maple Leafs Blue!

\newcommand{\todo}[1]{\textcolor{red}{[TODO: #1]}}
\newcommand{\ratul}[1]{\textcolor{blue}{[ratul: #1]}}
\newcommand{\ryan}[1]{\textcolor{green}{[ryan: #1]}}
\newcommand{\dpw}[1]{\textcolor{tmlblue}{[dpw: #1]}}
\newcommand{\todd}[1]{\textcolor{princetonorange}{[todd: #1]}}

\newcommand{\EG}{\emph{e.g.}}
\newcommand{\IE}{\emph{i.e.}}
\newcommand{\ETC}{\emph{etc.}}
\newcommand{\ETAL}{\emph{et al.}}

\newcommand{\sysname}{{\small \sf Propane/AT}\xspace}
\newcommand{\sysnamesec}{{\sf Propane/AT}\xspace}
\newcommand{\propane}{{\small \sf Propane}\xspace}

\newcommand{\para}[1]{\paragraph*{\textbf{#1}}}

\newcommand{\set}[1]{\ensuremath{\{ #1 \} }}
\newcommand{\abs}[1]{\ensuremath{ \lvert #1 \rvert }}

\newcommand{\CD}[1]{\texttt{\small #1}}  % code font
\newcommand{\KW}[1]{\texttt{\small\bfseries{#1}}}

\newcommand{\True}{\CD{true}}
\newcommand{\Define}{\KW{define}}
\newcommand{\Prefer}{\texttt{>>}}
\newcommand{\Path}{\texttt{=>}}
\newcommand{\Link}{\texttt{->}}
\newcommand{\Agg}{\KW{agg}}
\newcommand{\Any}{\KW{any}}
\newcommand{\None}{\KW{drop}}
\newcommand{\In}{\KW{in}}
\newcommand{\Out}{\KW{out}}
\newcommand{\AND}{\texttt{\&}}
\newcommand{\OR}{\texttt{|}}
\newcommand{\NOT}{\texttt{!}}
\newcommand{\Intersect}{\ensuremath{\cap}}
\newcommand{\Union}{\ensuremath{\cup}}

\newcommand{\Exit}{\KW{exit}}
\newcommand{\End}{\KW{end}}
\newcommand{\Start}{\KW{start}}
\newcommand{\Enter}{\KW{enter}}
\newcommand{\Eventually}{\KW{eventually}}
\newcommand{\Already}{\KW{already}}
\newcommand{\Internal}{\KW{internal}}
\newcommand{\Never}{\KW{never}}
\newcommand{\Always}{\KW{always}}
\newcommand{\Through}{\KW{through}}
\newcommand{\LinkKW}{\KW{link}}
\newcommand{\PathKW}{\KW{path}}
\newcommand{\Novalley}{\KW{novalley}}

\newcommand{\Con}{\mathrm{con}}
\newcommand{\Pfx}{\mathrm{pfx}}%
\newcommand{\CompilePred}{\ensuremath{\mathrm{compile}_\mathrm{pred}}}
\newcommand{\CompilePg}{\ensuremath{\mathrm{compile}_\mathrm{PG}}}
\newcommand{\CompileMbgp}{\ensuremath{\mathrm{compile}_\mathrm{mBGP}}}
\newcommand{\Compile}{\ensuremath{\mathrm{compile}}}
\newcommand{\Append}{\ensuremath{\mathrm{append}}}
\newcommand{\Pref}{\ensuremath{\mathrm{pref}}}
\newcommand{\Topo}{\ensuremath{\mathrm{topo}}}
\newcommand{\EndR}{\ensuremath{\mathrm{end}}}
\newcommand{\Rank}{\ensuremath{\mathrm{rank}}}

\renewcommand{\path}[2]{ #1 \mapsto \ensuremath{#2} }

%% grammar
\newcommand{\BNFALT}{\;\;|\;\;}
\newcommand{\hdr}[2]{\flushleft \chdr{\hspace{5mm}#1}{#2}}
\newcommand{\chdr}[2]{\textbf{#1} {#2} \\ \centering}%

\newtheorem{thm}{Theorem}
\newtheorem{defn}{Definition}
\newtheorem{lem}[thm]{Lemma}
\newtheorem*{cor}{Corollary}


\begin{document}

\special{papersize=8.5in,11in}
\setlength{\pdfpageheight}{\paperheight}
\setlength{\pdfpagewidth}{\paperwidth}

\onecolumn

\appendix

\vspace{2em}
\section{Definitions Reference}

\begin{figure*}[h!]\small
  \begin{minipage}[t]{.45\linewidth}
  \hdr{Propane/AT Syntax}{}
  \vspace*{-1\baselineskip}
  %
  \[ \begin{array}{rclr}
     pol     &::=& p_1, \dots, p_n & \textit{policies} \\
     p       &::=& t \hspace{.3em} \Path \hspace{.3em} r_1 \Prefer \dots \Prefer r_m \BNFALT cc & \textit{constraints} \\
     pfx     &::=& d.d.d.d/[d..d] & \textit{prefix} \\
     t       &::=& \$x & \textit{template variable} \\
         &\BNFALT& pfx & \textit{prefix test} \\
     r       &::=& l & \textit{location} \\
         &\BNFALT& \emptyset & \textit{empty set} \\
         &\BNFALT& \In & \textit{internal loc} \\
         &\BNFALT& \Out & \textit{external loc} \\
         &\BNFALT& r_1 \cup r_2 & \textit{union} \\
         &\BNFALT& r_1 \cap r_2 & \textit{intersection} \\
         &\BNFALT& r_1 \cdot r_2 & \textit{concatenation} \\
         &\BNFALT& \NOT r & \textit{path negation} \\
         &\BNFALT& r^* & \textit{iteration} \\
     cc     &::=& agg(pfx, r_1 \rightarrow r_2)  & \textit{control constraints} \\
  \end{array} \]%

  \end{minipage}
  %
  \begin{minipage}[t]{.5\linewidth}\small
  \hdr{Propane/AT Expansions}{}
  \vspace*{-1\baselineskip}
  %
  \[\begin{array}{lcl}
    \Any               & = & \Sigma^* \\
    \None              & = & \emptyset \\
    \Internal          & = & \In^+ \\
    \Always(X)         & = & X^* \\
    \Never(X)          & = & (!X)^* \\
    \Through(X)        & = & \Sigma^* \cdot X \cdot \Sigma^* \\
    \End(X)            & = & \Sigma^* \cdot X \\
    \Start(X)          & = & X \cdot \Sigma^* \\
    \Enter(X)          & = & \Sigma^* \cdot \Out \cdot (X \cap \In) \cdot \Sigma^* ~ \cup \\
                       &   & \Sigma^* \cdot (X \cap \Out) \cdot \In \cdot \Sigma^* \\
    \Exit(X)           & = & \Sigma^* \cdot \In \cdot (X \cap \Out) \cdot \Sigma^* ~ \cup \\
                       &   & \Sigma^* \cdot (X \cap \In) \cdot \Out \cdot \Sigma^* \\
    \LinkKW(X,Y)       & = & \Sigma^* \cdot X \cdot Y \cdot \Sigma^* \\
    \PathKW(\vec{X})   & = & \Sigma^* \cdot X_1 \dots X_n \cdot \Sigma^* \\
    \Novalley(\vec{X}) & = & \NOT\PathKW(X_2,X_1,X_2) ~ \cap \dots \cap \\
                       &   & \NOT\PathKW(X_n,X_{n-1},X_n) \\
  \end{array} \]%

  \end{minipage}%

  \vspace{1em}
  \begin{minipage}[t]{.46\linewidth}
  \hdr{mBGP Syntax}{}
  \vspace*{-1\baselineskip}
  %
  \[ \begin{array}{rclr}
     d    &   & & \textit{integer} \\
     c    &   & & \textit{community} \\
     t    &::=& \$x \BNFALT d.d.d.d/[d..d] & \textit{predicate} \\
     ns   &::=& \{ l_1, ~\dots,~ l_k \} & \textit{peers} \\
     ma   &::=& d : ({ns}_1, c_1) \rightarrow ({ns}_2, c_2) & \textit{match action} \\
     pc   &::=& ma_1, \dots, ma_k & \textit{prefix config} \\
     rc   &::=& t_1 \rightarrow {pc}_1, ~\dots,~ t_k \rightarrow {pc}_k & \textit{router config} \\
     mbgp &::=& l_1 \rightarrow {rc}_1, ~\dots,~ l_k \rightarrow {rc}_k & \textit{mBGP policy} \\%
  \end{array} \]%%

  \end{minipage}
  %
  %
  \begin{minipage}[t]{.5\linewidth}
  \hdr{Compilation}{}
  \vspace*{-1\baselineskip}
  %
  \[ \begin{array}{l}
     \CompileMbgp( [x_1, \dots, x_k], G ) = \\
     ~~~~~ [~ l \rightarrow rc ~\vert~ \\
     ~~~~~~~~~~~~ l \in internal(G.V), \\
     ~~~~~~~~~~~~ rc = \Append_i (\CompilePred( x_i, G )) ~]  \\
     \\
     \CompilePred( (t,PG,pref), G ) = \\
     ~~~~~~~~~~~~~~~ [~ t \rightarrow [~ ma ~\vert~ \\
     ~~~~~~~~~~~~~~~~~~~~~ m \leftarrow (l,q_m) \in PG, \\
     ~~~~~~~~~~~~~~~~~~~~~ pin \leftarrow \text{adjIn}(PG,m), \\
     ~~~~~~~~~~~~~~~~~~~~~ (in,q_n) \leftarrow \{ (bs,q_n) ~\vert~ bs=\{b ~\vert~ (b,q_n) \in pin \}, bs \neq \emptyset \}, \\
     ~~~~~~~~~~~~~~~~~~~~~ out \leftarrow \{ c ~\vert~ (c,\_) \in \text{adjOut}(PG_i,m) \}, \\
     ~~~~~~~~~~~~~~~~~~~~~ ma = \Pref(m) : (in,q_n) \rightarrow (out,q_m) ~] ~] \\
     \\


     \Compile( p_1, \dots, p_k, G) = \\
     ~~~~~~ \text{compile}_\text{mBGP}([\text{compile}_\text{PG}(p_1,G), \dots, \text{compile}_\text{PG}(p_k,G)], G) \\
  \end{array} \]%
  \end{minipage}%

  \vspace{3em}

  \vspace*{-2\baselineskip}
  \begin{minipage}[t]{1.01\linewidth}
  \hdr{Propane/AT Concretization}{}
  \vspace*{-2\baselineskip}
  %
  \[ \begin{array}{lcl}
     \\
     \Con(\emptyset, \Gamma, f)      &=& \emptyset \\
     \Con(l, \Gamma, f)              &=& \Sigma_i ~ f_i^{-1}(l) \\
     \Con(r_1 \cup r_2, \Gamma, f)   &=& \Con(r_1,\Gamma,f) \cup \Con(r_2,\Gamma,f) \\
     \Con(r_1 \cap r_2, \Gamma, f)   &=& \Con(r_1,\Gamma,f) \cap \Con(r_2,\Gamma,f) \\
     \Con(!r, \Gamma, f)             &=& !\Con(r,\Gamma,f) \\
     \Con(r^*, \Gamma, f)            &=& \Con(r,\Gamma,f)^* \\%
     \Con(\Pfx ~\Path~ r_1, ~\dots~, r_k, \Gamma, f) &=&
          \Pfx ~\Path~ \Con(r_1,\Gamma,f), ~\dots~, \Con(r_k,\Gamma,f)  \\%
     \Con(\$x ~\Path~ r_1, ~\dots~, r_k, \Gamma, f) &=&%
         [~ \Pfx ~\Path~ \Con(r_1,\Gamma,f) \cap \text{end}(l), ~\dots~, \\%
         & & ~~~~~~~~~~~~~~~ \Con(r_k,\Gamma,f) \cap \text{end}(l) ~\vert~ (\Pfx,l) \in \Gamma(x) ~]  \\%
     \Con(p_1, \dots, p_n, \Gamma,f) &=& \Con(p_1, \Gamma,f), \dots, \Con(p_n, \Gamma,f) \\%

  \end{array} \]%
  \end{minipage}%

  \vspace{2em}

  \begin{minipage}[t]{\linewidth}
  \hdr{mBGP Concretization}{}
  \vspace*{-2\baselineskip}
  %
  \[ \begin{array}{lcl}
     \\
     \Con(l_1 \rightarrow {rc}_1, ~\dots,~ l_k \rightarrow {rc}_k,\Gamma,f,G)
        & = &
        \mathit{append}_i~ [~ \ell \rightarrow con(rc_i,\ell,\Gamma,f,G)  ~\vert~ \ell \in f^{-1}(l_i) ~]
        \\
     \Con(t_1 \rightarrow {pc}_1, ~\dots,~ t_k \rightarrow {pc}_k,\ell,\Gamma,f,G)
        & = &
        \Con(t_1 \rightarrow {pc}_1,\ell,\Gamma,f,G), \dots, \Con(t_k \rightarrow {pc}_k,\ell,\Gamma,f,G)
        \\
     \Con(\Pfx \rightarrow {pc},\ell,\Gamma,f,G)
        & = &
        \Pfx \rightarrow \Con(pc,\text{true},\ell,\Gamma,f,G)
        \\
     \Con(\$x \rightarrow {pc},\ell,\Gamma,f,G)
        & = &
        [~ \Pfx \rightarrow \Con(pc, l=\ell, \ell,\Gamma,f,G) ~\vert~ (\Pfx, l) \in \Gamma(x) ~]
        \\
     \Con(ma_1, \dots, ma_k,o,\ell,\Gamma,f,G)
        & = &
        \Con(ma_1,o,\ell,\Gamma,f,G), \dots, \Con(ma_k,o,\ell,\Gamma,f,G)
        \\%
     \Con(n_1 : ({ns}_1, n_2) \rightarrow ({ns}_2, n_3),o,\ell,\Gamma,f,G)
        & = & \textbf{if}~ ns_1 = \{\text{start}\} ~\text{and}~ o = \text{false} ~\textbf{then}~ \bullet \\
        &   & \textbf{else}~ n_1 : ( \Con({ns}_1,\ell,\Gamma,f,G), n_2) \rightarrow (\Con({ns}_2,\ell,\Gamma,f,G),n_3)%

        \\
     \Con(\{ l_1, ~\dots,~ l_k \}, \ell, \Gamma,f,G)
        & = &
        \bigcup_i ~ \{ x ~\vert~ x \in f^{-1}(l_i),~ (x,\ell) \in G.E \}
        \\
  \end{array} \]%
  \end{minipage}%

  \vspace{1em}
  \hrulefill%
  \vspace{1em}%

  \caption{\sysname syntax, expansions and concretization, as well as mBGP syntax and concretization.}
  \label{fig:syntax}
  %\vspace{-1em}
\end{figure*}%

\newpage


\section{Preliminaries}

For reference, the full \sysname syntax as well as expansions from constraints into regular expressions are shown in Figure~\ref{fig:syntax}. mBGP syntax and compilation, as described in the paper, as well as concretization functions ($\Con$) are shown in Figure~\ref{fig:syntax}.

\subsection{Definition of Compilation}

We present the definition of compilation slighty differently here by factoring a separate $\CompilePred$ function, to make the proof clearer. This is a simple rewriting of the compilation function defined in the body of the paper.

\subsection{Definition of Concretization}

Definitions for concretization are shown in Figure~\ref{fig:syntax}. Concretization for a \sysname policy takes as input, the policy and a context
$\Gamma : Var \rightarrow 2^{Prefix \times V}$,
which maps from a template prefix to a set of pairs of a concrete prefix and a concrete location that ``owns" the prefix.
%
For each regular expression $r$, we replace each abstract location with the sum over its corresponding concrete locations under the inverse homomorphism $f^{-1}$. For each template variable, we replace it with a new entry for each of its corresponding concrete prefixes under the supplied mapping $\Gamma$. We also intersect the resulting concretized regular expression with $\text{end}(l)$ to capture the fact that this traffic is owned by the concrete location $l$.%

We also define concretization over the mBGP policy in a similar manner. We replace each abstract router configuration $l \rightarrow rc$ a new entry for each concrete location $\ell \in f^{-1}(l)$. The concrete location $\ell$ is passed as a parameter to $con$ to remember the current router.
%
To concretize a prefix policy with a template ($\$x \rightarrow pc$) we replace it with a sequence of policies, one for each prefix in context ($(pfx,l) \in \Gamma(x)$). Match action statements where the set of import neighbors is the singleton set containing the product graph start node $\{ start \}$ and we are not currently at looking at the router configuration for the location specified in the context $l$, then we drop the match action. This is denoted with the $\bullet$ symbol. Finally, to concretize a set of neighbors, we again use $f^{-1}$ to find the set of concrete neighbors under the inverse homomorphism, but then restrict it to those that are actually connected in the underlying concrete topology with $G.E$.


\subsection{Notation}

Throughout the remainder of the appendix, we use the following convention for metavariables:

\[ \begin{array}{ll}
  \text{Product Graph nodes} & n,m,o \\
  \text{Topology locations} & a,b,c \\
  \text{Automata states} & q_i \\
  \text{Topologies} & G, G^A \\
  \text{Product Graph} & PG, PG^A \\
  \text{Automata} & M, M^A \\
\end{array} \]

We use capital letters for abstract topology/product graph nodes and we use lower case letters for concrete topology nodes. By default, product graph nodes with different subscripts refer to nodes that share the same topology location (\IE, $\Topo(n_1) = \Topo(n_2)$). A superscript $G^A$ refers to the abstract version (in this case of the topology), while the non-superscripted value refers to the concrete version. Given a path as a sequence of locations $path = l_1, \dots, l_k$ we often apply the graph homomorphism $f$ to the path by writing: $f(path) = f(l_1), \dots, f(l_k)$.


\newpage

\section{Proof Sketch}
\vspace{1em}

The goal of the proof is to show that the concretization and compilation functions commute. In particular, we are interested in establishing the following theorem:

\begin{thm}
  for all \sysname policies pol, contexts $\Gamma$, and topologies G and $G^A$ related by the homomorphism $f$, 
  $$\Con(\Compile(pol,G^A),\Gamma,f,G) = \Compile(\Con(pol,\Gamma,f), G)$$
\end{thm}

The proof proceeds in the following steps. 

\para{Product Graphs (Step 1)} First, we establish several facts about the relationship of the concrete and abstract product graphs given the definition for building the product graph. We start by assuming that both an abstract constraint and its concretized form are compiled to product graphs and preference functions: 
%
\[
\begin{array}{lll}
  \CompilePg(t_1 \Path~ \Con(r_1,\Gamma,f) ~\Prefer~ \ldots ~\Prefer~ \Con(r_n,\Gamma,f), G) &=& (t_1, PG, \Pref) \\
  \CompilePg(t_2 \Path~ r_1 ~\Prefer~ \ldots ~\Prefer~ r_n, G^A) &=& (t_2, PG^A, \Pref^A) \\
\end{array}
\]
%
Using this assumption, we show that several relationships hold between $PG$ and $PG^A$ as well as between $\Pref$ and $\Pref^A$. 

\para{Substitution of Constraints (Step 2)} The next step is to use the relationships established in step 1 to show that concretization and compilation commute for an individual constraint \sysname p:
%
$$\Con(\Compile(p, G^A), \Gamma, f, G) = \Compile(\Con(p,\Gamma,f), G)$$
%
This proof proceeds by cases on the constraint p.

\para{Substitution of Policies (Step 3)} Finally, this theorem is lifted to \sysname policies $pol = p_1, \ldots, p_n$ using the previous proof for individual constraints to obtain the final theorem:
%
$$\Con(\Compile(pol,G^A),\Gamma,f,G) = \Compile(\Con(pol,\Gamma,f), G)$$ 

\newpage


\section{Substitution Proof}

\subsection{Product Graphs (Step 1)}
In this section, we will establish several relationships between the product graph and preference functions for abstract and concretized \sysname policies. First we relate the languages denoted by regular expressions under concretization. Then we lift this observation to automata, and finally to product graphs. We use these connections to left the notion of homomorphism to the product graphs and to relate the inferred BGP local preferences for abstract and concrete devices.


\newcommand{\Lang}{\ensuremath{\mathcal{L}}}

%We compile regular expressions to automata. As a side condition, we ensure that there are no transitions from some state $q$ to the initial state: $\sigma(q,x) = q_0$. This is done by creating another state $q_0'$ with the same transition function as $q_0$ and all other states transition to $q_0'$ instead of $q_0$.

\vspace{1em}
\begin{lem}
  For any context $\Gamma$, homomorphism $f$, and regular expression $r$, 
  path $p \in \Lang(con(r,\Gamma,f)) \iff f(p) \in \Lang(r)$.
\end{lem}
\begin{proof}
By induction on the structure of $r$

\emph{Case $\emptyset$:}
  \[ \begin{array}{lll}
    p \in \Lang(con(\emptyset,\Gamma,f)) &\iff& f(p) \in \Lang(\emptyset) \\
    p \in \emptyset &\iff& f(p) \in \emptyset \\
  \end{array} \]

\emph{Case $l$:}
  \[ \begin{array}{lll}
    p \in \Lang(con(l,\Gamma,f)) &\iff& f(p) \in \Lang(l) \\
    p \in \Lang(\Sigma_i ~ f_i^{-1}(l)) &\iff& f(p) \in \Lang(l) \\
    p \in \bigcup_i f_i^{-1}(l) &\iff& f(p) \in \Lang(l) \\
    p \in f^{-1}(l) &\iff& f(p) \in \{ l \} \\
    p \in f^{-1}(l) &\iff& f(p) = l \\
    \text{by homomorphism} & & \\
  \end{array} \]

\emph{Case $r_1 \cup r_2$:}
  \[ \begin{array}{lll}
    p \in \Lang(con(r_1 \cup r_1,\Gamma,f)) &\iff& f(p) \in \Lang(r_1 \cup r_2) \\
    p \in \Lang(con(r_1,\Gamma,f) \cup con(r_1,\Gamma,f)) &\iff& f(p) \in \Lang(r_1 \cup r_2) \\
    p \in \Lang(con(r_1,\Gamma,f)) \cup \Lang(con(r_1,\Gamma,f)) &\iff& f(p) \in \Lang(r_1 \cup r_2) \\
    p \in \Lang(con(r_1,\Gamma,f)) \vee p \in \Lang(con(r_1,\Gamma,f)) 
       &\iff& 
       f(p) \in \Lang(r_1) \vee f(p) \in \Lang(r_2) \\
    \text{by cases + IH} & & \\
  \end{array} \]

\emph{Case $r_1 \cap r_2$:} 
  \[ \begin{array}{c}
    \text{symmetric to } \cup \text{ case with } \wedge \text{ instead of } \vee
  \end{array} \]

\emph{Case $!r$:}
  \[ \begin{array}{lll}
    p \in \Lang(con(!r,\Gamma,f)) &\iff& f(p) \in \Lang(!r) \\
    p \in \Lang(!con(r,\Gamma,f)) &\iff& f(p) \in \Lang(!r) \\
    p \in \Sigma^* - \Lang(con(r,\Gamma,f)) &\iff& f(p) \in \Sigma^* - \Lang(r) \\
    \text{by IH} & & \\
  \end{array} \]

\emph{Case $r^*$:}
  \[ \begin{array}{lll}
    p \in \Lang(con(r^*,\Gamma,f)) &\iff& f(p) \in \Lang(r^*) \\
    p \in \Lang(con(r,\Gamma,f)^*) &\iff& f(p) \in \Lang(r^*) \\
    p \in \bigcup_{i \in \mathbb{N}} \Lang(con(r,\Gamma,f))^i &\iff& f(p) \in \bigcup_{i \in \mathbb{N}} \in \Lang(r)^i \\
    \text{Follows from IH and definition of } \Lang(r)^i & & \\
  \end{array} \]

\end{proof}



\vspace{2em}
For the proof, we assume an invariant that when regular expressions are translated to finite automata, there is no transition back to the initial state $q_0$. This is easily done by introducing a separate copy of $q_0$ that allows transitions. The reason is to distinguish if a state corresponds to a router originating a route. We also compile automata in a particular way as defined below

\begin{defn}
Given a regular expression $r$ over abstract locations, homomorphism $f$, a nonempty set of locations $L$, and a finite state machine $M^A = (\Sigma,Q^A,q_0,\sigma^A,F^A)$, we create a concrete state machine $M = (\Sigma, Q, q_0, \sigma, F)$ for the concretized policy $con(r,\Gamma, f) \cap \EndR(L)$ in the following way: 

    \[ \begin{array}{lll}
      1. & \sigma(q_0,l) = q' \iff \sigma^A(q,f(l)) = q' & \textbf{for each}~~ l \in L \\
      2. & \sigma(q,l) = q' \iff \sigma^A(q,f(l)) = q' & \textbf{for each}~~ l \in \Sigma \\
      3. & q \in F \iff q \in F^A & \\
    \end{array} \]
\end{defn}


Next, we show that the construction is correct. That is, the machine recognizes exactly the language $con(r,\Gamma, f) \cap \EndR(L)$.

\begin{lem}
  for any path $p$, $M$ matches $p$ $\iff$ $p \in \Lang(con(r,\Gamma, f) \cap \EndR(L))$
  %\vspace{1em}
  \begin{proof} 
    $ $
    \vspace{1em}

    \textbf{Case} ($\Rightarrow$)

    Assume $M$ matches $p$. Then this means that $M^A$ matches $f(p)$. If we have a trace of string of the form $ p = x_1 \cdot \dots \cdot x_n$, then $f(p) = f(x_1) \cdot \dots \cdot f(x_n)$. For each transition $\sigma(q,l) = q'$ in the concrete automaton, we have transition $\sigma(q,f(l)) = q'$ in the abstract automaton, and they have the same final states, so this trace is accepting for $M^A$. Because $M^A$ matches $f(p)$, this means that $f(p) \in \Lang(r)$. From Lemma 1, this means that $p \in \Lang(con(r,\Gamma,f))$. We also know that, since there is only a transition from the initial state $\sigma(q_0,l)$ defined for $l \in L$ by construction, it means that $p \in \Lang(\text{end}(L))$. Since we know that $p \in \Lang(con(r_i,\Gamma,f))$ and $p \in \Lang(\text{end}(L))$, we know that $p \in \Lang(con(r,\Gamma,f) \cap \text{end}(l))$ and thus $p \in \Lang(con(r,\Gamma, f) \cap \EndR(L))$.

    \vspace{1em}
    \textbf{Case} ($\Leftarrow$)

    Assume $p \in \Lang(con(r,\Gamma, f) \cap \EndR(L))$. This means that $p \in \Lang(con(r,\Gamma,f))$ and $p \in \Lang(\text{end}(L))$. Lemma 1, we know that $f(p) \in \Lang(r)$, which means that $M^A$ matches $f(p)$. 
    %
    Consider any string of the form $p = l \cdot x_2 \cdot \dots \cdot x_n$ such that $p \in \Lang(con(r,\Gamma,f) \cap \text{end}(L))$. Clearly $l \in L$ and there is a transition defined for $\sigma(q_0,l) = q_1$.
    %
    This means that $M^A$ matches $f(l) \cdot f(x_2) \cdot \dots \cdot f(x_n)$.
    %
    For each transition $\sigma^A(q,f(x_i)) = q'$, we have $\sigma(q,x_i) = q'$ in $M$.
    %
    Thus the string $l \cdot x_2 \cdot \dots \cdot x_n$ is accepted along the same path of automaton states.
  \end{proof}

\end{lem}

\vspace{.5em}
\begin{lem} $M$ and $M^A$ have the same set of states. That is, $Q = Q^A$.
    $ $
    \vspace{1em}
    \begin{proof}
      This follows trivially from the construction of $M$. States in $M$ are copied over from states in $M^A$.
    \end{proof}
\end{lem}

\vspace{3em}
For the remainder of this section, we will prove a collection of lemmas assuming the following: 
%
\[
\begin{array}{lll}
  \CompilePg(t_1 \Path~ \Con(r_1,\Gamma,f) \cap \EndR(L) ~\Prefer~ \ldots ~\Prefer~ \Con(r_n,\Gamma,f) \cap \EndR(L), G) &=& (t_1, PG, \Pref) \\
  \CompilePg(t_2 \Path~ r_1 ~\Prefer~ \ldots ~\Prefer~ r_n, G^A) &=& (t_2, PG^A, \Pref^A) \\
\end{array}
\]
%
We will also assume that $PG = (G',start,rank)$ and $PG^A = (G'^A,start^A,rank^A)$ and that either $L = \Sigma$, or $L = \{ l \}$.

\vspace{3em}


\begin{lem}
  We can lift the homomorphism $f$ to a new homomorphism $f_{pg}$ over the product graphs in the following way:
  \[ \begin{array}{rcl}
    f_{pg}( start ) & = & start^A  \\
    f_{pg}( (l,q_1,\ldots,q_n) ) & = & (f(l),q_1,\ldots,q_n) \\
  \end{array} \]

  Now we prove that $f_{pg}: G' \rightarrow G'^A$ is a valid homomorphism
  \begin{proof}
    From Lemma 4, we know that $(f(l),q_1,\ldots,q_n)$ is a valid node in $PG^A$ since each automata
    shares the same states. Assume there is an edge in $PG$ from $x=(l,q_1,\ldots,q_n)$
    to $y=(l',q_1',\ldots,q_n')$. We know that $f(x) = (f(l),q_1,\ldots,q_n)$ and $f(y) = (f(l'),q_1',\ldots,q_n')$.
    From the construction of PG, we know that $\sigma_i(q_k, l) = q_k'$. However, from the construction of the abstract automata, we also know that $\sigma_i(q_k, l) = q_k' \iff \sigma^A_i(q_k, f(l)) = q_k'$. Therefore, we can conclude that $\sigma^A_i(q_k, f(l)) = q_k'$. However, from the definition of $PG^A$, this means that there must be an edge in $PG^A$ for ($f(x),f(y)$).
  \end{proof}
\end{lem}


\begin{lem}
  If $f_{pg}(n) = N$, then the product graph preference of these nodes is equal: $\Rank(n) = \Rank^A(N)$.

  \begin{proof}
    Assume $n = (l,q_1,\dots,q_k)$. We know that $f_{pg}(n) = (f(l),q_1,\dots,q_k)$. 
    We also know that $q_i \in F \iff q_i \in F^A$. 
    By the definition of the ranking function $\Rank$, then 
    $\Rank(n) = \{ i ~\vert~ q_i \in F \} = \{ i ~\vert~ q_i \in F^A \} = \Rank^A(N)$.
  \end{proof}

\end{lem}


%\begin{lem}
%  For every state $N = (L, q_1, \dots, q_n)$ in $PG^A$, there exists a state $n = (l,q_1, \ldots, q_n)$ in $PG$
%  such that $f_{pg}(n) = N$.%

%  \begin{proof}
%    By assumption, we assumed that $f$ is surjective. That is, every location $L$ in the original abstract topology $G^A$ is mapped to by at least one location $l$ in the concrete topology $G$: $f(l) = L$. 
%  \end{proof}
%\end{lem}

\todo{re evaluate this}

\todo{make explicit the fact that we can't anycast}

\todo{tie back to existing lemmas}

\vspace{1em}

Next, we show that whenever there is a transition in $PG^A$, there is a corresponding step in the concrete product graph $PG$. This will allows to show that, if the preference inference succeeds for the abstract product graph, then it will also succeed for the concrete product graph while inferring the same preferences.

\vspace{1em}

\begin{lem}
  If, for $PG$ and $PG^A$ we have the following:

  \[ \begin{array}{ll}
    1. & (a,b) ~\text{is an edge in the concrete topology} \\
    2. & \Topo(m) = a \\
    3. & f_{pg}(m) = M \\
    4. & (M,N) ~ \text{is an edge in the product graph}~ PG^A \\
    5. & \Topo(N) = f(b) \\
  \end{array} \]

  then there exists a node $n$ in $PG$ where:

  \[ \begin{array}{ll}
    1. & \Topo(n) = b \\
    2. & f_{pg}(n) = N \\
    3. & (m,n) ~ \text{is an edge in the product graph}~ PG \\
  \end{array} \]

  \begin{proof}
    $ $
    \vspace{1em}
    
    \noindent
    Since $\Topo(m) = a$, suppose that $m = (a, q_1, \dots, q_k)$. We know that $f_{pg}(m) = M = (f(a), q_1, \dots, q_k)$. By assumption $N = (f(b), s_1, \dots, s_k)$. Let us take the node $n = (b, s_1, \dots, s_k)$. 

    \vspace{.8em}
    \begin{easylist}
      & Clearly $\Topo(n) = b$
      & Clearly $f_{pg}(n) = (f(b), s_1, \dots, s_k) = N$
      & Since $(M,N)$ is an edge in $PG^A$, we know that, for each automata transition function: $\sigma^A(q_i, f(b)) = s_i$. From the automata construction, this means that for each regular expression, $\sigma(q_i, b) = s_i$ if $q_i \neq q_{0_i}$. We know that $q_i \neq q_{0_i}$ due to the side condition for automaton construction that ensures no transitions to the initial state. It follows that $(m,n)$ is an edge in the product graph since $(a,b)$ is a valid topology edge by assumption, and $\sigma(q_i, b) = s_i$. 
    \end{easylist}

  \end{proof}
\end{lem}


\newcommand{\trans}[3]{\ensuremath{#1 \overset{#3}{\rightarrow} #2}}


\begin{lem}
  For any transition $\trans{m}{m'}{l}$ in $PG$, there is a corresponding transition $\trans{f(m)}{f(m')}{f(l)}$ in $PG^A$.
  \begin{proof}
    if $m' = (l, q_1, \ldots, q_n)$, then $f(m') = (f(l), q_1, \ldots, q_n)$. Since there is the edge $(m,m')$ in $PG$, then there is the edge $(f(m),f(m'))$ in $PG^A$. Finally, because $\Topo(f(m')) = f(l)$, there must be a transition $\trans{f(m)}{f(m')}{f(l)}$.
  \end{proof}
\end{lem}

% n --> m'
% m' --> n

\vspace{.4em}
\begin{lem}
  In the concrete product graph, $m \leq m' \iff f_{pg}(m) \leq f_{pg}(m')$ in the abstract product graph.
  \begin{proof}
    $ $

    \vspace{1em}
    We show that $\leq$ forms a simulation relation for the subgraph reachable from $m$ and $m'$ in $PG$ iff $\leq$ forms a simulation relation for the subgraph reachable from $f(m)$ and $f(m')$ for $PG^A$. This involves showing that $m \geq_{rank} m' \iff f(m) \geq_{rank} f(m')$, and that 
    for every transition $\trans{m}{n}{l}$ in $PG$ there is a transition $\trans{m'}{n'}{l}$ iff for every transition $\trans{f(m)}{f(n)}{f(l)}$ in $PG^A$ there is a transition $\trans{f(m')}{f(n')}{f(l)}$.

    \vspace{1em}
    \textbf{Case} $(\Rightarrow)$

    Consider the subgraph of $PG$ reachable from $m$ and $m'$. From $m \leq m'$ and the definition of ($\leq$), we know that $m' \geq_{rank} m$. 

    %
    From Lemma 6, and $m' \geq_{rank} m$ we know that $f_{pg}(m') \geq_{rank} f_{pg}(m)$. 
    From Lemma 8, there is a transition $\trans{f(n)}{f(n')}{f(l)}$.

    \vspace{1.2em}
    \textbf{Case} $(\Leftarrow)$

    Let $M = f(m)$ and let $M' = f(m')$.
    Suppose that $M \leq M'$, which means that with $M' \geq_{rank} M$ in the abstract product graph. It also means that, for each neighbor $N'$, if we have the transition: $\trans{M'}{N'}{L}$ then we also have a transition: $\trans{M}{N}{L}$ where $N' \geq_{rank} N$. We must show that the same relation holds for $m$ and $m'$. 

    \vspace{1em}
    Assume that $\Topo(M) = f(a)$ and $\Topo(N) = f(b)$. \todo{This can be done because $f$ is surjective}. Also assume that $m'$ has a neighbor $n'$. We know that $\Topo(m) = a$ and $\Topo(m') = b$. Clearly $(a,b)$ is a valid concrete topology edge since it is a transition in the product graph between $m$ and $m'$. We now apply Lemma 7 with the following facts:

    \[ \begin{array}{ll}
      1. & (a,b) ~\text{is a concrete topology edge} \\
      2. & \Topo(m) = a \\
      3. & f_{pg}(m) = M \\
      4. & (M,N) ~\text{is an edge in}~ PG^A \\
      5. & \Topo(N) = f(b) \\
    \end{array} \]

    Lemma 7 lets us conclude that there exists a node $n'$ such that:

    \[ \begin{array}{ll}
      1. & \Topo(n) = b \\
      2. & f_{pg}(n) = N \\
      3. & (m,n) ~\text{is an edge in}~ PG \\
      4. & \Rank(n) = \Rank(N) \\
    \end{array} \] 

    Thus if there is transition $\trans{m'}{n'}{b}$, then there is also a transition $\trans{m}{n}{b}$. Lemma 6 together with the assumption $N' \geq N$ shows that $n' \geq{rank} n$.

  \end{proof}

\end{lem}


\vspace{3em}

The previous lemma tells us that the total ordering between node preferences is preserved under the lifted graph homomorphism $f_{pg}$. 
We use this fact to define an ordering ($ord : V \rightarrow \mathbb{N}$) that maps product graph nodes to numbers reflecting the total ordering such that $ord(m) = ord(f(m))$ for all product graph nodes $m$.


\begin{defn}
  Assign $\Pref(m) = \Pref^A(f_{pg}(m))$ as increasing integers according to the total ordering for $\leq$.
  Clearly $\Pref(m) \leq \Pref(m') \iff m \leq m'$ and $\Pref(f_{pg}(m)) \leq \Pref(f_{pg}(m')) \iff f_{pg}(m) \leq f_{pg}(m')$
\end{defn}


\vspace{3em}
\subsection{Constraint Substitution (Part 2)}

\begin{lem}

  For concrete ($PG$) and abstract ($PG^A$) product graphs related by $f_{pg}$

  \[ \begin{array}{l}
     ~~~~~~~~~ [~ pfx \rightarrow ma_1, \dots, ma_k ~\vert~ \\
     ~~~~~~~~~~~~~~~~~~ M \leftarrow (l,q_M) \in PG^A, \\
     ~~~~~~~~~~~~~~~~~~ pin = \mathit{adjIn}(PG^A,M), \\
     ~~~~~~~~~~~~~~~~~~ (in,q_N) \in \{(BS,q_N) ~\vert~ (\_,q_N) \in pin, BS=\{b ~\vert~ b \in f^{-1}(B),~ (b,\ell) \in G.E,~ (B,q_N) \in pin \} \}), \\
     ~~~~~~~~~~~~~~~~~~ out \leftarrow \{ c ~\vert~ c \in f^{-1}(C), (c,\ell) \in G.E, (C,\_) \in \mathit{adjOut}(PG^A,M) \}, \\
     ~~~~~~~~~~~~~~~~~~ in \neq \emptyset, \\
     ~~~~~~~~~~~~~~~~~~ ma_h = ord^A(M) : (in,q_N) \rightarrow (out,q_M) ~] \\
  \end{array} \]%

  Is equivalent to

  \[ \begin{array}{l}
     ~~~~~~~~~ [~ pfx \rightarrow ma_1, \dots, ma_k ~\vert~ \\
     ~~~~~~~~~~~~~~~~~~ m \leftarrow (l,q_M) \in PG, \\
     ~~~~~~~~~~~~~~~~~~ pin \leftarrow \text{adjIn}(PG,m), \\
     ~~~~~~~~~~~~~~~~~~ (in,q_N) \leftarrow \{ (bs,q_N) ~\vert~ (\_,q_N) \in I, bs=\{ b ~\vert~ (b,q_N) \in pin\} \}), \\
     ~~~~~~~~~~~~~~~~~~ out \leftarrow \{ c ~\vert~ (c,\_) \in \mathit{adjOut}(PG,m) \}, \\
     ~~~~~~~~~~~~~~~~~~ in \neq \emptyset, \\
     ~~~~~~~~~~~~~~~~~~ ma_h = ord^A(f_{pg}(m)) : (in,q_N) \rightarrow (out,q_M) ~] \\
  \end{array} \]%

  \begin{proof}
    For each $M$ there exists at least one $m$ such that $f_{pg}(m) = M$. Note that $f_{pg}$ overapproximates the connectivity of the product graph, by virtue of being a graph homomorphism. For each concrete node $n$ such that $n = (b,q_n) \in adjIn(PG,m)$ we know that if $f_{pg}(n) = N$ where $N = (f(b),q_N)$, then $N \in adjIn(PG^A,M)$ and $q_n = q_N$ from the homomorphism. Thus by taking $f^{-1}(B) = f^{-1}(f(b))$, for each such $f(b)$ for node $N$ that shares the same state $q_N$, we get a superset of the locations from the concrete graph. However, by restricting those locations to only those that appear in the topology $(b,\ell)$, we get exactly the set that appears in the concrete product graph. 
    This is because we know $q_N \rightarrow q_M$ from the abstract product graph is a valid transition, which means that $q_n \rightarrow q_m$ is a valid concrete product graph transition, and if there is a topology edge $(b,\ell)$, then there must be a product graph edge $(n,m)$. Therefore:
    $$\{b ~\vert~ b \in f^{-1}(B),~ (b,\ell) \in G.E,~ (B,q_N) \in \text{adjIn}(PG^A,f_{pg}(m)) \}$$
    is equivalent to
    $$\{ b ~\vert~ (b,q_N) \in \text{adjIn}(PG,m)\}$$
    This also holds for the case with adjOut. Further, note that because we are looking at a particular location $l$, there can only be at most one such $m = (l,q_N)$ such that $f_{pg}(m) = M = (f(l), q_N)$. If there is no such $m$ where $f_{pg}(m) = M$, then the above expression will produce the empty set after filtering with the topology. Going over each $M$ then is equivalent to going over each $m$ so long as we throw away imports $\mathit{in}$ that are empty.

  \end{proof}


\end{lem}


\begin{thm}
  For any context $\Gamma$, concrete topology $G$, abstract topology $G^A$, homomorphism $f : G \rightarrow G^A$:

  $$con(compile(pol,G^A),\Gamma,f,G) = compile(con(pol,\Gamma,f),G)$$

  \begin{proof} \text{ }

    Suppose that $pol = p_1, \dots, p_n$. Each $p_i$ has the form $(t_i ~\Path~ r_{i1} ~\Prefer~,\dots, ~\Prefer~ r_{ik})$. Then by evaulating:

    \[ \begin{array}{lcl}
      con(pol,\Gamma,f) & = & con(p_1,\dots,p_n,\Gamma,f) \\
                        & = & con(p_1,\Gamma,f), \dots, con(p_n,\Gamma,f) \\
                        & = & con(t_1 ~\Path~ r_{11} ~\Prefer~,\dots, ~\Prefer~ r_{1k},\Gamma,f), \\
                        &   & \dots, \\
                        &   & con(t_n ~\Path~ r_{n1} ~\Prefer~,\dots, ~\Prefer~ r_{nk},\Gamma,f) \\
    \end{array} \]

    For each test $t_i$, if $t_i = pfx$, then we get 

    \[ \begin{array}{ll}
          & con({pfx}_{i1} ~\Path~ r_{i1} ~\Prefer~,\dots, ~\Prefer~ r_{ik},\Gamma,f) \\
        = & {pfx}_{i1} ~\Path~ con(r_{i1},\Gamma,f) ~\Prefer~,\dots, ~\Prefer~ con(r_{ik},\Gamma,f) \\
    \end{array} \]

    For each test $t_i$, if $t_i = \$x$, then we get

    \[ \begin{array}{lcl}
        con(\$x_{i} ~\Path~ r_{i1} ~\Prefer~,\dots, ~\Prefer~ r_{ik},\Gamma,f) 
            & = & {pfx}_{i1} ~\Path~ con(r_{i1},\Gamma,f) \cap \text{end}(l_{i1}) ~\Prefer~,\dots, ~\Prefer~ con(r_{ik},\Gamma,f) \cap \text{end}(l_{i1}), \\
            &   & \dots, \\ 
            &   & {pfx}_{ij} ~\Path~ con(r_{i1},\Gamma,f) \cap \text{end}(l_{ij}) ~\Prefer~,\dots, ~\Prefer~ con(r_{ik},\Gamma,f) \cap \text{end}(l_{ij}), \\
            &   & \\
            &   & \text{for each } (pfx_{ij}, l_{ij}) \in \Gamma(x) \\
    \end{array} \]

    Next we compute $compile(con(pol,\Gamma,f), G)$:

    \[ \begin{array}{ll}
        & compile(con(pol,\Gamma,f), G)  \\
                          & \\
                         =& compile_{mBGP}( \\
                          &  ~~~~ compile_{PG}(pfx_{11} ~\Path~ r'_{111} ~\Prefer~,\dots, ~\Prefer~ r'_{11k},G ), \\
                          &  ~~~~ \dots, \\
                          &  ~~~~ compile_{PG}(pfx_{1j} ~\Path~ r'_{1j1} ~\Prefer~,\dots, ~\Prefer~ r'_{1jk},G ), \\
                          &  ~~~~ \dots, \\
                          &  ~~~~ compile_{PG}(pfx_{i1} ~\Path~ r'_{i11} ~\Prefer~,\dots, ~\Prefer~ r'_{i1k},G ), \\
                          &  ~~~~ \dots, \\
                          &  ~~~~ compile_{PG}(pfx_{ij} ~\Path~ r'_{ij1} ~\Prefer~,\dots, ~\Prefer~ r'_{ijk},G ) \\
                          &  ) \\
    \end{array} \]
 
    \vspace{.5em}
    This results in a series of prefixes, product graphs, and orderings of the form: $(pfx_{ij}, PG_{ij}, ord_{ij})$.

    \vspace{1em}
    Similarly, we can compute $compile(pol, G^A)$:

    \[ \begin{array}{ll}
        & compile(pol,G^A)  \\
                      & \\
                     =& compile_{mBGP}( \\
                      & ~~~~ compile_{PG}(t_1 ~\Path~ r_{11} ~\Prefer~,\dots, ~\Prefer~ r_{1k}, G^A ), \\
                      & ~~~~ \dots, \\
                      & ~~~~ compile_{PG}(t_i ~\Path~ r_{i1} ~\Prefer~,\dots, ~\Prefer~ r'_{ik}, G^A ), \\
                      & ) \\
    \end{array} \]

    This results in a series of prefixes, product graphs, and orderings of the form $(t_i, PG^A_i, ord^A_i)$.

    We know the follwing:

    \begin{itemize}
      \item each $PG^A_i$ and $PG_{ij}$ are related by $f_{pg}$
      \vspace{-.2em}
      \item each $ord^A_i$ and $ord_{ij}$ have the property that $ord^A(f_{pg}(m)) = ord_{ij}(m)$
    \end{itemize}
    


  \[ \begin{array}{l}
     con(\textbf{compile}_\textbf{mBGP}( (t_1,PG^A_1,ord^A_1), \dots, (t^A_i,PG^A_i,ord^A_i) ), \Gamma,f,G) \\
  \end{array} \]%

Unfold definition of $\text{compile}_\text{mBGP}$

  \[ \begin{array}{l}
     ~~~~~ con([~ l \rightarrow rc ~\vert~ \\
     ~~~~~~~~~ l \in internal(G^A.V), \\
     ~~~~~~~~~ rc = \mathit{append}_i~  \\
     ~~~~~~~~~~~~~~~ [~ t_i \rightarrow ma_1, \dots, ma_k ~\vert~ \\
     ~~~~~~~~~~~~~~~~~~~~~ M \leftarrow (l,q_M) \in PG^A_i, \\
     ~~~~~~~~~~~~~~~~~~~~~ pin \leftarrow \text{adjIn}(PG^A_i,M), \\
     ~~~~~~~~~~~~~~~~~~~~~ (in,q_n) \leftarrow \{ (BS,q_N) ~\vert~ (\_,q_N) \in pin, BS=\{B ~\vert~ (B,q_N) \in pin \} \}, \\
     ~~~~~~~~~~~~~~~~~~~~~ out \leftarrow \{ C ~\vert~ (C,\_) \in \text{adjOut}(PG^A_i,M) \}, \\
     ~~~~~~~~~~~~~~~~~~~~~ in \neq \emptyset, \\
     ~~~~~~~~~~~~~~~~~~~~~ ma_h = ord^A_i(M) : (in,q_N) \rightarrow (out,q_M) ~] ~], \Gamma,f,G) \\
  \end{array} \]%

  Apply the definition of $con$

  \[ \begin{array}{l}
     ~~~~~ [~ \ell \rightarrow con(rc,\ell,\Gamma,f,G) ~\vert~ \\
     ~~~~~~~~~ \ell \in f^{-1}(l), \\
     ~~~~~~~~~ l \in internal(G^A.V), \\
     ~~~~~~~~~ rc = \mathit{append}_i~  \\
     ~~~~~~~~~~~~~~~ [~ t_i \rightarrow ma_1, \dots, ma_k ~\vert~ \\
     ~~~~~~~~~~~~~~~~~~~~~ M \leftarrow (l,q_M) \in PG^A_i, \\
     ~~~~~~~~~~~~~~~~~~~~~ pin \leftarrow \text{adjIn}(PG^A_i,M), \\
     ~~~~~~~~~~~~~~~~~~~~~ (in,q_N) \leftarrow \{ (bs,q_N) ~\vert~ (\_,q_N) \in pin, BS=\{B ~\vert~ (B,q_n) \in pin \} \}, \\
     ~~~~~~~~~~~~~~~~~~~~~ out \leftarrow \{ C ~\vert~ (C,\_) \in \text{adjOut}(PG_i,M) \}, \\
     ~~~~~~~~~~~~~~~~~~~~~ in \neq \emptyset, \\
     ~~~~~~~~~~~~~~~~~~~~~ ma_h = ord^A_i(M) : (in,q_N) \rightarrow (out,q_M) ~] ~] \\
  \end{array} \]%

  Rewrite $con$ on $rc$

  \[ \begin{array}{l}
     ~~~~~ [~ \ell \rightarrow con(rc,\ell,\Gamma,f,G) ~\vert~ \\
     ~~~~~~~~~ \ell \in f^{-1}(l), \\
     ~~~~~~~~~ l \in internal(G^A.V), \\
     ~~~~~~~~~ rc = con(\mathit{append}_i~  \\
     ~~~~~~~~~~~~~~~ [~ t_i \rightarrow ma_1, \dots, ma_k ~\vert~ \\
     ~~~~~~~~~~~~~~~~~~~~~ M \leftarrow (l,q_M) \in PG^A_i, \\
     ~~~~~~~~~~~~~~~~~~~~~ pin \leftarrow \text{adjIn}(PG^A_i,M), \\
     ~~~~~~~~~~~~~~~~~~~~~ (in,q_N) \leftarrow \{ (BS,q_N) ~\vert~ (\_,q_N) \in pin, BS=\{B ~\vert~ (B,q_N) \in pin \} \}, \\
     ~~~~~~~~~~~~~~~~~~~~~ out \leftarrow \{ C ~\vert~ (C,\_) \in \text{adjOut}(PG_i,M) \}, \\
     ~~~~~~~~~~~~~~~~~~~~~ in \neq \emptyset, \\
     ~~~~~~~~~~~~~~~~~~~~~ ma_h = ord^A_i(m) : (in,q_N) \rightarrow (out,q_M) ~],\ell,\Gamma,f,G) ~] \\
  \end{array} \]%

  Apply definition of $con$

  \[ \begin{array}{l}
     ~~~~~ [~ \ell \rightarrow con(rc,\ell,\Gamma,f,G) ~\vert~ \\
     ~~~~~~~~~ \ell \in f^{-1}(l), \\
     ~~~~~~~~~ l \in internal(G^A.V), \\
     ~~~~~~~~~ rc = \mathit{append}_i~  \\
     ~~~~~~~~~~~~~~~ con([~ t_i \rightarrow ma_1, \dots, ma_k ~\vert~ \\
     ~~~~~~~~~~~~~~~~~~~~~ M \leftarrow (l,q_M) \in PG^A_i, \\
     ~~~~~~~~~~~~~~~~~~~~~ pin \leftarrow \text{adjIn}(PG^A_i,M), \\
     ~~~~~~~~~~~~~~~~~~~~~ (in,q_N) \leftarrow \{ (BS,q_N) ~\vert~ (\_,q_N) \in pin, BS=\{B ~\vert~ (B,q_N) \in pin \} \}, \\
     ~~~~~~~~~~~~~~~~~~~~~ out \leftarrow \{ C ~\vert~ (C,\_) \in \text{adjOut}(PG^A_i,M) \}, \\
     ~~~~~~~~~~~~~~~~~~~~~ in \neq \emptyset, \\
     ~~~~~~~~~~~~~~~~~~~~~ ma_h = ord^A_i(m) : (in,q_N) \rightarrow (out,q_M) ~],\ell,\Gamma,f,G) ~] \\
  \end{array} \]%

  \vspace{1em}
  \textbf{Case 1}: Assume $t_i = pfx_{i1}$. Look at:

  \[ \begin{array}{l}
     ~~~~~~~~~ con([~ \Pfx_{i1} \rightarrow ma_1, \dots, ma_k ~\vert~ \\
     ~~~~~~~~~~~~~~~~~~ M \leftarrow (l,q_M) \in PG^A_i, \\
     ~~~~~~~~~~~~~~~~~~ pin \leftarrow \text{adjIn}(PG^A_i,M), \\
     ~~~~~~~~~~~~~~~~~~ (in,q_N) \leftarrow \{ (BS,q_N) ~\vert~ (\_,q_N) \in pin, BS=\{B ~\vert~ (B,q_N) \in pin \} \}, \\
     ~~~~~~~~~~~~~~~~~~ out \leftarrow \{ C ~\vert~ (C,\_) \in \text{adjOut}(PG^A_i,M) \}, \\
     ~~~~~~~~~~~~~~~~~~ in \neq \emptyset, \\
     ~~~~~~~~~~~~~~~~~~ ma_h = ord^A_i(M) : (in,q_N) \rightarrow (out,q_M) ~],\ell,\Gamma,f,G) \\
  \end{array} \]%

  Apply definition of $con$

  \[ \begin{array}{l}
     ~~~~~~~~~ [~ \Pfx_{i1} \rightarrow con(ma_1, \dots, ma_k,\text{true},\ell,\Gamma,f,G) ~\vert~ \\
     ~~~~~~~~~~~~~~~~~~ M \leftarrow (l,q_M) \in PG^A_i, \\
     ~~~~~~~~~~~~~~~~~~ pin \leftarrow \text{adjIn}(PG^A_i,M), \\
     ~~~~~~~~~~~~~~~~~~ (in,q_N) \leftarrow \{ (BS,q_N) ~\vert~ (\_,q_N) \in pin, BS=\{B ~\vert~ (B,q_N) \in pin \} \}, \\
     ~~~~~~~~~~~~~~~~~~ out \leftarrow \{ C ~\vert~ (C,\_) \in \text{adjOut}(PG^A_i,M) \}, \\
     ~~~~~~~~~~~~~~~~~~ in \neq \emptyset, \\
     ~~~~~~~~~~~~~~~~~~ ma_h = ord^A_i(M) : (in,q_N) \rightarrow (out,q_M) ~] \\
  \end{array} \]%

  Apply definition of $con$

  \[ \begin{array}{l}
     ~~~~~~~~~ [~ \Pfx_{i1} \rightarrow con(ma_1,\text{true},\ell,\Gamma,f,G), \dots, con(ma_k,\text{true},\ell,\Gamma,f,G) ~\vert~ \\
     ~~~~~~~~~~~~~~~~~~ M \leftarrow (l,q_M) \in PG^A_i, \\
     ~~~~~~~~~~~~~~~~~~ pin \leftarrow \text{adjIn}(PG^A_i,M), \\
     ~~~~~~~~~~~~~~~~~~ (in,q_N) \leftarrow \{ (BS,q_N) ~\vert~ (\_,q_N) \in pin, BS=\{B ~\vert~ (B,q_N) \in pin \} \}, \\
     ~~~~~~~~~~~~~~~~~~ out \leftarrow \{ C ~\vert~ (C,\_) \in \text{adjOut}(PG^A_i,M) \}, \\
     ~~~~~~~~~~~~~~~~~~ in \neq \emptyset, \\
     ~~~~~~~~~~~~~~~~~~ ma_h = ord^A_i(M) : (in,q_N) \rightarrow (out,q_M) ~] \\
  \end{array} \]%

  Apply definition of $con$

  \[ \begin{array}{l}
     ~~~~~~~~~ [~ \Pfx_{i1} \rightarrow ma_1, \dots, ma_k ~\vert~ \\
     ~~~~~~~~~~~~~~~~~~ M \leftarrow (l,q_M) \in PG^A_i, \\
     ~~~~~~~~~~~~~~~~~~ pin \leftarrow \text{adjIn}(PG^A_i,M), \\
     ~~~~~~~~~~~~~~~~~~ (in,q_N) \leftarrow \{ (BS,q_N) ~\vert~ (\_,q_N) \in pin, BS=\{B ~\vert~ (B,q_N) \in pin \} \}, \\
     ~~~~~~~~~~~~~~~~~~ out \leftarrow \{ C ~\vert~ (C,\_) \in \text{adjOut}(PG^A_i,M) \}, \\
     ~~~~~~~~~~~~~~~~~~ in \neq \emptyset, \\
     ~~~~~~~~~~~~~~~~~~ ma_h = con(ord^A_i(M) : (in,q_N) \rightarrow (out,q_M),\text{true},\ell,\Gamma,f,G) ~] \\
  \end{array} \]%

  Apply definition of $con$

  \[ \begin{array}{l}
     ~~~~~~~~~ [~ \Pfx_{i1} \rightarrow ma_1, \dots, ma_k ~\vert~ \\
     ~~~~~~~~~~~~~~~~~~ M \leftarrow (l,q_M) \in PG^A_i, \\
     ~~~~~~~~~~~~~~~~~~ pin \leftarrow \text{adjIn}(PG^A_i,M), \\
     ~~~~~~~~~~~~~~~~~~ (in,q_N) \leftarrow \{ (BS,q_N) ~\vert~ (\_,q_N) \in pin, BS=\{B ~\vert~ (B,q_N) \in pin \} \}, \\
     ~~~~~~~~~~~~~~~~~~ out \leftarrow \{ C ~\vert~ (C,\_) \in \text{adjOut}(PG^A_i,M) \}, \\
     ~~~~~~~~~~~~~~~~~~ in \neq \emptyset, \\
     ~~~~~~~~~~~~~~~~~~ ma_h = ord^A_i(M) : (con(in,\ell,\Gamma,f,G),q_N) \rightarrow (con(out,\ell,\Gamma,f,G),q_M),\ell,\Gamma,f,G) ~] \\
  \end{array} \]%

  Rewrite on $in$ and $out$

  \[ \begin{array}{l}
     ~~~~~~~~~ [~ \Pfx_{i1} \rightarrow ma_1, \dots, ma_k ~\vert~ \\
     ~~~~~~~~~~~~~~~~~~ M \leftarrow (l,q_M) \in PG^A_i, \\
     ~~~~~~~~~~~~~~~~~~ pin \leftarrow \text{adjIn}(PG^A_i,M), \\
     ~~~~~~~~~~~~~~~~~~ (con(in,\ell,\Gamma,f,G),q_N) \leftarrow \{ (BS,q_N) ~\vert~ (\_,q_N) \in pin, BS=\{B ~\vert~ (B,q_N) \in pin \} \}, \\
     ~~~~~~~~~~~~~~~~~~ out \leftarrow con(\{ C ~\vert~ (C,\_) \in \text{adjOut}(PG^A_i,M) \},\ell,\Gamma,f,G)), \\
     ~~~~~~~~~~~~~~~~~~ in \neq \emptyset, \\
     ~~~~~~~~~~~~~~~~~~ ma_h = ord^A_i(M) : (in,q_N) \rightarrow (out,q_M),\ell,\Gamma,f,G) ~] \\
  \end{array} \]%

  Rewrite $con$ on $in$

  \[ \begin{array}{l}
     ~~~~~~~~~ [~ \Pfx_{i1} \rightarrow ma_1, \dots, ma_k ~\vert~ \\
     ~~~~~~~~~~~~~~~~~~ M \leftarrow (l,q_M) \in PG^A_i, \\
     ~~~~~~~~~~~~~~~~~~ pin \leftarrow \text{adjIn}(PG^A_i,M), \\
     ~~~~~~~~~~~~~~~~~~ (in,q_N) \leftarrow \{ (BS,q_N) ~\vert~ (\_,q_N) \in pin, BS=con(\{B ~\vert~ (B,q_N) \in pin \},\ell,\Gamma,f,G) \}, \\
     ~~~~~~~~~~~~~~~~~~ out \leftarrow con(\{ C ~\vert~ (C,\_) \in \text{adjOut}(PG^A_i,M) \},\ell,\Gamma,f,G)), \\
     ~~~~~~~~~~~~~~~~~~ in \neq \emptyset, \\
     ~~~~~~~~~~~~~~~~~~ ma_h = ord^A_i(M) : (in,q_N) \rightarrow (out,q_M),\ell,\Gamma,f,G) ~] \\
  \end{array} \]%

  Apply definition of $con$

  \[ \begin{array}{l}
     ~~~~~~~~~ [~ \Pfx_{i1} \rightarrow ma_1, \dots, ma_k ~\vert~ \\
     ~~~~~~~~~~~~~~~~~~ M \leftarrow (l,q_M) \in PG^A_i, \\
     ~~~~~~~~~~~~~~~~~~ pin \leftarrow \text{adjIn}(PG^A_i,M), \\
     ~~~~~~~~~~~~~~~~~~ (in,q_N) \leftarrow \{ (BS,q_N) ~\vert~ (\_,q_N) \in pin, BS=\{b ~\vert~ b \in f^{-1}(B),~ (b,\ell) \in G.E,~ (B,q_N) \in pin \} \}, \\
     ~~~~~~~~~~~~~~~~~~ out \leftarrow \{c~\vert~ c \in f^{-1}(C),~ (c,\ell) \in G.E,~ (C,\_) \in \text{adjOut}(PG^A_i,M) \},\ell,\Gamma,f,G)), \\
     ~~~~~~~~~~~~~~~~~~ in \neq \emptyset, \\
     ~~~~~~~~~~~~~~~~~~ ma_h = ord^A_i(M) : (in,q_N) \rightarrow (out,q_M),\ell,\Gamma,f,G) ~] \\
  \end{array} \]%

  From the relation between concrete ($PG$) and abstract ($PG^A$) product graphs given by the previous lemma

  \[ \begin{array}{l}
     ~~~~~~~~~ [~ \Pfx_{i1} \rightarrow ma_1, \dots, ma_k ~\vert~ \\
     ~~~~~~~~~~~~~~~~~~ m \leftarrow (l,q_M) \in PG_{i1}, \\
     ~~~~~~~~~~~~~~~~~~ pin \leftarrow \text{adjIn}(PG_{i1},m), \\
     ~~~~~~~~~~~~~~~~~~ (in,q_N) \leftarrow \{ (bs,q_N) ~\vert~ (\_,q_N) \in pin, bs=\{ b ~\vert~ (b,q_N) \in ping \} \}), \\
     ~~~~~~~~~~~~~~~~~~ out \leftarrow \{ c ~\vert~ (c,\_) \in \text{adjOut}(PG_{i1},m) \}, \\
     ~~~~~~~~~~~~~~~~~~ in \neq \emptyset, \\
     ~~~~~~~~~~~~~~~~~~ ma_h = ord^A_i(f_{pg}(m)) : (in,q_N) \rightarrow (out,q_M) ~] \\
  \end{array} \]%

  Since $ord^A_i(f_{pg}(m)) = ord_{i1}(m)$

  \[ \begin{array}{l}
     ~~~~~~~~~ [~ \Pfx_{i1} \rightarrow ma_1, \dots, ma_k ~\vert~ \\
     ~~~~~~~~~~~~~~~~~~ m \leftarrow (l,q_M) \in PG_{i1}, \\
     ~~~~~~~~~~~~~~~~~~ pin \leftarrow \text{adjIn}(PG_{i1},m), \\
     ~~~~~~~~~~~~~~~~~~ (in,q_N) \leftarrow \{ (bs,q_N) ~\vert~ (\_,q_N) \in pin, bs=\{ b ~\vert~ (b,q_N) \in ping \} \}), \\
     ~~~~~~~~~~~~~~~~~~ out \leftarrow \{ c ~\vert~ (c,\_) \in \text{adjOut}(PG_{i1},m) \}, \\
     ~~~~~~~~~~~~~~~~~~ in \neq \emptyset, \\
     ~~~~~~~~~~~~~~~~~~ ma_h = ord_{i1}(m) : (in,q_N) \rightarrow (out,q_M) ~] \\
  \end{array} \]%

  Since product graphs have equivalent states

  \[ \begin{array}{l}
     ~~~~~~~~~ [~ \Pfx_{i1} \rightarrow ma_1, \dots, ma_k ~\vert~ \\
     ~~~~~~~~~~~~~~~~~~ m \leftarrow (l,q_m) \in PG_{i1}, \\
     ~~~~~~~~~~~~~~~~~~ pin \leftarrow \text{adjIn}(PG_{i1},m), \\
     ~~~~~~~~~~~~~~~~~~ (in,q_n) \leftarrow \{ (bs,q_n) ~\vert~ (\_,q_n) \in pin, bs=\{ b ~\vert~ (b,q_n) \in ping \} \}), \\
     ~~~~~~~~~~~~~~~~~~ out \leftarrow \{ c ~\vert~ (c,\_) \in \text{adjOut}(PG_{i1},m) \}, \\
     ~~~~~~~~~~~~~~~~~~ in \neq \emptyset, \\
     ~~~~~~~~~~~~~~~~~~ ma_h = ord_{i1}(m) : (in,q_n) \rightarrow (out,q_m) ~] \\
  \end{array} \]%

  \vspace{1em}
  \textbf{Case 2}: Assume $t_i = \$x$

  \[ \begin{array}{l}
     ~~~~~~~~~ con([~ \$x \rightarrow ma_1, \dots, ma_k ~\vert~ \\
     ~~~~~~~~~~~~~~~~~~ M \leftarrow (l,q_M) \in PG^A_i, \\
     ~~~~~~~~~~~~~~~~~~ pin \leftarrow \text{adjIn}(PG^A_i,M), \\
     ~~~~~~~~~~~~~~~~~~ (in,q_N) \leftarrow \{ (BS,q_N) ~\vert~ (\_,q_N) \in pin, BS=\{B ~\vert~ (B,q_N) \in pin \} \}, \\
     ~~~~~~~~~~~~~~~~~~ out \leftarrow \{ C ~\vert~ (C,\_) \in \text{adjOut}(PG^A_i,M) \}, \\
     ~~~~~~~~~~~~~~~~~~ in \neq \emptyset, \\
     ~~~~~~~~~~~~~~~~~~ ma_h = ord^A_i(M) : (in,q_N) \rightarrow (out,q_M) ~],\ell,\Gamma,f,G) \\
  \end{array} \]% 

  Apply the definition of $con$

  \[ \begin{array}{l}
     ~~~~~~~~~ [~ \Pfx_{ij} \rightarrow con(ma_1, \dots, ma_k,\ell,\Gamma,f,G) ~\vert~ \\
     ~~~~~~~~~~~~~~~~~~ (\Pfx_{ij},l_{ij}) \in \Gamma(x), \\
     ~~~~~~~~~~~~~~~~~~ M \leftarrow (l,q_M) \in PG^A_i, \\
     ~~~~~~~~~~~~~~~~~~ pin \leftarrow \text{adjIn}(PG^A_i,M), \\
     ~~~~~~~~~~~~~~~~~~ (in,q_N) \leftarrow \{ (BS,q_N) ~\vert~ (\_,q_N) \in pin, BS=\{B ~\vert~ (B,q_N) \in pin \} \}, \\
     ~~~~~~~~~~~~~~~~~~ out \leftarrow \{ C ~\vert~ (C,\_) \in \text{adjOut}(PG^A_i,M) \}, \\
     ~~~~~~~~~~~~~~~~~~ in \neq \emptyset, \\
     ~~~~~~~~~~~~~~~~~~ ma_h = ord^A_i(M) : (in,q_N) \rightarrow (out,q_M) ~] \\
  \end{array} \]%

  Apply definition $con$

  \[ \begin{array}{l}
     ~~~~~~~~~ [~ \Pfx_{ij} \rightarrow con(ma_1,\ell,\Gamma,f,G), \dots, \\ 
     ~~~~~~~~~~~~~~~~~~~~~~~~~~ con(ma_k,\ell,\Gamma,f,G) ~\vert~ \\
     ~~~~~~~~~~~~~~~~~~ (\Pfx_{ij},l_{ij}) \in \Gamma(x), \\
     ~~~~~~~~~~~~~~~~~~ M \leftarrow (l,q_M) \in PG^A_i, \\
     ~~~~~~~~~~~~~~~~~~ pin \leftarrow \text{adjIn}(PG^A_i,M), \\
     ~~~~~~~~~~~~~~~~~~ (in,q_N) \leftarrow \{ (BS,q_N) ~\vert~ (\_,q_N) \in pin, BS=\{B ~\vert~ (B,q_N) \in pin \} \}, \\
     ~~~~~~~~~~~~~~~~~~ out \leftarrow \{ C ~\vert~ (C,\_) \in \text{adjOut}(PG^A_i,M) \}, \\
     ~~~~~~~~~~~~~~~~~~ in \neq \emptyset, \\
     ~~~~~~~~~~~~~~~~~~ ma_h = ord^A_i(M) : (in,q_N) \rightarrow (out,q_M) ~] \\
  \end{array} \]%

  Rewrite $con$ on $ma_h$.

  \[ \begin{array}{l}
     ~~~~~~~~~ [~ \Pfx_{ij} \rightarrow ma_1, \dots, ma_k ~\vert~ \\ 
     ~~~~~~~~~~~~~~~~~~ (\Pfx_{ij},l_{ij}) \in \Gamma(x), \\
     ~~~~~~~~~~~~~~~~~~ M \leftarrow (l,q_M) \in PG^A_i, \\
     ~~~~~~~~~~~~~~~~~~ pin \leftarrow \text{adjIn}(PG^A_i,M), \\
     ~~~~~~~~~~~~~~~~~~ (in,q_N) \leftarrow \{ (BS,q_N) ~\vert~ (\_,q_N) \in pin, BS=\{B ~\vert~ (B,q_N) \in pin \} \}, \\
     ~~~~~~~~~~~~~~~~~~ out \leftarrow \{ C ~\vert~ (C,\_) \in \text{adjOut}(PG^A_i,M) \}, \\
     ~~~~~~~~~~~~~~~~~~ in \neq \emptyset, \\
     ~~~~~~~~~~~~~~~~~~ ma_h = con(ord^A_i(M) : (in,q_N) \rightarrow (out,q_M),l_{ij},\ell,\Gamma,f,G) ~] \\
  \end{array} \]%

  Apply definition of $con$

  \[ \begin{array}{l}
     ~~~~~~~~~ [~ \Pfx_{ij} \rightarrow ma_1, \dots, ma_k ~\vert~ \\ 
     ~~~~~~~~~~~~~~~~~~ (\Pfx_{ij},l_{ij}) \in \Gamma(x), \\
     ~~~~~~~~~~~~~~~~~~ M \leftarrow (l,q_M) \in PG^A_i, \\
     ~~~~~~~~~~~~~~~~~~ pin \leftarrow \text{adjIn}(PG^A_i,M), \\
     ~~~~~~~~~~~~~~~~~~ (in,q_N) \leftarrow \{ (BS,q_N) ~\vert~ (\_,q_N) \in pin, BS=\{B ~\vert~ (B,q_N) \in pin \} \}, \\
     ~~~~~~~~~~~~~~~~~~ out \leftarrow \{ C ~\vert~ (C,\_) \in \text{adjOut}(PG^A_i,M) \}, \\
     ~~~~~~~~~~~~~~~~~~ in \neq \emptyset, \\
     ~~~~~~~~~~~~~~~~~~ ma_h = \textbf{if}~ in=\{ G.s \} \text{ and } l_{ij} \neq \ell ~\textbf{then}~ \bullet \\ 
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ \textbf{else}~ ord^A_i(M) : (con(in,\ell,\Gamma,f,G),q_N) \rightarrow (con(out,\ell,\Gamma,f,G),q_M) \} \\
  \end{array} \]%

  \textbf{Observation}: 
  By filtering the cases where $in = \{ \mathit{start} \}$ and $l_{ij} \neq \ell$ we get the same thing as before after applying the definition of $con$ for each $(pfx_{ij}, l_{ij}) \in \Gamma(x)$.

 \[ \begin{array}{l}
     ~~~~~~~~~ [~ \Pfx_{ij} \rightarrow ma_1, \dots, ma_k ~\vert~ \\
     ~~~~~~~~~~~~~~~~~~ (pfx_{ij}, l_{ij}) \in \Gamma(x), \\
     ~~~~~~~~~~~~~~~~~~ m \leftarrow (l,q_m) \in PG_{ij}, \\
     ~~~~~~~~~~~~~~~~~~ pin \leftarrow \text{adjIn}(PG_{ij},m), \\
     ~~~~~~~~~~~~~~~~~~ (in,q_n) \leftarrow \{ (bs,q_n) ~\vert~ (\_,q_n) \in pin, bs=\{ b ~\vert~ (b,q_n) \in ping \} \}), \\
     ~~~~~~~~~~~~~~~~~~ out \leftarrow \{ c ~\vert~ (c,\_) \in \text{adjOut}(PG_{ij},m) \}, \\
     ~~~~~~~~~~~~~~~~~~ in \neq \emptyset, \\
     ~~~~~~~~~~~~~~~~~~ ma_h = ord_{i1}(m) : (in,q_n) \rightarrow (out,q_m) ~] \\
  \end{array} \]%

  This works because each $PG_{ij}$ was constructed from $con(r_{ijk}) \cap end(l_{ij})$. This means that the only state in $PG_{ij}$ connected to the start node ($\mathit{start}$) is a node for $l_{ij}$. This was ensured by the fact that the transition function for each regular expression $\sigma_{ijk}(q_0,l) = q$ is defined only for locations $l \in L$ where $L = \{ l_{ij} \}$ from the construction of the automata.

  \vspace{1em}
  \textbf{Merging Cases}:

  In the first case, we got a result of the form:

  \[ \begin{array}{l}
     ~~~~~~~~~ [~ \Pfx_{i1} \rightarrow ma_1, \dots, ma_k ~\vert~ \\
     ~~~~~~~~~~~~~~~~~~ m \leftarrow (l,q_m) \in PG_{i1}, \\
     ~~~~~~~~~~~~~~~~~~ pin \leftarrow \text{adjIn}(PG_{i1},m), \\
     ~~~~~~~~~~~~~~~~~~ (in,q_n) \leftarrow \{ (bs,q_n) ~\vert~ (\_,q_n) \in pin, bs=\{ b ~\vert~ (b,q_n) \in ping \} \}), \\
     ~~~~~~~~~~~~~~~~~~ out \leftarrow \{ c ~\vert~ (c,\_) \in \text{adjOut}(PG_{i1},m) \}, \\
     ~~~~~~~~~~~~~~~~~~ in \neq \emptyset, \\
     ~~~~~~~~~~~~~~~~~~ ma_h = ord_{i1}(m) : (in,q_n) \rightarrow (out,q_m) ~] \\
  \end{array} \]%

  In the second case, we got a result of the form:

 \[ \begin{array}{l}
     ~~~~~~~~~ [~ \Pfx_{ij} \rightarrow ma_1, \dots, ma_k ~\vert~ \\
     ~~~~~~~~~~~~~~~~~~ (pfx_{ij}, l_{ij}) \in \Gamma(x), \\
     ~~~~~~~~~~~~~~~~~~ m \leftarrow (l,q_m) \in PG_{ij}, \\
     ~~~~~~~~~~~~~~~~~~ pin \leftarrow \text{adjIn}(PG_{ij},m), \\
     ~~~~~~~~~~~~~~~~~~ (in,q_n) \leftarrow \{ (bs,q_n) ~\vert~ (\_,q_n) \in pin, bs=\{ b ~\vert~ (b,q_n) \in ping \} \}), \\
     ~~~~~~~~~~~~~~~~~~ out \leftarrow \{ c ~\vert~ (c,\_) \in \text{adjOut}(PG_{ij},m) \}, \\
     ~~~~~~~~~~~~~~~~~~ in \neq \emptyset, \\
     ~~~~~~~~~~~~~~~~~~ ma_h = ord_{ij}(m) : (in,q_n) \rightarrow (out,q_m) ~] \\
  \end{array} \]%

  Putting these together, we get the following:

  \[ \begin{array}{l}
     ~~~~~ [~ \ell \rightarrow rc ~\vert~ \\
     ~~~~~~~~~ \ell \in f^{-1}(l), \\
     ~~~~~~~~~ l \in internal(G^A.V), \\
     ~~~~~~~~~ rc = \mathit{append}_{ij}~  \\
     ~~~~~~~~~~~~~~~ [~ \Pfx_{ij} \rightarrow ma_1, \dots, ma_k ~\vert~ \\
     ~~~~~~~~~~~~~~~~~~~~~ m \leftarrow (l,q_m) \in PG_{ij}, \\
     ~~~~~~~~~~~~~~~~~~~~~ pin \leftarrow \text{adjIn}(PG_{ij},m), \\
     ~~~~~~~~~~~~~~~~~~~~~ (in,q_n) \leftarrow \{ (bs,q_n) ~\vert~ (\_,q_n) \in pin, bs=\{b ~\vert~ (b,q_n) \in pin \} \}, \\
     ~~~~~~~~~~~~~~~~~~~~~ out \leftarrow \{ c ~\vert~ (c,\_) \in \text{adjOut}(PG_{ij},m) \}, \\
     ~~~~~~~~~~~~~~~~~~~~~ in \neq \emptyset, \\
     ~~~~~~~~~~~~~~~~~~~~~ ma_h = ord_{ij}(m) : (in,q_n) \rightarrow (out,q_m) ~] ~] \\
  \end{array} \]%


  Finally, we observe that this is equivalent to the following:

  \[ \begin{array}{l}
     ~~~~~ [~ l \rightarrow rc ~\vert~ \\
     ~~~~~~~~~ l \in internal(G.V), \\
     ~~~~~~~~~ rc = \mathit{append}_{ij}~  \\
     ~~~~~~~~~~~~~~~ [~ \Pfx_{ij} \rightarrow ma_1, \dots, ma_k ~\vert~ \\
     ~~~~~~~~~~~~~~~~~~~~~ m \leftarrow (l,q_m) \in PG_{ij}, \\
     ~~~~~~~~~~~~~~~~~~~~~ pin \leftarrow \text{adjIn}(PG_{ij},m), \\
     ~~~~~~~~~~~~~~~~~~~~~ (in,q_n) \leftarrow \{ (bs,q_n) ~\vert~ (\_,q_n) \in pin, bs=\{b ~\vert~ (b,q_n) \in pin \} \}, \\
     ~~~~~~~~~~~~~~~~~~~~~ out \leftarrow \{ c ~\vert~ (c,\_) \in \text{adjOut}(PG_{ij},m) \}, \\
     ~~~~~~~~~~~~~~~~~~~~~ in \neq \emptyset, \\
     ~~~~~~~~~~~~~~~~~~~~~ ma_h = ord_{ij}(m) : (in,q_n) \rightarrow (out,q_m) ~] ~] \\
  \end{array} \]%

  This is exactly the definition of compilation for the concretized policy

  \[ \begin{array}{l}
     = \textbf{compile}_\textbf{mBGP}( (pfx_{11},PG_{11},ord_{11}), \dots, (pfx_{ij},PG_{ij},ord_{ij}) ) \\
  \end{array} \]%


  \end{proof}

\end{thm}

\end{document}