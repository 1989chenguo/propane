\documentclass[twocolumn]{sig-alternate-10pt}
%\documentclass[twocolumn]{article}
%\documentclass[10pt]{sigalternate052015}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{xcolor}
\usepackage{url}
\usepackage{times}
\usepackage{xspace}
\usepackage{listings}
\usepackage{code}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\usepackage{tikz}
\usetikzlibrary{arrows,automata,positioning}
\let\proof\relax
\let\endproof\relax
\usepackage{amsthm}
\usepackage{subcaption}
\usepackage{balance}
\usepackage[ampersand]{easylist}
\usepackage{textcomp}
\usepackage{pifont}
\newcommand{\cmark}{\ding{51}}
\newcommand{\xmark}{\ding{55}}

\definecolor{princetonorange}{RGB}{255,143,0}
\definecolor{tmlblue}{RGB}{0,58,120}  % tmlblue == Toronto Maple Leafs Blue!

\newcommand{\todo}[1]{\textcolor{red}{[TODO: #1]}}
\newcommand{\ratul}[1]{\textcolor{blue}{[ratul: #1]}}
\newcommand{\ryan}[1]{\textcolor{green}{[ryan: #1]}}
\newcommand{\dpw}[1]{\textcolor{tmlblue}{[dpw: #1]}}
\newcommand{\todd}[1]{\textcolor{princetonorange}{[todd: #1]}}

\newcommand{\EG}{\emph{e.g.}}
\newcommand{\IE}{\emph{i.e.}}
\newcommand{\ETC}{\emph{etc.}}
\newcommand{\ETAL}{\emph{et al.}}

\newcommand{\sysname}{{\small \sf Methane}\xspace}
\newcommand{\sysnamesec}{{\sf Methane}\xspace}
\newcommand{\propane}{{\small \sf Propane}\xspace}

\newcommand{\para}[1]{\paragraph*{\textbf{#1}}}

\newcommand{\set}[1]{\ensuremath{\{ #1 \} }}
\newcommand{\abs}[1]{\ensuremath{ \lvert #1 \rvert }}

\newcommand{\CD}[1]{\texttt{\small #1}}  % code font
\newcommand{\KW}[1]{\texttt{\small\bfseries{#1}}}

\newcommand{\True}{\CD{true}}
\newcommand{\Define}{\KW{define}}
\newcommand{\Prefer}{\texttt{>>}}
\newcommand{\Path}{\texttt{=>}}
\newcommand{\Link}{\texttt{->}}
\newcommand{\Agg}{\KW{agg}}
\newcommand{\Any}{\KW{any}}
\newcommand{\None}{\KW{drop}}
\newcommand{\In}{\KW{in}}
\newcommand{\Out}{\KW{out}}
\newcommand{\AND}{\texttt{\&}}
\newcommand{\OR}{\texttt{|}}
\newcommand{\NOT}{\texttt{!}}
\newcommand{\Intersect}{\ensuremath{\cap}}
\newcommand{\Union}{\ensuremath{\cup}}

\newcommand{\Exit}{\KW{exit}}
\newcommand{\End}{\KW{end}}
\newcommand{\Start}{\KW{start}}
\newcommand{\Enter}{\KW{enter}}
\newcommand{\Eventually}{\KW{eventually}}
\newcommand{\Already}{\KW{already}}
\newcommand{\Internal}{\KW{internal}}
\newcommand{\Never}{\KW{never}}
\newcommand{\Always}{\KW{always}}
\newcommand{\Through}{\KW{through}}
\newcommand{\LinkKW}{\KW{link}}
\newcommand{\PathKW}{\KW{path}}
\newcommand{\Novalley}{\KW{novalley}}

\renewcommand{\path}[2]{ #1 \mapsto \ensuremath{#2} }

%% grammar
\newcommand{\BNFALT}{\;\;|\;\;}
\newcommand{\hdr}[2]{\flushleft \chdr{\hspace{5mm}#1}{#2}}
\newcommand{\chdr}[2]{\textbf{#1} {#2} \\ \centering}%

\newtheorem{thm}{Theorem}[section]
\newtheorem{defn}{Definition}
\newtheorem{lem}[thm]{Lemma}
\newtheorem*{cor}{Corollary}

\begin{document}

\special{papersize=8.5in,11in}
\setlength{\pdfpageheight}{\paperheight}
\setlength{\pdfpagewidth}{\paperwidth}

\appendix

\onecolumn
\section{Definitions}

\subsection{Methane}

The full \sysname syntax as well as expansions from constraints into regular expressions are shown in Figure~\ref{fig:syntax}. The language includes constraints of the form $\CD{\Agg(pfx, \ensuremath{r_1 \rightarrow r_2})}$ that say that aggregation for summary prefix $\CD{pfx}$ will occur from any single location matching $\CD{\ensuremath{r_1}}$ to any location matching $\CD{\ensuremath{r_2}}$.


\begin{figure*}[h!]\small
  \begin{minipage}[t]{.45\linewidth}
  \hdr{Syntax}{}
  \vspace*{-1\baselineskip}
  %
  \[ \begin{array}{rclr}
    \hline%

     pol     &::=& p_1, \dots, p_n & \textit{policies} \\
     p       &::=& t \hspace{.3em} \Path \hspace{.3em} r_1 \Prefer \dots \Prefer r_m \BNFALT cc & \textit{constraints} \\
     pfx     &::=& d.d.d.d/[d..d] & \textit{prefix} \\
     t       &::=& \$x & \textit{template variable} \\
         &\BNFALT& pfx & \textit{prefix test} \\
     r       &::=& l & \textit{location} \\
         &\BNFALT& \emptyset & \textit{empty set} \\
         &\BNFALT& \In & \textit{internal loc} \\
         &\BNFALT& \Out & \textit{external loc} \\
         &\BNFALT& r_1 \cup r_2 & \textit{union} \\
         &\BNFALT& r_1 \cap r_2 & \textit{intersection} \\
         &\BNFALT& r_1 \cdot r_2 & \textit{concatenation} \\
         &\BNFALT& \NOT r & \textit{path negation} \\
         &\BNFALT& r^* & \textit{iteration} \\
     cc     &::=& agg(pfx, r_1 \rightarrow r_2)  & \textit{control constraints} \\
  \end{array} \]%

  \end{minipage}
  %
  ~~
  \vrule
  ~~
  %
  \begin{minipage}[t]{.5\linewidth}\small
  \hdr{Expansions}{}
  \vspace*{-1\baselineskip}
  %
  \[\begin{array}{rcl}
    \hline
    \Any               & = & \Sigma^* \\
    \None              & = & \emptyset \\
    \Internal          & = & \In^+ \\
    \Always(X)         & = & X^* \\
    \Never(X)          & = & (!X)^* \\
    \Through(X)        & = & \Sigma^* \cdot X \cdot \Sigma^* \\
    \End(X)            & = & \Sigma^* \cdot X \\
    \Start(X)          & = & X \cdot \Sigma^* \\
    \Enter(X)          & = & \Sigma^* \cdot \Out \cdot (X \cap \In) \cdot \Sigma^* ~ \cup \\
                       &   & \Sigma^* \cdot (X \cap \Out) \cdot \In \cdot \Sigma^* \\
    \Exit(X)           & = & \Sigma^* \cdot \In \cdot (X \cap \Out) \cdot \Sigma^* ~ \cup \\
                       &   & \Sigma^* \cdot (X \cap \In) \cdot \Out \cdot \Sigma^* \\
    \LinkKW(X,Y)       & = & \Sigma^* \cdot X \cdot Y \cdot \Sigma^* \\
    \PathKW(\vec{X})   & = & \Sigma^* \cdot X_1 \dots X_n \cdot \Sigma^* \\
    \Novalley(\vec{X}) & = & \NOT\PathKW(X_2,X_1,X_2) ~ \cap \dots \cap \\
                       &   & \NOT\PathKW(X_n,X_{n-1},X_n) \\
  \end{array} \]%

  \end{minipage}%

  \hrulefill%
  \vspace{1em}

  \caption{Methane syntax and expansions.}
  \label{fig:syntax}
  %\vspace{-1em}
\end{figure*}%



\subsection{BGP Configuration}

\para{Syntax}

We define syntax for an abstraction of BGP configurations -- called ABGP -- in Figure~\ref{fig:abgp-syntax}. An ABGP policy consists of a map from topology locations $l$ to router configurations $rc$. Each router configuration $rc$ is a sequence of prefix (templates) $t$ and their corresponding prefix configuration $pc$. A prefix configuration $pc$ is a sequence of match actions $ma$. Each match action $ma$ consists of a preference value $n$, followed by a set of peers $ns$ and community value (\IE, state of the product graph) $n$, and the exports the route to a new set of neighbors $ns$ and updates the community value $n$.

\vspace{2em}
\begin{figure}[h!]\small

  \hrulefill%
  \vspace{1em}

  \begin{minipage}[t]{.5\linewidth}
  \vspace*{-1\baselineskip}
  %
  \[ \begin{array}{rclr}
     abgp &::=& l_1 \rightarrow {rc}_1, ~\dots,~ l_k \rightarrow {rc}_k & \textit{abgp policy} \\
     rc   &::=& t_1 \rightarrow {pc}_1, ~\dots,~ t_k \rightarrow {pc}_k & \textit{router config} \\
     pc   &::=& ma_1, \dots, ma_k & \textit{prefix config} \\
     ma   &::=& n_1 : ({ns}_1, n_2) \rightarrow ({ns}_2, n_3) & \textit{match action} \\
     ps   &::=& \{ t_1, ~\dots,~ t_k \} & \textit{predicates} \\
     ns   &::=& \{ l_1, ~\dots,~ l_k \} & \textit{peers} \\
  \end{array} \]%

  \end{minipage}
  %
  ~~
  \vrule
  ~~
  %
  \begin{minipage}[t]{.5\linewidth}
  \vspace*{-1\baselineskip}
  %
  \[ \begin{array}{l}
     \textbf{compile}_\textbf{ABGP}( (t_1,PG_1,ord_1), \dots, (t_k,PG_k,ord_k) ) = \\
     ~~~~~ \{ l \rightarrow rc ~\vert~ \\
     ~~~~~~~~~ l \in internal(V), \\
     ~~~~~~~~~ rc = \bigcup_i~ \{ t_i \rightarrow ma_1, \dots, ma_k ~\vert~ \\
     ~~~~~~~~~~~~~~~~~~~~~ m = (l,q_m) \in PG_i, \\
     ~~~~~~~~~~~~~~~~~~~~~ in = \{ b ~\vert~ (b,q_n) \in \text{adjIn}(PG_i,m) \} \\
     ~~~~~~~~~~~~~~~~~~~~~ out = \{ c ~\vert~ (c,\_) \in \text{adjOut}(PG_i,m) \} \\
     ~~~~~~~~~~~~~~~~~~~~~ ma_j = ord_i(m) : (in,q_n) \rightarrow (out,q_m) \} \} \\
     \\
     \textbf{compile}( p_1, \dots, p_k ) = \\
     ~~~~~~ compile_{ABGP}(compile_{PG}(p_1), \dots, compile_{PG}(p_k)) \\
  \end{array} \]%

  \end{minipage}

  \vspace{1em}
  \hrulefill%
  \vspace{1em}

  \caption{BGP syntax and compilation.}
  \label{fig:abgp-syntax}
\end{figure}%

We assume a particular router $l$ appears at most once in any abgp specification.
An abgp configuration is a partial function from router to prefix configuration.
We write $abgp(l)$ to apply such a config to a router location $l$.
%
We often build configs using set-builder notation.  For instance,
$\{l \rightarrow rc ~\vert~ l \in V \wedge p(l,rc)\}$ denotes the abgp policy

\[ \begin{array}{c}
  l_1 \rightarrow rc_{11},... \\
  ...           \\
  l_k \rightarrow rc_{1k},... \\
\end{array} \]


where $l_1, ..., l_k$ are the nodes in the topology
and each $rc_{ij}$ satisfies $p(l_i,rc_{ij})$. Similarly for $rc$.

\para{Compilation}

Figure~\ref{fig:abgp-syntax} also defines compilation from a \sysname policy to an ABGP policy. It starts by compiling separately each constraint of the form $p_i = (t_i ~\Path~ r_{i1} ~\Prefer~ r_{ik})$ to a product graph $PG = (G', s, P)$, the particular test $t_i$, and the preference ordering $ord_i$. 

The function $compile_{ABGP}$ then takes tuples of $(t_i, PG_i, ord_i)$ and returns an ABGP policy. It looks at each incoming neighbor with the same community state $q_n$ and matches any of those neighbor with the preference provided by the ordering $ord$ obtained from the search for local preferences. It then exports this advertisement to each adjacent peer along an outgoing edge and adds the community value for the current state $q_m$.


\subsection{Concretization}

Here we define what it means to concretize an abstract \sysname policy. 
Concretization takes as input, a policy and a context $\Gamma$ mapping from a template prefix to a set of pairs of a concrete prefix and a concrete location where the prefix is owned.

\[ \begin{array}{lcl}
  con(\emptyset,\Gamma)                        & = & \emptyset \\
  con(l,\Gamma)                                & = & \Sigma ~ f^{-1}(l) \\
  con(r_1 \cup r_2,\Gamma)                     & = & con(r_1,\Gamma) \cup con(r_2,\Gamma) \\
  con(r_1 \cap r_2,\Gamma)                     & = & con(r_1,\Gamma) \cap con(r_2,\Gamma) \\
  con(!r,\Gamma)                               & = & !con(r,\Gamma) \\
  con(r^*,\Gamma)                              & = & con(r,\Gamma)^* \\
  con(pfx \Rightarrow r_1, \dots, r_k,\Gamma)  & = & pfx \Rightarrow con(r_1,\Gamma), \dots, con(r_k,\Gamma) \\
  con(\$x \Rightarrow r_1, \dots, r_k,\Gamma)  & = & \{ pfx \Rightarrow con(r_1,\Gamma) \cap \textbf{end}(l), \dots, \\
  & & ~~~~~~~~~~~~~~~ con(r_k,\Gamma) \cap \textbf{end}(l) ~\vert~ (pfx,l) \in \Gamma(x) \} \\
\end{array} \]

For each regular expression $r$, we replace each abstract location with the sum over its corresponding concrete locations under the inverse homomorphism $f^{-1}$. For each template variable, we replace it with a new entry for each of its corresponding concrete values under the supplied mapping $\Gamma$. We also intersect the resulting concretized regular expression with $\textbf{end}(l)$ to capture the fact that traffic is owned by the concrete location $l$. \textbf{Note}: we need the side condition that $\textbf{end}(l) \cap con(r_i,\Gamma) \neq \emptyset$ if $con(r_i,\Gamma) \neq \emptyset$.
We can also define concretization over the ABGP policy as:

\[ \begin{array}{lcl}
     con(l_1 \rightarrow {rc}_1, ~\dots,~ l_k \rightarrow {rc}_k,\Gamma,G) 
        & = & 
        \{ \ell \rightarrow con(rc_i,\ell,\Gamma,G)  ~\vert~ \ell \in f^{-1}(l_i) \}
        \\
     con(t_1 \rightarrow {pc}_1, ~\dots,~ t_k \rightarrow {pc}_k,\ell,\Gamma,G) 
        & = &  
        con(t_1 \rightarrow {pc}_1,\ell,\Gamma,G), \dots, con(t_k \rightarrow {pc}_k,\ell,\Gamma,G)
        \\
     con(pfx \rightarrow {pc},\ell,\Gamma,G) 
        & = &  
        pfx \rightarrow con(pc,\text{true},\ell,\Gamma,G)
        \\
     con(\$x \rightarrow {pc},\ell,\Gamma,G) 
        & = &  
        \{ pfx \rightarrow con(pc, l=\ell, \ell,\Gamma,G) ~\vert~ (pfx, l) \in \Gamma(x) \}
        \\
     con(ma_1, \dots, ma_k,o,\ell,\Gamma,G) 
        & = &
        con(ma_1,o,\ell,\Gamma,G), \dots, con(ma_k,o,\ell,\Gamma,G)
        \\

     con(n_1 : ({ns}_1, n_2) \rightarrow ({ns}_2, n_3),o,\ell,\Gamma,G) 
        & = & \textbf{if}~ ns_1 = \{G.s\} ~\text{and}~ o = \text{false} ~\textbf{then}~ \bullet \\
        &   & \textbf{else}~ n_1 : ( con({ns}_1,\ell,\Gamma,G), n_2) \rightarrow (con({ns}_2,\ell,\Gamma,G),n_3)

        \\
     con(\{ l_1, ~\dots,~ l_k \}, \ell, \Gamma,G) 
        & = &  
        \bigcup_i ~ \{ x ~\vert~ x \in f^{-1}(l_i),~ (x,\ell) \in G.E \}
        \\
\end{array} \]

\subsection{Abstraction}

A network topology is a graph $G$ = ($V, E$), where $V$ is a set of vertices and $E \colon V \times V$ a set of directed edges. A role-based abstraction is a graph homomorphism from $G$ to an abstract graph $G^A$ = ($V^A$,$E^A$). A graph homorphism $f : G \rightarrow G^A$ is a function that maps each node in the concrete graph to a node in the abstract graph such that, whenever $(u,v) \in E$, then $(f(u),f(v)) \in E^A$. We write $f^{-1}(v)$ to denote the set of concrete nodes mapping to the abstract node $v$. Given a path as a sequence of locations $p = l_1, \dots, l_k$ we define $f(p) = f(l_1), \dots, f(l_k)$.


\subsection{Notation}

Throughout the remainder of the appendix, we use the following convention for metavariables:

\[ \begin{array}{ll}
  \text{Product Graph nodes} & n,m,o \\
  \text{Topology locations} & a,b,c \\
  \text{Automata states} & q_i \\
  \text{Topologies} & G, G^A \\
  \text{Product Graph} & PG, PG^A \\
  \text{Automata} & M, M^A \\
\end{array} \]

We use capital letters for abstract topology/product graph nodes and we use lower case letters for concrete topology nodes. By default, product graph nodes with different subscripts refer to nodes that share the same topology location (\IE, $n_1 \approx n_2$). A superscript $G^A$ refers to the abstract version (in this case of the topology), while the non-superscripted value refers to the concrete version.


\section{Substitution Theorem}

The goal of this section is to prove that the concretization and compilation functions commute. That is -- we can perform compilation directly over the abstraction and only substitute for the concrete values afterwards. First we need a few helper theorems about compilation.

\subsection{Automata}

\newcommand{\Lang}{\ensuremath{\mathcal{L}}}

We compile regular expressions to automata. As a side condition, we ensure that there are no transitions from some state $q$ to the initial state: $\sigma(q,x) = q_0$. This is done by creating another state $q_0'$ with the same transition function as $q_0$ and all other states transition to $q_0'$ instead of $q_0$.

\begin{lem}
  For any map $\Gamma$ and regular expression $r$ over abstract locations, path $p \in \Lang(con(r,\Gamma)) \iff f(p) \in \Lang(r)$.
\end{lem}
\begin{proof}
By induction on the structure of $r$

\emph{Case $\emptyset$:}
  \[ \begin{array}{lll}
    p \in \Lang(con(\emptyset)) &\iff& f(p) \in \Lang(\emptyset) \\
    p \in \emptyset &\iff& f(p) \in \emptyset \\
  \end{array} \]

\emph{Case $l$:}
  \[ \begin{array}{lll}
    p \in \Lang(con(l)) &\iff& f(p) \in \Lang(l) \\
    p \in \Lang(\Sigma ~ f^{-1}(l)) &\iff& f(p) \in \Lang(l) \\
    p \in \bigcup f^{-1}(l) &\iff& f(p) \in \Lang(l) \\
    p \in f^{-1}(l) &\iff& f(p) \in \{ l \} \\
    p \in f^{-1}(l) &\iff& f(p) = l \\
    \text{by homomorphism} & & \\
  \end{array} \]

\emph{Case $r_1 \cup r_2$:}
  \[ \begin{array}{lll}
    p \in \Lang(con(r_1 \cup r_1)) &\iff& f(p) \in \Lang(r_1 \cup r_2) \\
    p \in \Lang(con(r_1) \cup con(r_1)) &\iff& f(p) \in \Lang(r_1 \cup r_2) \\
    p \in \Lang(con(r_1)) \cup \Lang(con(r_1)) &\iff& f(p) \in \Lang(r_1 \cup r_2) \\
    p \in \Lang(con(r_1)) \vee p \in \Lang(con(r_1)) 
       &\iff& 
       f(p) \in \Lang(r_1) \vee f(p) \in \Lang(r_2) \\
    \text{by cases + IH} & & \\
  \end{array} \]

\emph{Case $r_1 \cap r_2$:} 
  \[ \begin{array}{c}
    \text{symmetric to } \cup \text{ case}
  \end{array} \]

\emph{Case $!r$:}
  \[ \begin{array}{lll}
    p \in \Lang(con(!r)) &\iff& f(p) \in \Lang(!r) \\
    p \in \Lang(!con(r)) &\iff& f(p) \in \Lang(!r) \\
    p \in \Sigma^* - \Lang(con(r)) &\iff& f(p) \in \Sigma^* - \Lang(r) \\
    \text{by IH} & & \\
  \end{array} \]

\emph{Case $r^*$:}
  \[ \begin{array}{lll}
    p \in \Lang(con(r^*)) &\iff& f(p) \in \Lang(r^*) \\
    \ryan{TODO} & & \\
  \end{array} \]

\end{proof}



%\begin{defn}
%If $r$ complies to state machine $M^A$, then we compile the policy $con(r)$ in the following way:%

%  \[ \begin{array}{ll}
%    1. & \sigma^A(q,f(l)) = q' \iff \sigma(q,l) = q' \\
%    2. & q \in F^A \iff q \in F \\
%  \end{array} \]%

%That is, we construct a new automata over the same states and final states, but with a different transition function $\sigma$. This ensures that there is a bisimulation between the two state machines.%

%\end{defn}%
%

%\begin{lem}
%  $M^A$ matches $f(p)$ $\iff$ $M$ matches $p$.
%\end{lem}%

%\begin{proof}
%  Suppose $M^A$ matches $f(p) = A_1, \dots, A_k$, then there exists a trace through $M^A$ of the form:%

%  $$q_0, q_1, \dots, q_{k+1}$$%

%  where $\sigma^A(q_i, A_i) = q_{i+1}$ and $q_{k+1} \in F^A$. We must show that $M$ matches $p = a_1, \dots, a_k$. %

%  From the construction of the automaton, we know that $\sigma(q_i, a_i) = q_{i+1}$ and $q_{k+1} \in F \iff q_{k+1} \in F^A$. Therefore, the trace $q_0, q_1, \dots, q_{k+1}$ is accepted by $M$. 
%  %
%  The same proof is symmetric for the other direction.
%\end{proof}%
%

%\begin{lem}
%  $M$ matches $p$ $\iff$ $p \in \Lang(con(r))$
%  \begin{proof}
%    \[ \begin{array}{lllr}
%      M ~\text{matches}~ p &\iff& M^A ~\text{matches}~ f(p) & \textit{previous lemma} \\
%                         &\iff& f(p) \in \Lang(r) & \textit{automaton construction} \\
%                         &\iff& p \in \Lang(con(r)) & \textit{first lemma} \\
%    \end{array} \]%

%  \end{proof}
%\end{lem}


\begin{lem}
  Consider the PG created from compiling the constraint $p = (t ~\Path~ r_1 ~\Prefer~,\dots, ~\Prefer~ r_k)$ with state machine $M^A_i$ for each $r_i$. We know that, for each $(pfx ~\Path~ r'_1 ~\Prefer~,\dots, ~\Prefer~ r'_k) \in con(p)$ where $r'_i$ is of the form $r \cap \text{end}(L)$ we can constuct state machine $M_i$ for $r'_i$ over the same states in the following way:
    
    \[ \begin{array}{lll}
      1. & \sigma(q_0,l) = q' \iff \sigma^A(q,f(l)) = q' & \textbf{for each}~~ l \in L \\
      2. & \sigma(q,l) = q' \iff \sigma^A(q,f(l)) = q' & \textbf{for each}~~ l \in \Sigma \\
      3. & q \in F \iff q \in F^A & \\
    \end{array} \]

  then $M_i$ matches $p$ $\iff$ $p \in \Lang(r_i')$
  
  \vspace{1em}
  \begin{proof} by cases on $t$

    \vspace{1em}

    \textbf{Case} $(\$x ~\Path~ r_1 ~\Prefer~,\dots, ~\Prefer~ r_k)$

    \[ \begin{array}{lcl}
      con(p) &=& pfx_1 ~\Path~ con(r_1) \cap \text{end}(l_1), ~\Prefer~ \dots ~\Prefer~ con(r_k) \cap \text{end}(l_1)  \\
             & & \dots, \\
             & & pfx_n ~\Path~ con(r_1) \cap \text{end}(l_n), ~\Prefer~ \dots ~\Prefer~ con(r_k) \cap \text{end}(l_n)
    \end{array} \]

    Case ($\Rightarrow$)

    Assume $M_i$ matches $p$. Then this means that $M^A_i$ matches $f(p)$. If we have a trace of string of the form $ p = x_1 \cdot \dots \cdot x_n$, then $f(p) = f(x_1) \cdot \dots \cdot f(x_n)$. For each transition $\sigma(q,l) = q'$ in the concrete automaton, we have transition $\sigma(q,f(l)) = q'$ in the abstract automaton, and they have the same final states, so this trace is accepting for $M^A_i$. Because $M^A_i$ matches $f(p)$, this means that $f(p) \in \Lang(r_i)$. From our above lemma, this means that $p \in \Lang(con(r_i))$. We also know that, since $L = \{ l_i \}$, the first transition $\sigma(q_0,l_i)$ is the only transition allowed from the initial state for $M_i$. So this means that $p \in \Lang(\text{end}(l_i))$. Since we know that $p \in \Lang(con(r_i))$ and $p \in \Lang(\text{end}(l_i))$, we know that $p \in \Lang(con(r_i) \cap \text{end}(l_i))$ and thus $p \in \Lang(r'_i)$.

    \vspace{1em}
    Case ($\Leftarrow$)

    Assume $p \in \Lang(r'_i)$. This means that $p \in \Lang(con(r_i) \cap \text{end}(l_i))$. In turn, this means that $p \in \Lang(con(r_i))$ and $p \in \Lang(\text{end}(l_i))$. From the above lemma, we know that $f(p) \in \Lang(r_i)$, which means that $M^A_i$ matches $f(p)$. 
    %
    Consider any string of the form $p = l_i \cdot x_2 \cdot \dots \cdot x_n$ such that $p \in \Lang(con(r_i) \cap \text{end}(l_i))$. Clearly there is a transition defined for $\sigma(q_0,l_i) = q_1$.
    %
    This means that $M^A_i$ matches $f(l_i) \cdot f(x_2) \cdot \dots \cdot f(x_n)$
    %
    For each transition $\sigma^A(q,f(x_i)) = q'$, we have $\sigma(q,x_i) = q'$ in $M_i$.
    %
    Thus the string $l_i \cdot x_2 \cdot \dots \cdot x_n$ is accepted along the same path of automaton states.

  \vspace{1em}

  \textbf{Case} $(pfx ~\Path~ r_1 ~\Prefer~,\dots, ~\Prefer~ r_k)$

    \[ \begin{array}{lcl}
      con(p) &=& pfx_1 ~\Path~ con(r_1) \cap \text{end}(\Sigma^*), ~\Prefer~ \dots ~\Prefer~ con(r_k) \cap \text{end}(\Sigma^*) \\
    \end{array} \]

    First we observe that: $M^A_i$ matches $f(p)$ $\iff$ $M_i$ matches $p$.
    %
    Suppose $M^A_i$ matches $f(p) = A_1, \dots, A_k$, then there exists a trace through $M^A_i$ of the form:%
    %
    $q_0, q_1, \dots, q_{k+1}$
    %
    where $\sigma^A_i(q_i, A_i) = q_{i+1}$ and $q_{k+1} \in F^A$. We must show that $M_i$ matches $p = a_1, \dots, a_k$. %
    %
    From the construction of the automaton, we know that $\sigma_i(q_i, a_i) = q_{i+1}$ and $q_{k+1} \in F \iff q_{k+1} \in F^A_i$. Therefore, the trace $q_0, q_1, \dots, q_{k+1}$ is accepted by $M_i$. 
    %
    The same proof is symmetric for the other direction. It follows that:

    \[ \begin{array}{lll}
      M ~\text{matches}~ p &\iff& M^A ~\text{matches}~ f(p) \\
                         &\iff& f(p) \in \Lang(r) \\
                         &\iff& p \in \Lang(con(r)) \\
    \end{array} \]%

  \end{proof}

\end{lem}

\begin{cor}
  foo
\end{cor}



\subsection{Product Graph}

\begin{defn}
  Because compilation guarantees that the automata states are the same under the concretization function, we can lift the graph homomorphism $f$ to a new homomorphism $f_{pg}$ over the product graph in the following way:
  \[ \begin{array}{rcl}
    f_{pg}( s ) & = & s^A  \\
    f_{pg}( (l,q_1,\ldots,q_n) ) & = & (f(l),q_1,\ldots,q_n) \\
  \end{array} \]
\end{defn}

\begin{lem}
  If $f_{pg}(n) = N$, then $P(n) = P^A(N)$.

  \begin{proof}
    Assume $n = (a,q_1,\dots,q_k)$. We know that $f_{pg}(n) = (f(a),q_1,\dots,q_k)$. 
    We also know that $q_i \in F_i \iff q_i \in F^A_i$. 
    By the definition of the preference function $P$, then $P(n) = P^A(N)$.
  \end{proof}

\end{lem}


\begin{lem}
  If, for abstract product graph $PG$, if we have the following:

  \[ \begin{array}{ll}
    1. & (a,b) ~\text{is an edge in the concrete topology} \\
    2. & \tilde{m} = a \\
    3. & f_{pg}(m) = M \\
    4. & (M,N) ~ \text{is an edge in the product graph}~ PG^A \\
    5. & \tilde{N} = f(b) \\
  \end{array} \]

  then there exists a node $n$ in the concrete product graph $PG$ where:

  \[ \begin{array}{ll}
    1. & \tilde{n} = b \\
    2. & f_{pg}(n) = N \\
    3. & (m,n) ~ \text{is an edge in the product graph}~ PG \\
  \end{array} \]

  \begin{proof}

    suppose that $m = (a, q_1, \dots, q_k)$. Then we know that $M = (f(a), q_1, \dots, q_k)$. Also suppose there is some $b$ such that $N = (f(b), s_1, \dots, s_k)$ since $f^{-1}(N) \neq \emptyset$. This means that, since $(a,b)$ is an edge in the concrete topology, $(f(a),f(b))$ is an edge in the abstract topology. Also we know that $\tilde{N} = f(b)$.

    Let us take the node $n = (b, s_1, \dots, s_k)$. 

    \begin{easylist}
      & Clearly $\tilde{n} = b$
      & Clearly $f_{pg}(n) = (f(b), s_1, \dots, s_k) = N$
      & For each regular expression $\sigma^A(q_i, f(b)) = s_i$. This means that for each regular expression, $\sigma(q_i, b) = s_i$ if $q_i \neq q_{0_i}$. We know that $q_i \neq q_{0_i}$ due to the side condition for automaton construction. It follows that $(m,n)$ is an edge in the product graph by definition.
    \end{easylist}

  \end{proof}
\end{lem}

\begin{thm}
  $m \leq m'$ in the concrete product graph iff $f_{pg}(m) \leq f_{pg}(m')$ in the abstract product graph under the lifted graph homomorphism $f_{pg}$.

  \begin{proof}
    $(\leftarrow)$

    Suppose we have a simulation relation from the subgraphs rooted at nodes $M$ and $M'$ with $M' \geq_{rank} M$ in the abstract product graph. Assume that $\tilde{M} = f(a)$ and $\tilde{N} = f(b)$. For each neighbor $N'$, if we can make a move from $M'$:

    $$M' \overset{\tilde{N'}}{\rightarrow} N'$$

    then we also make a similar move for $M$ for some $N$ where $N \approx N'$ and $N' \geq_{rank} N$:

    $$M \overset{\tilde{N}}{\rightarrow} N$$

    We must show that the same relation holds for $m$ and $m'$. 

    Now assume $m'$ has a neighbor $n'$ where $\tilde{m} = a$ and $\tilde{n} = b$. Then clearly $(a,b)$ is a valid topology edge since it is a transition in the product graph. We now apply the previous lemma with the following facts:

    \[ \begin{array}{ll}
      1. & (a,b) ~\text{is a topology edge} \\
      2. & \tilde{m} = a \\
      3. & f_{pg}(m) = M \\
      4. & (M,N) ~\text{is an edge in}~ PG^A \\
      5. & \tilde{N} = f(b) \\
    \end{array} \]

    This lets us conclude that there exists a node $n'$ such that:

    \[ \begin{array}{ll}
      1. & \tilde{n} = b \\
      2. & f_{pg}(n) = N \\
      3. & (m,n) ~\text{is an edge in}~ PG \\
      4. & P(n) = P(N) \\
    \end{array} \] 

    Thus if we have $m' \overset{b}{\rightarrow} n'$, then we also have $m \overset{b}{\rightarrow} n$. The previous lemma can also be used to show that $P(n') = P(N')$ in a symmetric fashion, so we are guaranteed that $n' \geq_{rank} n$ from the fact that $N' \geq_{rank} N$.

  \end{proof}

  \begin{proof}
    $(\rightarrow)$

    This is the simpler case. We assume we have $m' \overset{b}{\rightarrow} n'$ implies $m \overset{b}{\rightarrow} n$.
    Simply take $N = f_{pg}(n)$ and $N' = f_{pg}(n')$. If we know that $M' \overset{b}{\rightarrow} N'$ then we already know that $M \overset{b}{\rightarrow} N$ from the homomorphism. All that's required is to show that $N' \geq_{rank} N$. This follows trivially from the fact that $P(n) = P(N)$ and $P(n') = P(N')$.
  \end{proof}

\end{thm}

\begin{defn}
  Assign $ord(m) = ord^A(f_{pg}(m))$ as increasing integers according to the total ordering for $\leq$.
  Clearly $ord(m) \leq ord(m') \iff m \leq m'$ and $ord(f_{pg}(m)) \leq ord(f_{pg}(m')) \iff f_{pg}(m) \leq f_{pg}(m')$
\end{defn}


\subsection{Substitution}

\begin{defn}
  The previous theorem tells us that the total ordering between node preferences is preserved under the lifted graph homomorphism $f_{pg}$. 
  We use this fact to define an ordering ($ord : V \rightarrow \mathbb{N}$) that maps product graph nodes to numbers reflecting the total ordering such that $ord(m) = ord(f(m))$ for all product graph nodes $m$.
\end{defn} 


\begin{thm}
  $compile(con(pol)) = con(compile(pol))$

  \begin{proof} \text{ }

    Suppose that $pol = p_1, \dots, p_n$. Each $p_i$ has the form $(t_i ~\Path~ r_{i1} ~\Prefer~,\dots, ~\Prefer~ r_{ik})$. Then by evaulating:

    \[ \begin{array}{lcl}
      con(pol) & = & con(p_1,\dots,p_n) \\
               & = & con(p_1), \dots, con(p_n) \\
               & = & con(t_1 ~\Path~ r_{11} ~\Prefer~,\dots, ~\Prefer~ r_{1k}), \\
               &   & \dots, \\
               &   & con(t_n ~\Path~ r_{n1} ~\Prefer~,\dots, ~\Prefer~ r_{nk}) \\
    \end{array} \]

    For each test $t_i$, if $t_i = pfx$, then we get 

    \[ \begin{array}{lcl}
        con({pfx}_{i1} ~\Path~ r_{i1} ~\Prefer~,\dots, ~\Prefer~ r_{ik}) 
           & = & {pfx}_{i1} ~\Path~ con(r_{i1}) ~\Prefer~,\dots, ~\Prefer~ con(r_{ik}) \\
    \end{array} \]

    For each test $t_i$, if $t_i = \$x$, then we get

    \[ \begin{array}{lcl}
        con(\$x_{i} ~\Path~ r_{i1} ~\Prefer~,\dots, ~\Prefer~ r_{ik}) 
            & = & {pfx}_{i1} ~\Path~ con(r_{i1}) \cap \text{end}(l_{i1}) ~\Prefer~,\dots, ~\Prefer~ con(r_{ik}) \cap \text{end}(l_{i1}), \\
            &   & \dots, \\ 
            &   & {pfx}_{ij} ~\Path~ con(r_{i1}) \cap \text{end}(l_{ij}) ~\Prefer~,\dots, ~\Prefer~ con(r_{ik}) \cap \text{end}(l_{ij}), \\
            &   & \\
            &   & \text{for each } (pfx_{ij}, l_{ij}) \in \Gamma(x) \\
    \end{array} \]

    Next we compute $compile(con(pol))$:

    \[ \begin{array}{lcl}
        compile(con(pol)) &=& compile_{ABGP}( \\
                          & & ~~~~ compile_{PG}(pfx_{11} ~\Path~ r'_{111} ~\Prefer~,\dots, ~\Prefer~ r'_{11k} ), \\
                          & & ~~~~ \dots, \\
                          & & ~~~~ compile_{PG}(pfx_{1j} ~\Path~ r'_{1j1} ~\Prefer~,\dots, ~\Prefer~ r'_{1jk} ), \\
                          & & ~~~~ \dots, \\
                          & & ~~~~ compile_{PG}(pfx_{i1} ~\Path~ r'_{i11} ~\Prefer~,\dots, ~\Prefer~ r'_{i1k} ), \\
                          & & ~~~~ \dots, \\
                          & & ~~~~ compile_{PG}(pfx_{ij} ~\Path~ r'_{ij1} ~\Prefer~,\dots, ~\Prefer~ r'_{ijk} ) \\
                          & & ) \\
    \end{array} \]
 
    This results in a series of prefixes, product graphs, and orderings of the form: $(pfx_{ij}, PG_{ij}, ord_{ij})$.

    \vspace{1em}
    Similarly, we can compute $compile(pol)$:

    \[ \begin{array}{lcl}
        compile(pol) &=& compile_{ABGP}( \\
                     & & ~~~~ compile_{PG}(t_1 ~\Path~ r_{11} ~\Prefer~,\dots, ~\Prefer~ r_{1k} ), \\
                     & & ~~~~ \dots, \\
                     & & ~~~~ compile_{PG}(t_i ~\Path~ r_{i1} ~\Prefer~,\dots, ~\Prefer~ r'_{ik} ), \\
                     & & ) \\
    \end{array} \]

    This results in a series of prefixes, product graphs, and orderings of the form $(t_i, PG^A_i, ord^A_i)$.

    We know the follwing:

    \begin{itemize}
      \item each $PG^A_i$ and $PG_ij$ are related by $f_{pg}$
      \item each $ord^A_i$ and $ord_{ij}$ have the property that $ord^A(f_{pg}(m)) = ord_{ij}(m)$
    \end{itemize}
    


  \[ \begin{array}{l}
     con(\textbf{compile}( (t_1,PG^A_1,ord^A_1), \dots, (t^A_i,PG^A_i,ord^A_i) )) \\
  \end{array} \]%

Unfold definition of compile

  \[ \begin{array}{l}
     ~~~~~ con(\{ l \rightarrow rc ~\vert~ \\
     ~~~~~~~~~ l \in internal(V^A), \\
     ~~~~~~~~~ rc = \bigcup_i~ \{ t_i \rightarrow ma_1, \dots, ma_k ~\vert~ \\
     ~~~~~~~~~~~~~~~~~~~~~ M = (l,q_M) \in PG^A_i, \\
     ~~~~~~~~~~~~~~~~~~~~~ in = \{ B ~\vert~ (B,q_N) \in \text{adjIn}(PG^A_i,M) \} \\
     ~~~~~~~~~~~~~~~~~~~~~ out = \{ C ~\vert~ (C,\_) \in \text{adjOut}(PG^A_i,M) \} \\
     ~~~~~~~~~~~~~~~~~~~~~ ma_h = ord^A_i(M) : (in,q_n) \rightarrow (out,q_M) \} \}) \\
  \end{array} \]%

  Apply the definition of $con$

  \[ \begin{array}{l}
     ~~~~~ \{ \ell \rightarrow con(rc) ~\vert~ \\
     ~~~~~~~~~ \ell \in f^{-1}(l), \\
     ~~~~~~~~~ l \in internal(V^A), \\
     ~~~~~~~~~ rc = \bigcup_i~ \{ t_i \rightarrow ma_1, \dots, ma_k ~\vert~ \\
     ~~~~~~~~~~~~~~~~~~~~~ M = (l,q_M) \in PG^A_i, \\
     ~~~~~~~~~~~~~~~~~~~~~ in = \{ B ~\vert~ (B,q_n) \in \text{adjIn}(PG^A_i,M) \} \\
     ~~~~~~~~~~~~~~~~~~~~~ out = \{ C ~\vert~ (C,\_) \in \text{adjOut}(PG^A_i,M) \} \\
     ~~~~~~~~~~~~~~~~~~~~~ ma_h = ord^A_i(M) : (in,q_N) \rightarrow (out,q_M) \} \} \\
  \end{array} \]%

  Rewrite $con$ on $rc$

  \[ \begin{array}{l}
     ~~~~~ \{ \ell \rightarrow rc ~\vert~ \\
     ~~~~~~~~~ \ell \in f^{-1}(l), \\
     ~~~~~~~~~ l \in internal(V^A), \\
     ~~~~~~~~~ rc = con(\bigcup_i~ \{ t_i \rightarrow ma_1, \dots, ma_k ~\vert~ \\
     ~~~~~~~~~~~~~~~~~~~~~ M = (l,q_M) \in PG^A_i, \\
     ~~~~~~~~~~~~~~~~~~~~~ in = \{ B ~\vert~ (B,q_N) \in \text{adjIn}(PG^A_i,M) \} \\
     ~~~~~~~~~~~~~~~~~~~~~ out = \{ C ~\vert~ (C,\_) \in \text{adjOut}(PG^A_i,M) \} \\
     ~~~~~~~~~~~~~~~~~~~~~ ma_h = ord^A_i(M) : (in,q_N) \rightarrow (out,q_M) \}) \} \\
  \end{array} \]%

  Apply definition of $con$

  \[ \begin{array}{l}
     ~~~~~ \{ \ell \rightarrow rc ~\vert~ \\
     ~~~~~~~~~ \ell \in f^{-1}(l), \\
     ~~~~~~~~~ l \in internal(V^A), \\
     ~~~~~~~~~ rc = \bigcup_i~ con(\{ t_i \rightarrow ma_1, \dots, ma_k ~\vert~ \\
     ~~~~~~~~~~~~~~~~~~~~~ M = (l,q_M) \in PG^A_i, \\
     ~~~~~~~~~~~~~~~~~~~~~ in = \{ B ~\vert~ (B,q_N) \in \text{adjIn}(PG^A_i,M) \} \\
     ~~~~~~~~~~~~~~~~~~~~~ out = \{ C ~\vert~ (C,\_) \in \text{adjOut}(PG^A_i,M) \} \\
     ~~~~~~~~~~~~~~~~~~~~~ ma_h = ord^A_i(M) : (in,q_N) \rightarrow (out,q_M) \}) \} \\
  \end{array} \]%

  \vspace{1em}
  \textbf{Case 1}: Assume $t_i = pfx$. Look at:

  \[ \begin{array}{l}
     ~~~~~~~~~ con(\{ pfx \rightarrow ma_1, \dots, ma_k ~\vert~ \\
     ~~~~~~~~~~~~~~~~~~ M = (l,q_M) \in PG^A_i, \\
     ~~~~~~~~~~~~~~~~~~ in = \{ B ~\vert~ (B,q_N) \in \text{adjIn}(PG^A_i,M) \} \\
     ~~~~~~~~~~~~~~~~~~ out = \{ C ~\vert~ (C,\_) \in \text{adjOut}(PG^A_i,M) \} \\
     ~~~~~~~~~~~~~~~~~~ ma_h = ord^A_i(M) : (in,q_N) \rightarrow (out,q_M) \}) \\
  \end{array} \]%

  Apply definition of $con$

  \[ \begin{array}{l}
     ~~~~~~~~~ \{ pfx \rightarrow con(ma_1, \dots, ma_k) ~\vert~ \\
     ~~~~~~~~~~~~~~~~~~ M = (l,q_M) \in PG^A_i, \\
     ~~~~~~~~~~~~~~~~~~ in = \{ B ~\vert~ (B,q_N) \in \text{adjIn}(PG^A_i,M) \} \\
     ~~~~~~~~~~~~~~~~~~ out = \{ C ~\vert~ (C,\_) \in \text{adjOut}(PG^A_i,M) \} \\
     ~~~~~~~~~~~~~~~~~~ ma_h = ord^A_i(M) : (in,q_N) \rightarrow (out,q_M) \} \\
  \end{array} \]%

  Apply definition of $con$

  \[ \begin{array}{l}
     ~~~~~~~~~ \{ pfx \rightarrow con(ma_1), \dots, con(ma_k) ~\vert~ \\
     ~~~~~~~~~~~~~~~~~~ M = (l,q_M) \in PG^A_i, \\
     ~~~~~~~~~~~~~~~~~~ in = \{ B ~\vert~ (B,q_N) \in \text{adjIn}(PG^A_i,M) \} \\
     ~~~~~~~~~~~~~~~~~~ out = \{ C ~\vert~ (C,\_) \in \text{adjOut}(PG^A_i,M) \} \\
     ~~~~~~~~~~~~~~~~~~ ma_h = ord^A_i(M) : (in,q_N) \rightarrow (out,q_M) \}) \\
  \end{array} \]%

  Apply definition of $con$

  \[ \begin{array}{l}
     ~~~~~~~~~ con(\{ pfx \rightarrow ma_1, \dots, ma_k ~\vert~ \\
     ~~~~~~~~~~~~~~~~~~ M = (l,q_M) \in PG^A_i, \\
     ~~~~~~~~~~~~~~~~~~ in = \{ B ~\vert~ (B,q_N) \in \text{adjIn}(PG^A_i,M) \} \\
     ~~~~~~~~~~~~~~~~~~ out = \{ C ~\vert~ (C,\_) \in \text{adjOut}(PG^A_i,M) \} \\
     ~~~~~~~~~~~~~~~~~~ ma_h = con(ord^A_i(M) : (in,q_N) \rightarrow (out,q_M), \text{true}) \}) \\
  \end{array} \]%

  Apply definition of $con$

  \[ \begin{array}{l}
     ~~~~~~~~~ \{ pfx \rightarrow ma_1, \dots, ma_k ~\vert~ \\
     ~~~~~~~~~~~~~~~~~~ M = (l,q_M) \in PG^A_i, \\
     ~~~~~~~~~~~~~~~~~~ in = \{ B ~\vert~ (B,q_N) \in \text{adjIn}(PG^A_i,M) \} \\
     ~~~~~~~~~~~~~~~~~~ out = \{ C ~\vert~ (C,\_) \in \text{adjOut}(PG^A_i,M) \} \\
     ~~~~~~~~~~~~~~~~~~ ma_h = ord^A_i(M) : (con(in),q_N) \rightarrow (con(out),q_M) \} \\
  \end{array} \]%

  Rewrite on $in$ and $out$

  \[ \begin{array}{l}
     ~~~~~~~~~ \{ pfx \rightarrow ma_1, \dots, ma_k ~\vert~ \\
     ~~~~~~~~~~~~~~~~~~ M = (l,q_M) \in PG^A_i, \\
     ~~~~~~~~~~~~~~~~~~ in = con(\{ B ~\vert~ (B,q_N) \in \text{adjIn}(PG^A_i,M) \}) \\
     ~~~~~~~~~~~~~~~~~~ out = con(\{ C ~\vert~ (C,\_) \in \text{adjOut}(PG^A_i,M) \}) \\
     ~~~~~~~~~~~~~~~~~~ ma_h = ord^A_i(M) : (in,q_N) \rightarrow (out,q_M) \} \\
  \end{array} \]%

  Apply definition of $con$

  \[ \begin{array}{l}
     ~~~~~~~~~ \{ pfx \rightarrow ma_1, \dots, ma_k ~\vert~ \\
     ~~~~~~~~~~~~~~~~~~ M = (l,q_M) \in PG^A_i, \\
     ~~~~~~~~~~~~~~~~~~ in = \{ b \in f^{-1}(B), (B,\ell) \in G.E, (B,q_N) \in \text{adjIn}(PG^A_i,M) \}) \\
     ~~~~~~~~~~~~~~~~~~ out = \{ c \in f^{-1}(C), (C,\ell) \in G.E, (C,\_) \in \text{adjOut}(PG^A_i,M) \} \\
     ~~~~~~~~~~~~~~~~~~ ma_h = ord^A_i(M) : (in,q_N) \rightarrow (out,q_M) \} \\
  \end{array} \]%

  From the relation between concrete ($PG$) and abstract ($PG^A$) product graphs

  \[ \begin{array}{l}
     ~~~~~~~~~ \{ pfx \rightarrow ma_1, \dots, ma_k ~\vert~ \\
     ~~~~~~~~~~~~~~~~~~ m = (l,q_M) \in PG_{i1}, \\
     ~~~~~~~~~~~~~~~~~~ in = \{ b ~\vert~ (b,q_N) \in \text{adjIn}(PG_{i1},m) \}) \\
     ~~~~~~~~~~~~~~~~~~ out = \{ c ~\vert~ (c,\_) \in \text{adjOut}(PG_{i1},m) \} \\
     ~~~~~~~~~~~~~~~~~~ ma_h = ord^A_i(f_{pg}(m)) : (in,q_N) \rightarrow (out,q_M) \} \\
  \end{array} \]%

  \ryan {Proof that we can change this to concrete topology}

  Since $ord^A_i(f_{pg}(m)) = ord_{i1}(m)$

  \[ \begin{array}{l}
     ~~~~~~~~~ \{ pfx \rightarrow ma_1, \dots, ma_k ~\vert~ \\
     ~~~~~~~~~~~~~~~~~~ m = (l,q_M) \in PG_{i1}, \\
     ~~~~~~~~~~~~~~~~~~ in = \{ b ~\vert~ (b,q_N) \in \text{adjIn}(PG_{i1},m) \}) \\
     ~~~~~~~~~~~~~~~~~~ out = \{ c ~\vert~ (c,\_) \in \text{adjOut}(PG_{i1},m) \} \\
     ~~~~~~~~~~~~~~~~~~ ma_h = ord_{i1}(m) : (in,q_N) \rightarrow (out,q_M) \} \\
  \end{array} \]%

  Since product graphs have equivalent states

  \[ \begin{array}{l}
     ~~~~~~~~~ \{ pfx \rightarrow ma_1, \dots, ma_k ~\vert~ \\
     ~~~~~~~~~~~~~~~~~~ m = (l,q_m) \in PG_{i1}, \\
     ~~~~~~~~~~~~~~~~~~ in = \{ b ~\vert~ (b,q_n) \in \text{adjIn}(PG_{i1},m) \}) \\
     ~~~~~~~~~~~~~~~~~~ out = \{ c ~\vert~ (c,\_) \in \text{adjOut}(PG_{i1},m) \} \\
     ~~~~~~~~~~~~~~~~~~ ma_h = ord_{i1}(m) : (in,q_n) \rightarrow (out,q_m) \} \\
  \end{array} \]%

  \vspace{1em}
  \textbf{Case 2}: Assume $t_i = \$x$

  \[ \begin{array}{l}
     ~~~~~~~~~ con(\{ \$x \rightarrow ma_1, \dots, ma_k ~\vert~ \\
     ~~~~~~~~~~~~~~~~~~ M = (l,q_M) \in PG^A_i, \\
     ~~~~~~~~~~~~~~~~~~ in = \{ B ~\vert~ (B,q_N) \in \text{adjIn}(PG^A_i,M) \} \\
     ~~~~~~~~~~~~~~~~~~ out = \{ C ~\vert~ (C,\_) \in \text{adjOut}(PG^A_i,M) \} \\
     ~~~~~~~~~~~~~~~~~~ ma_h = ord^A_i(M) : (in,q_N) \rightarrow (out,q_M) \}) \\
  \end{array} \]%

  Apply the definition of $con$

  \[ \begin{array}{l}
     ~~~~~~~~~ \{ pfx_{ij} \rightarrow con(ma_1, \dots, ma_k) ~\vert~ \\
     ~~~~~~~~~~~~~~~~~~ (pfx_{ij}, l_{ij}) \in \Gamma(x), \\
     ~~~~~~~~~~~~~~~~~~ M = (l,q_M) \in PG^A_i, \\
     ~~~~~~~~~~~~~~~~~~ in = \{ B ~\vert~ (B,q_N) \in \text{adjIn}(PG^A_i,M) \} \\
     ~~~~~~~~~~~~~~~~~~ out = \{ C ~\vert~ (C,\_) \in \text{adjOut}(PG^A_i,M) \} \\
     ~~~~~~~~~~~~~~~~~~ ma_h = ord^A_i(M) : (in,q_N) \rightarrow (out,q_M) \} \\
  \end{array} \]%

  Apply definition $con$

  \[ \begin{array}{l}
     ~~~~~~~~~ \{ pfx_{ij} \rightarrow con(ma_1), \dots, con(ma_k) ~\vert~ \\
     ~~~~~~~~~~~~~~~~~~ (pfx_{ij}, l_{ij}) \in \Gamma(x), \\
     ~~~~~~~~~~~~~~~~~~ M = (l,q_M) \in PG^A_i, \\
     ~~~~~~~~~~~~~~~~~~ in = \{ B ~\vert~ (B,q_N) \in \text{adjIn}(PG^A_i,M) \} \\
     ~~~~~~~~~~~~~~~~~~ out = \{ C ~\vert~ (C,\_) \in \text{adjOut}(PG^A_i,M) \} \\
     ~~~~~~~~~~~~~~~~~~ ma_h = ord^A_i(M) : (in,q_N) \rightarrow (out,q_M) \} \\
  \end{array} \]%

  Rewrite $con$ on $ma_h$.

  \[ \begin{array}{l}
     ~~~~~~~~~ \{ pfx_{ij} \rightarrow ma_1, \dots, ma_k ~\vert~ \\
     ~~~~~~~~~~~~~~~~~~ (pfx_{ij}, l_{ij}) \in \Gamma(x), \\
     ~~~~~~~~~~~~~~~~~~ M = (l,q_M) \in PG^A_i, \\
     ~~~~~~~~~~~~~~~~~~ in = \{ B ~\vert~ (B,q_N) \in \text{adjIn}(PG^A_i,M) \} \\
     ~~~~~~~~~~~~~~~~~~ out = \{ C ~\vert~ (C,\_) \in \text{adjOut}(PG^A_i,M) \} \\
     ~~~~~~~~~~~~~~~~~~ ma_h = con(ord^A_i(M) : (in,q_N) \rightarrow (out,q_M), l_{ij} = \ell) \} \\
  \end{array} \]%

  Apply definition of $con$

  \[ \begin{array}{l}
     ~~~~~~~~~ \{ pfx_{ij} \rightarrow ma_1, \dots, ma_k ~\vert~ \\
     ~~~~~~~~~~~~~~~~~~ (pfx_{ij}, l_{ij}) \in \Gamma(x), \\
     ~~~~~~~~~~~~~~~~~~ M = (l,q_M) \in PG^A_i, \\
     ~~~~~~~~~~~~~~~~~~ in = \{ B ~\vert~ (B,q_N) \in \text{adjIn}(PG^A_i,M) \} \\
     ~~~~~~~~~~~~~~~~~~ out = \{ C ~\vert~ (C,\_) \in \text{adjOut}(PG^A_i,M) \} \\
     ~~~~~~~~~~~~~~~~~~ ma_h = \textbf{if}~ in=\{ G.s \} \text{ and } l_{ij} \neq \ell ~\textbf{then}~ \bullet \\ 
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ \textbf{else}~ ord^A_i(M) : (con(in),q_N) \rightarrow (con(out),q_M) \} \\
  \end{array} \]%

  \textbf{Observation}: 
  By filtering the cases where $in = \{ G.s \}$ and $l_{ij} \neq \ell$ we get the same thing as before after applying the definition of $con$:

 \[ \begin{array}{l}
     ~~~~~~~~~ \{ pfx_{ij} \rightarrow ma_1, \dots, ma_k ~\vert~ \\
     ~~~~~~~~~~~~~~~~~~ (pfx_{ij}, l_{ij}) \in \Gamma(x), \\
     ~~~~~~~~~~~~~~~~~~ m = (l,q_m) \in PG_{ij}, \\
     ~~~~~~~~~~~~~~~~~~ in = \{ b ~\vert~ (b,q_n) \in \text{adjIn}(PG_{ij},m) \}) \\
     ~~~~~~~~~~~~~~~~~~ out = \{ c ~\vert~ (c,\_) \in \text{adjOut}(PG_{ij},m) \} \\
     ~~~~~~~~~~~~~~~~~~ ma_h = ord_{ij}(m) : (in,q_n) \rightarrow (out,q_m) \} \\
  \end{array} \]%

  This works because each $PG_{ij}$ was constructed from $con(r_{ijk}) \cap end(l_{ij})$. This means that the only state in $PG_{ij}$ connected to the start node $G.s$ is a node for $l_{ij}$. This was ensured by the fact that the transition function for each regular expression $\sigma_{ijk}(q_0,l) = q$ is defined only for locations $l \in L$ where $L = \{ l_{ij} \}$ from the construction of the automata.

  \vspace{1em}
  \textbf{Merging Cases}:

  In the first case, we got a result of the form:

  \[ \begin{array}{l}
     ~~~~~~~~~ \{ pfx \rightarrow ma_1, \dots, ma_k ~\vert~ \\
     ~~~~~~~~~~~~~~~~~~ m = (l,q_m) \in PG_{i1}, \\
     ~~~~~~~~~~~~~~~~~~ in = \{ b ~\vert~ (b,q_n) \in \text{adjIn}(PG_{i1},m) \}) \\
     ~~~~~~~~~~~~~~~~~~ out = \{ c ~\vert~ (c,\_) \in \text{adjOut}(PG_{i1},m) \} \\
     ~~~~~~~~~~~~~~~~~~ ma_h = ord_{i1}(m) : (in,q_n) \rightarrow (out,q_m) \} \\
  \end{array} \]%

  In the second case, we got a result of the form:

 \[ \begin{array}{l}
     ~~~~~~~~~ \{ pfx_{ij} \rightarrow ma_1, \dots, ma_k ~\vert~ \\
     ~~~~~~~~~~~~~~~~~~ (pfx_{ij}, l_{ij}) \in \Gamma(x), \\
     ~~~~~~~~~~~~~~~~~~ m = (l,q_m) \in PG_{ij}, \\
     ~~~~~~~~~~~~~~~~~~ in = \{ b ~\vert~ (b,q_n) \in \text{adjIn}(PG_{ij},m) \}) \\
     ~~~~~~~~~~~~~~~~~~ out = \{ c ~\vert~ (c,\_) \in \text{adjOut}(PG_{ij},m) \} \\
     ~~~~~~~~~~~~~~~~~~ ma_h = ord_{ij}(m) : (in,q_n) \rightarrow (out,q_m) \} \\
  \end{array} \]%

  Putting these together, we get the following:

  \[ \begin{array}{l}
     ~~~~~ \{ \ell \rightarrow rc ~\vert~ \\
     ~~~~~~~~~ \ell \in f^{-1}(l), \\
     ~~~~~~~~~ l \in internal(V^A), \\
     ~~~~~~~~~ rc = \bigcup_{ij}~ \{ pfx_{ij} \rightarrow ma_1, \dots, ma_k ~\vert~ \\
     ~~~~~~~~~~~~~~~~~~~~~ m = (l,q_m) \in PG_{ij}, \\
     ~~~~~~~~~~~~~~~~~~~~~ in = \{ b ~\vert~ (b,q_n) \in \text{adjIn}(PG_{ij},m) \}) \\
     ~~~~~~~~~~~~~~~~~~~~~ out = \{ c ~\vert~ (c,\_) \in \text{adjOut}(PG_{ij},m) \} \\
     ~~~~~~~~~~~~~~~~~~~~~ ma_h = ord_{ij}(m) : (in,q_n) \rightarrow (out,q_m) \} \\
  \end{array} \]%


  Finally, we observe that this is equivalent to the following:

  \[ \begin{array}{l}
     ~~~~~ \{ l \rightarrow rc ~\vert~ \\
     ~~~~~~~~~ l \in internal(V), \\
     ~~~~~~~~~ rc = \bigcup_{ij}~ con(\{ pfx_{ij} \rightarrow ma_1, \dots, ma_k ~\vert~ \\
     ~~~~~~~~~~~~~~~~~~~~~ m = (l,q_m) \in PG_{ij}, \\
     ~~~~~~~~~~~~~~~~~~~~~ in = \{ b ~\vert~ (b,q_n) \in \text{adjIn}(PG_{ij},m) \}) \\
     ~~~~~~~~~~~~~~~~~~~~~ out = \{ c ~\vert~ (c,\_) \in \text{adjOut}(PG_{ij},m) \} \\
     ~~~~~~~~~~~~~~~~~~~~~ ma_h = ord_{ij}(m) : (in,q_n) \rightarrow (out,q_m) \} \\
  \end{array} \]%

  This is exactly the definition of compilation for the concretized policy

  \[ \begin{array}{l}
     = \textbf{compile}( (pfx_{11},PG_{11},ord_{11}), \dots, (pfx_{ij},PG_{ij},ord_{ij}) ) \\
  \end{array} \]%


  \end{proof}

\end{thm}

\end{document}