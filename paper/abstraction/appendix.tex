\documentclass[twocolumn, openany]{sig-alternate-10pt}
%\documentclass[twocolumn]{article}
%\documentclass[10pt]{sigalternate052015}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{xcolor}
\usepackage{url}
\usepackage{times}
\usepackage{xspace}
\usepackage{listings}
\usepackage{code}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\usepackage{tikz}
\usetikzlibrary{arrows,automata,positioning}
\let\proof\relax
\let\endproof\relax
\usepackage{amsthm}
\usepackage{subcaption}
\usepackage{balance}
\usepackage[ampersand]{easylist}
\usepackage{textcomp}
\usepackage{pifont}
\newcommand{\cmark}{\ding{51}}
\newcommand{\xmark}{\ding{55}}

\definecolor{princetonorange}{RGB}{255,143,0}
\definecolor{tmlblue}{RGB}{0,58,120}  % tmlblue == Toronto Maple Leafs Blue!

\newcommand{\todo}[1]{\textcolor{red}{[TODO: #1]}}
\newcommand{\ratul}[1]{\textcolor{blue}{[ratul: #1]}}
\newcommand{\ryan}[1]{\textcolor{green}{[ryan: #1]}}
\newcommand{\dpw}[1]{\textcolor{tmlblue}{[dpw: #1]}}
\newcommand{\todd}[1]{\textcolor{princetonorange}{[todd: #1]}}

\newcommand{\EG}{\emph{e.g.}}
\newcommand{\IE}{\emph{i.e.}}
\newcommand{\ETC}{\emph{etc.}}
\newcommand{\ETAL}{\emph{et al.}}

\newcommand{\sysname}{{\small \sf Propane/AT}\xspace}
\newcommand{\sysnamesec}{{\sf Propane/AT}\xspace}
\newcommand{\propane}{{\small \sf Propane}\xspace}

\newcommand{\para}[1]{\paragraph*{\textbf{#1}}}

\newcommand{\set}[1]{\ensuremath{\{ #1 \} }}
\newcommand{\abs}[1]{\ensuremath{ \lvert #1 \rvert }}

\newcommand{\CD}[1]{\texttt{\small #1}}  % code font
\newcommand{\KW}[1]{\texttt{\small\bfseries{#1}}}

\newcommand{\True}{\CD{true}}
\newcommand{\Define}{\KW{define}}
\newcommand{\Prefer}{\texttt{>>}}
\newcommand{\Path}{\texttt{=>}}
\newcommand{\Link}{\texttt{->}}
\newcommand{\Agg}{\KW{agg}}
\newcommand{\Any}{\KW{any}}
\newcommand{\None}{\KW{drop}}
\newcommand{\In}{\KW{in}}
\newcommand{\Out}{\KW{out}}
\newcommand{\AND}{\texttt{\&}}
\newcommand{\OR}{\texttt{|}}
\newcommand{\NOT}{\texttt{!}}
\newcommand{\Intersect}{\ensuremath{\cap}}
\newcommand{\Union}{\ensuremath{\cup}}

\newcommand{\Exit}{\KW{exit}}
\newcommand{\End}{\KW{end}}
\newcommand{\Start}{\KW{start}}
\newcommand{\Enter}{\KW{enter}}
\newcommand{\Eventually}{\KW{eventually}}
\newcommand{\Already}{\KW{already}}
\newcommand{\Internal}{\KW{internal}}
\newcommand{\Never}{\KW{never}}
\newcommand{\Always}{\KW{always}}
\newcommand{\Through}{\KW{through}}
\newcommand{\LinkKW}{\KW{link}}
\newcommand{\PathKW}{\KW{path}}
\newcommand{\Novalley}{\KW{novalley}}

\newcommand{\Con}{\mathrm{con}}
\newcommand{\Pfx}{\mathrm{pfx}}%
\newcommand{\CompilePred}{\ensuremath{\mathrm{compile}_\mathrm{pred}}}
\newcommand{\CompilePg}{\ensuremath{\mathrm{compile}_\mathrm{PG}}}
\newcommand{\CompileMbgp}{\ensuremath{\mathrm{compile}_\mathrm{mBGP}}}
\newcommand{\Compile}{\ensuremath{\mathrm{compile}}}
\newcommand{\Append}{\ensuremath{\mathrm{append}}}
\newcommand{\Pref}{\ensuremath{\mathrm{pref}}}
\newcommand{\Topo}{\ensuremath{\mathrm{topo}}}
\newcommand{\EndR}{\ensuremath{\mathrm{end}}}
\newcommand{\Rank}{\ensuremath{\mathrm{rank}}}

\renewcommand{\path}[2]{ #1 \mapsto \ensuremath{#2} }

%% grammar
\newcommand{\BNFALT}{\;\;|\;\;}
\newcommand{\hdr}[2]{\flushleft \chdr{\hspace{5mm}#1}{#2}}
\newcommand{\chdr}[2]{\textbf{#1} {#2} \\ \centering}%

\newtheorem{thm}{Theorem}
\newtheorem{defn}{Definition}
\newtheorem{lem}[thm]{Lemma}
\newtheorem*{cor}{Corollary}


\begin{document}

\special{papersize=8.5in,11in}
\setlength{\pdfpageheight}{\paperheight}
\setlength{\pdfpagewidth}{\paperwidth}

\onecolumn

\appendix

\vspace{2em}
\section{Definitions Reference}

\begin{figure*}[h!]\small
  \begin{minipage}[t]{.45\linewidth}
  \hdr{Propane/AT Syntax}{}
  \vspace*{-1\baselineskip}
  %
  \[ \begin{array}{rclr}
     pol     &::=& p_1, \dots, p_n & \textit{policies} \\
     p       &::=& t \hspace{.3em} \Path \hspace{.3em} r_1 \Prefer \dots \Prefer r_m & \textit{constraints} \\
     pfx     &::=& d.d.d.d/[d..d] & \textit{prefix} \\
     t       &::=& \$x & \textit{template variable} \\
         &\BNFALT& pfx & \textit{prefix test} \\
     l   & & & \textit{topology location} \\
     r       &::=& l & \textit{location} \\
         &\BNFALT& \emptyset & \textit{empty set} \\
         &\BNFALT& \In & \textit{internal loc} \\
         &\BNFALT& \Out & \textit{external loc} \\
         &\BNFALT& r_1 \cup r_2 & \textit{union} \\
         &\BNFALT& r_1 \cap r_2 & \textit{intersection} \\
         &\BNFALT& r_1 \cdot r_2 & \textit{concatenation} \\
         &\BNFALT& \NOT r & \textit{path negation} \\
         &\BNFALT& r^* & \textit{iteration} \\
  \end{array} \]%

  \end{minipage}
  %
  \begin{minipage}[t]{.5\linewidth}\small
  \hdr{Propane/AT Expansions}{}
  \vspace*{-1\baselineskip}
  %
  \[\begin{array}{lcl}
    \Any               & = & \Sigma^* \\
    \None              & = & \emptyset \\
    \Internal          & = & \In^+ \\
    \Always(X)         & = & X^* \\
    \Never(X)          & = & (!X)^* \\
    \Through(X)        & = & \Sigma^* \cdot X \cdot \Sigma^* \\
    \End(X)            & = & \Sigma^* \cdot X \\
    \Start(X)          & = & X \cdot \Sigma^* \\
    \Enter(X)          & = & \Sigma^* \cdot \Out \cdot (X \cap \In) \cdot \Sigma^* ~ \cup \\
                       &   & \Sigma^* \cdot (X \cap \Out) \cdot \In \cdot \Sigma^* \\
    \Exit(X)           & = & \Sigma^* \cdot \In \cdot (X \cap \Out) \cdot \Sigma^* ~ \cup \\
                       &   & \Sigma^* \cdot (X \cap \In) \cdot \Out \cdot \Sigma^* \\
    \LinkKW(X,Y)       & = & \Sigma^* \cdot X \cdot Y \cdot \Sigma^* \\
    \PathKW(\vec{X})   & = & \Sigma^* \cdot X_1 \dots X_n \cdot \Sigma^* \\
    \Novalley(\vec{X}) & = & \NOT\PathKW(X_2,X_1,X_2) ~ \cap \dots \cap \\
                       &   & \NOT\PathKW(X_n,X_{n-1},X_n) \\
  \end{array} \]%

  \end{minipage}%

  \vspace{1em}
  \begin{minipage}[t]{.46\linewidth}
  \hdr{mBGP Syntax}{}
  \vspace*{-1\baselineskip}
  %
  \[ \begin{array}{rclr}
     l    &   & & \textit{topology location} \\
     d    &   & & \textit{integer} \\
     c    &   & & \textit{community} \\
     t    &::=& \$x \BNFALT d.d.d.d/[d..d] & \textit{predicate} \\
     ns   &::=& \{ l_1, ~\dots,~ l_k \} & \textit{peers} \\
     ma   &::=& d : ({ns}_1, c_1) \rightarrow ({ns}_2, c_2) & \textit{match action} \\
     pc   &::=& ma_1, \dots, ma_k & \textit{prefix config} \\
     rc   &::=& t_1 \rightarrow {pc}_1, ~\dots,~ t_k \rightarrow {pc}_k & \textit{router config} \\
     mbgp &::=& l_1 \rightarrow {rc}_1, ~\dots,~ l_k \rightarrow {rc}_k & \textit{mBGP policy} \\%
  \end{array} \]%%

  \end{minipage}
  %
  %
  \begin{minipage}[t]{.5\linewidth}
  \hdr{Compilation}{}
  \vspace*{-1\baselineskip}
  %
  \[ \begin{array}{l}
     \CompileMbgp( [x_1, \dots, x_k], G ) = \\
     ~~~~~ [~ l \rightarrow rc ~\vert~ \\
     ~~~~~~~~~~~~ l \in internal(G.V), \\
     ~~~~~~~~~~~~ rc = \Append_i (\CompilePred( x_i, G )) ~]  \\
     \\
     \CompilePred( (t,PG,pref), G ) = \\
     ~~~~~~~~~~~~~~~ [~ t \rightarrow [~ ma ~\vert~ \\
     ~~~~~~~~~~~~~~~~~~~~~ m \leftarrow (l,q_m) \in PG, \\
     ~~~~~~~~~~~~~~~~~~~~~ pin \leftarrow \text{adjIn}(PG,m), \\
     ~~~~~~~~~~~~~~~~~~~~~ (in,q_n) \leftarrow \{ (bs,q_n) ~\vert~ bs=\{b ~\vert~ (b,q_n) \in pin \}, bs \neq \emptyset \}, \\
     ~~~~~~~~~~~~~~~~~~~~~ out \leftarrow \{ c ~\vert~ (c,\_) \in \text{adjOut}(PG_i,m) \}, \\
     ~~~~~~~~~~~~~~~~~~~~~ ma = \Pref(m) : (in,q_n) \rightarrow (out,q_m) ~] ~] \\
     \\


     \Compile( p_1, \dots, p_k, G) = \\
     ~~~~~~ \text{compile}_\text{mBGP}([\text{compile}_\text{PG}(p_1,G), \dots, \text{compile}_\text{PG}(p_k,G)], G) \\
  \end{array} \]%
  \end{minipage}%

  \vspace{3em}

  \vspace*{-2\baselineskip}
  \begin{minipage}[t]{1.01\linewidth}
  \hdr{Propane/AT Concretization}{}
  \vspace*{-2\baselineskip}
  %
  \[ \begin{array}{lcl}
     \\
     \Con(\emptyset, \Gamma, f)      &=& \emptyset \\
     \Con(l, \Gamma, f)              &=& \Sigma ~ f^{-1}(l) \\
     \Con(r_1 \cup r_2, \Gamma, f)   &=& \Con(r_1,\Gamma,f) \cup \Con(r_2,\Gamma,f) \\
     \Con(r_1 \cap r_2, \Gamma, f)   &=& \Con(r_1,\Gamma,f) \cap \Con(r_2,\Gamma,f) \\
     \Con(!r, \Gamma, f)             &=& !\Con(r,\Gamma,f) \\
     \Con(r^*, \Gamma, f)            &=& \Con(r,\Gamma,f)^* \\%
     \Con(\Pfx ~\Path~ r_1, ~\dots~, r_k, \Gamma, f) &=&
          \Pfx ~\Path~ \Con(r_1,\Gamma,f), ~\dots~, \Con(r_k,\Gamma,f)  \\%
     \Con(\$x ~\Path~ r_1, ~\dots~, r_k, \Gamma, f) &=&%
         [~ \Pfx ~\Path~ \Con(r_1,\Gamma,f) \cap \text{end}(l), ~\dots~, \\%
         & & ~~~~~~~~~~~~~~~ \Con(r_k,\Gamma,f) \cap \text{end}(l) ~\vert~ (\Pfx,l) \in \Gamma(x) ~]  \\%
     \Con(p_1, \dots, p_n, \Gamma,f) &=& \Con(p_1, \Gamma,f), \dots, \Con(p_n, \Gamma,f) \\%

  \end{array} \]%
  \end{minipage}%

  \vspace{2em}

  \begin{minipage}[t]{\linewidth}
  \hdr{mBGP Concretization}{}
  \vspace*{-2\baselineskip}
  %
  \[ \begin{array}{lcl}
     \\
     \Con(l_1 \rightarrow {rc}_1, ~\dots,~ l_k \rightarrow {rc}_k,\Gamma,f,G)
        & = &
        \mathit{append}_i~ [~ \ell \rightarrow con(rc_i,\ell,\Gamma,f,G)  ~\vert~ \ell \in f^{-1}(l_i) ~]
        \\
     \Con(t_1 \rightarrow {pc}_1, ~\dots,~ t_k \rightarrow {pc}_k,\ell,\Gamma,f,G)
        & = &
        \Con(t_1 \rightarrow {pc}_1,\ell,\Gamma,f,G), \dots, \Con(t_k \rightarrow {pc}_k,\ell,\Gamma,f,G)
        \\
     \Con(\Pfx \rightarrow {pc},\ell,\Gamma,f,G)
        & = &
        \Pfx \rightarrow \Con(pc,\text{true},\ell,\Gamma,f,G)
        \\
     \Con(\$x \rightarrow {pc},\ell,\Gamma,f,G)
        & = &
        [~ \Pfx \rightarrow \Con(pc, l=\ell, \ell,\Gamma,f,G) ~\vert~ (\Pfx, l) \in \Gamma(x) ~]
        \\
     \Con(ma_1, \dots, ma_k,o,\ell,\Gamma,f,G)
        & = &
        \Con(ma_1,o,\ell,\Gamma,f,G), \dots, \Con(ma_k,o,\ell,\Gamma,f,G)
        \\%
     \Con(n_1 : ({ns}_1, n_2) \rightarrow ({ns}_2, n_3),o,\ell,\Gamma,f,G)
        & = & \textbf{if}~ ns_1 = \{\text{start}\} ~\text{and}~ o = \text{false} ~\textbf{then}~ \bullet \\
        &   & \textbf{else}~ n_1 : ( \Con({ns}_1,\ell,\Gamma,f,G), n_2) \rightarrow (\Con({ns}_2,\ell,\Gamma,f,G),n_3)%

        \\
     \Con(\{ l_1, ~\dots,~ l_k \}, \ell, \Gamma,f,G)
        & = &
        \bigcup_i ~ \{ x ~\vert~ x \in f^{-1}(l_i),~ (x,\ell) \in G.E \}
        \\
  \end{array} \]%
  \end{minipage}%

  \vspace{1em}
  \hrulefill%
  \vspace{1em}%

  \caption{\sysname syntax, expansions and concretization, as well as mBGP syntax and concretization.}
  \label{fig:syntax}
  %\vspace{-1em}
\end{figure*}%

\newpage


\section{Preliminaries}

For reference, the full \sysname syntax, expansions from constraints into regular expressions, mBGP syntax and compilation, as described in the paper, as well as concretization functions ($\Con$) are shown in Figure~\ref{fig:syntax}.

\subsection{Definition of Compilation}

We present the definition of compilation slighty differently here by factoring out a separate $\CompilePred$ function, to make the proof slightly cleaner. This is a very simple rewriting of the compilation function defined in the body of the paper where $\CompilePred$ is presented inline.

\subsection{Definition of Concretization}

Definitions for concretization are shown in Figure~\ref{fig:syntax}. Concretization for a \sysname policy takes as input, the policy and a context
$\Gamma : Var \rightarrow 2^{Prefix \times V}$,
which maps from a template prefix to a set of pairs of a concrete prefix and a concrete location that ``owns" the prefix.
%
For each regular expression $r$, the abstract location is replaced with the sum over its corresponding concrete locations under the inverse homomorphism $f^{-1}(l) = \{ l' ~\vert~ f(l') = l \}$. For each template variable, we replace it with a new entry for each of its corresponding concrete prefixes under the supplied mapping $\Gamma$. We also intersect the resulting concretized regular expression with $\text{end}(l)$ to capture the fact that this traffic is owned by the concrete location $l$.%

Concretization is defined for mBGP policies in a similar manner. Each abstract router configuration $l \rightarrow rc$ is replaced with a new entry for each concrete location $\ell \in f^{-1}(l)$. The concrete location $\ell$ is passed as a parameter to $con$ to remember the current router.
%
To concretize a prefix policy with a template ($\$x \rightarrow pc$), the template is replaced with a sequence of policies, one for each prefix in context ($(pfx,l) \in \Gamma(x)$). Match action statements where the set of import neighbors is the singleton set containing the product graph start node $\{ start \}$ and we are not currently at looking at the router configuration for the location specified in the context $l$, then we drop the match action. This is denoted with the $\bullet$ symbol. Finally, to concretize a set of neighbors, $f^{-1}$ is used to find the set of concrete neighbors under the inverse homomorphism, but then it is restricted to those that are actually connected in the underlying concrete topology with $G.E$.


\subsection{Notation}

Throughout the remainder of the appendix, we use the following convention for metavariables:

\[ \begin{array}{ll}
  \text{Product Graph nodes} & n,m,o \\
  \text{Topology locations} & a,b,c \\
  \text{Automata states} & q_i \\
  \text{Topologies} & G, G^A \\
  \text{Product Graph} & PG, PG^A \\
\end{array} \]

Capital letters are used for abstract topology/product graph nodes and lower case letters for concrete topology nodes. A superscript $G^A$ refers to the abstract version (in this case of the topology), while the non-superscripted value refers to the concrete version. Given a path as a sequence of locations $path = l_1, \dots, l_k$ we often apply the graph homomorphism $f$ to the path by writing: $f(path) = f(l_1), \dots, f(l_k)$.


\newpage

\section{Proof Sketch}
\vspace{1em}

The goal of the proof is to show that the concretization and compilation functions commute. One can concretize an abstract policy and then compile the concrete result, or compile an abstract policy and the concretize the abstract result and know that the configurations will be the same. More specifically, we are interested in establishing the following theorem:

\begin{thm}
  for all \sysname policies pol, contexts $\Gamma$, and topologies G and $G^A$ related by the homomorphism $f$, 
  $$\Con(\Compile(pol,G^A),\Gamma,f,G) = \Compile(\Con(pol,\Gamma,f), G)$$
\end{thm}

\noindent
The proof proceeds in the following steps. 

\para{Product Graphs (Step 1)} First, we establish several facts about the relationship of the concrete and abstract product graphs given the definition for building the product graph. We start by assuming that both an abstract constraint and its concretized form are compiled to product graphs and preference functions: 
%
\[
\begin{array}{lll}
  \CompilePg(t_1 \Path~ \Con(r_1,\Gamma,f) \cap \EndR(L) ~\Prefer~ \ldots ~\Prefer~ \Con(r_n,\Gamma,f) \cap \EndR(L), G) &=& (t_1, PG, \Pref) \\
  \CompilePg(t_2 \Path~ r_1 ~\Prefer~ \ldots ~\Prefer~ r_n, G^A) &=& (t_2, PG^A, \Pref^A) \\
\end{array}
\]
%
where $L$ can be thought of as a set of destination locations (possibly $\Sigma$) for the prefix. Using these assumptions, we show that several relationships hold between $PG$ and $PG^A$ as well as between the inferred preference functions $\Pref$ and $\Pref^A$. In particular, we show that there is a homomorphism $f_{pg}$ from $PG$ to $PG^A$, and then using this fact, we demonstrate that the inferred local preference functions $\Pref$ and $\Pref^A$ have the property that for all nodes $m$ in $PG$,  $\Pref(m) = \Pref^A(f_{pg}(m))$.

\para{Substitution of Constraints (Step 2)} 
The next step is to use the relationships between $PG$ and $PG^A$ established in step 1 to show that concretization and compilation commute for an individual \sysname constraint p:
%
$$\Con(\Compile(p, G^A), \Gamma, f, G) = \Compile(\Con(p,\Gamma,f), G)$$
%
Constraints are of the form: $t \Path~ r_1 ~\Prefer~ \ldots ~\Prefer~ r_n$. The proof proceeds by case analysis on the predicate $t$. The proof is long, but mainly involves repeatedly applying the definition of concretization and compilation until all abstract sets of locations are written in terms of concrete sets of locations. The proofs from step 1 are then used to show that these sets are equivalent.

\para{Substitution of Policies (Step 3)} Finally, this theorem is lifted to \sysname policies $pol = p_1, \ldots, p_n$ using the proof from part 2 for individual constraints to obtain the final theorem:
%
$$\Con(\Compile(pol,G^A),\Gamma,f,G) = \Compile(\Con(pol,\Gamma,f), G)$$ 
%
The proof is obtained by unfolding of the definition of compilation and concretization and applying the previous theorem.

\newpage


\section{Substitution Proof}

\subsection{Product Graphs (Step 1)}
In this section, we will establish several relationships between the product graph and preference functions for abstract and concretized \sysname policies. To do so, we first relate the languages denoted by regular expressions under concretization. Then we lift this observation to automata, and finally to product graphs. We use these connections to construct a homomorphism for the product graphs and to relate the inferred BGP local preferences for abstract and concrete devices.


\newcommand{\Lang}{\ensuremath{\mathcal{L}}}

%We compile regular expressions to automata. As a side condition, we ensure that there are no transitions from some state $q$ to the initial state: $\sigma(q,x) = q_0$. This is done by creating another state $q_0'$ with the same transition function as $q_0$ and all other states transition to $q_0'$ instead of $q_0$.

\vspace{1em}
\begin{lem}
  For any context $\Gamma$, homomorphism $f$, and regular expression $r$, 
  path $p \in \Lang(con(r,\Gamma,f)) \iff f(p) \in \Lang(r)$.
\end{lem}
\begin{proof}
By induction on the structure of $r$

\emph{Case $\emptyset$:}
  \[ \begin{array}{lll}
    p \in \Lang(con(\emptyset,\Gamma,f)) &\iff& f(p) \in \Lang(\emptyset) \\
    p \in \emptyset &\iff& f(p) \in \emptyset \\
  \end{array} \]

\emph{Case $l$:}
  \[ \begin{array}{lll}
    p \in \Lang(con(l,\Gamma,f)) &\iff& f(p) \in \Lang(l) \\
    p \in \Lang(\Sigma_i ~ f_i^{-1}(l)) &\iff& f(p) \in \Lang(l) \\
    p \in \bigcup_i f_i^{-1}(l) &\iff& f(p) \in \Lang(l) \\
    p \in f^{-1}(l) &\iff& f(p) \in \{ l \} \\
    p \in f^{-1}(l) &\iff& f(p) = l \\
    \text{by the homomorphism} & & \\
  \end{array} \]

\emph{Case $r_1 \cup r_2$:}
  \[ \begin{array}{lll}
    p \in \Lang(con(r_1 \cup r_1,\Gamma,f)) &\iff& f(p) \in \Lang(r_1 \cup r_2) \\
    p \in \Lang(con(r_1,\Gamma,f) \cup con(r_1,\Gamma,f)) &\iff& f(p) \in \Lang(r_1 \cup r_2) \\
    p \in \Lang(con(r_1,\Gamma,f)) \cup \Lang(con(r_1,\Gamma,f)) &\iff& f(p) \in \Lang(r_1 \cup r_2) \\
    p \in \Lang(con(r_1,\Gamma,f)) \vee p \in \Lang(con(r_1,\Gamma,f)) 
       &\iff& 
       f(p) \in \Lang(r_1) \vee f(p) \in \Lang(r_2) \\
    \text{by cases and the IH} & & \\
  \end{array} \]

\emph{Case $r_1 \cap r_2$:} 
  \[ \begin{array}{c}
    \text{symmetric to } \cup \text{ case with } \wedge \text{ instead of } \vee
  \end{array} \]

\emph{Case $!r$:}
  \[ \begin{array}{lll}
    p \in \Lang(con(!r,\Gamma,f)) &\iff& f(p) \in \Lang(!r) \\
    p \in \Lang(!con(r,\Gamma,f)) &\iff& f(p) \in \Lang(!r) \\
    p \in \Sigma^* - \Lang(con(r,\Gamma,f)) &\iff& f(p) \in \Sigma^* - \Lang(r) \\
    \text{by the IH} & & \\
  \end{array} \]

\emph{Case $r^*$:}
  \[ \begin{array}{lll}
    p \in \Lang(con(r^*,\Gamma,f)) &\iff& f(p) \in \Lang(r^*) \\
    p \in \Lang(con(r,\Gamma,f)^*) &\iff& f(p) \in \Lang(r^*) \\
    p \in \bigcup_{i \in \mathbb{N}} \Lang(con(r,\Gamma,f))^i &\iff& f(p) \in \bigcup_{i \in \mathbb{N}} \in \Lang(r)^i \\
    \text{Follows from IH and definition of } \Lang(r)^i & & \\
  \end{array} \]

\end{proof}



\vspace{1em}
For the proof, we need to make sure that automata are constructed in a particular way to ensure a product graph homomorphism will exist. We assume an invariant that when regular expressions are translated to finite automata, there is no transition back to the initial state $q_0$. This can be done easily by introducing a second copy of $q_0$ that allows transitions. The reason is to distinguish if a state corresponds to a router ``owning" a prefix. We also compile automata in a particular way as defined below

\begin{defn}
Given a regular expression $r$ over abstract locations, homomorphism $f$, a nonempty set of locations $L$, and a finite state machine $M^A = (\Sigma,Q^A,q_0,\sigma^A,F^A)$, we construct a concrete state machine $M = (\Sigma, Q, q_0, \sigma, F)$ for the concretized policy $con(r,\Gamma, f) \cap \EndR(L)$ in the following way: 

    \[ \begin{array}{lll}
      1. & \sigma(q_0,l) = q' \iff \sigma^A(q,f(l)) = q' & \textbf{for each}~~ l \in L \\
      2. & \sigma(q,l) = q' \iff \sigma^A(q,f(l)) = q' & \textbf{for each}~~ l \in \Sigma - L \\
      3. & q \in F \iff q \in F^A & \\
    \end{array} \]
\end{defn}


Next, we show that the construction is correct. That is, the machine recognizes exactly the language $con(r,\Gamma, f) \cap \EndR(L)$.

\begin{lem}
  for any path $p$, $M$ matches $p$ $\iff$ $p \in \Lang(con(r,\Gamma, f) \cap \EndR(L))$
  %\vspace{1em}
  \begin{proof} 
    $ $
    \vspace{1em}

    \emph{Case} ($\Rightarrow$)

    Assume $M$ matches $p$. Then this means that $M^A$ matches $f(p)$. If we have a trace of string of the form $ p = x_1 \cdot \dots \cdot x_n$, then $f(p) = f(x_1) \cdot \dots \cdot f(x_n)$. For each transition $\sigma(q,l) = q'$ in the concrete automaton, we have transition $\sigma(q,f(l)) = q'$ in the abstract automaton, and they have the same final states, so this trace is accepting for $M^A$. Because $M^A$ matches $f(p)$, this means that $f(p) \in \Lang(r)$. From Lemma 1, this means that $p \in \Lang(con(r,\Gamma,f))$. We also know that, since there is only a transition from the initial state $\sigma(q_0,l)$ defined for $l \in L$ by construction, it means that $p \in \Lang(\text{end}(L))$. Since we know that $p \in \Lang(con(r_i,\Gamma,f))$ and $p \in \Lang(\text{end}(L))$, we know that $p \in \Lang(con(r,\Gamma,f) \cap \text{end}(l))$ and thus $p \in \Lang(con(r,\Gamma, f) \cap \EndR(L))$.

    \vspace{1em}
    \emph{Case} ($\Leftarrow$)

    Assume $p \in \Lang(con(r,\Gamma, f) \cap \EndR(L))$. This means that $p \in \Lang(con(r,\Gamma,f))$ and $p \in \Lang(\text{end}(L))$. Lemma 1, we know that $f(p) \in \Lang(r)$, which means that $M^A$ matches $f(p)$. 
    %
    Consider any string of the form $p = l \cdot x_2 \cdot \dots \cdot x_n$ such that $p \in \Lang(con(r,\Gamma,f) \cap \text{end}(L))$. Clearly $l \in L$ and there is a transition defined for $\sigma(q_0,l) = q_1$.
    %
    This means that $M^A$ matches $f(l) \cdot f(x_2) \cdot \dots \cdot f(x_n)$.
    %
    For each transition $\sigma^A(q,f(x_i)) = q'$, we have $\sigma(q,x_i) = q'$ in $M$.
    %
    Thus the string $l \cdot x_2 \cdot \dots \cdot x_n$ is accepted along the same path of automaton states.
  \end{proof}

\end{lem}

\vspace{.5em}
\begin{lem} $M$ and $M^A$ have the same set of states. That is, $Q = Q^A$.
    $ $
    \vspace{1em}
    \begin{proof}
      This follows from the construction of $M$. States in $M$ are copied over from states in $M^A$.
    \end{proof}
\end{lem}

\vspace{1em}
\para{Note:}
For the remainder of this section, we will prove a collection of lemmas assuming the following: 
%
\[
\begin{array}{lll}
  \CompilePg(t_1 \Path~ \Con(r_1,\Gamma,f) \cap \EndR(L) ~\Prefer~ \ldots ~\Prefer~ \Con(r_n,\Gamma,f) \cap \EndR(L), G) &=& (t_1, PG, \Pref) \\
  \CompilePg(t_2 \Path~ r_1 ~\Prefer~ \ldots ~\Prefer~ r_n, G^A) &=& (t_2, PG^A, \Pref^A) \\
\end{array}
\]
%
We will also assume that $PG = (G',start,rank)$ and $PG^A = (G'^A,start^A,rank^A)$ and that either $L = \Sigma$, or $L = \{ l \}$.
\vspace{2em}

\begin{lem}
  For any node $n = (l,q_1,\ldots,q_k)$ in $PG$ there exists a node $f(n) = (f(l),q_1,\ldots,q_k)$ in $PG^A$.
  \begin{proof}
    Consider a path of length k in $PG$ to node $n$. The proof proceeds by induction on the path length $k$, if $n$ is connected to $start$, then $q_i = q_{0_i}$. Since there are no transitions back to the initial state, there must be a node $f(n) = (f(l), q_{0_1}, \ldots, q_{0_1})$ or else there is a contradiction for Lemma 1. For the inductive case, if $n$ is the kth hop along the path, then it has an inbound edge from neighbor $k-1$. Call this neighbor $m$. Then $(m,n)$ is an edge in $PG$, there is a node $f(m)$ with the same states. From the graph homomorphism, we know that $(f(m),f(n))$ must be an edge in $PG^A$ and since $f(m)$ has the same states as $m$, by the construction of the automata, $f(n)$ will have the same states as $n$.
  \end{proof}
\end{lem}

\begin{lem}
  The homomorphism $f$ can be lifted to a new homomorphism $f_{pg}$ over the product graphs in the following way:
  \[ \begin{array}{rcl}
    f_{pg}( start ) & = & start^A  \\
    f_{pg}( (l,q_1,\ldots,q_n) ) & = & (f(l),q_1,\ldots,q_n) \\
  \end{array} \]

  Now we prove that $f_{pg}: G' \rightarrow G'^A$ is a valid homomorphism
  \begin{proof}
    From Lemma 5, $(f(l),q_1,\ldots,q_n)$ is a valid node in $PG^A$. 
    %
    Assume there is an edge in $PG$ from $x=(l,q_1,\ldots,q_n)$
    to $y=(l',q_1',\ldots,q_n')$. We know that $f(x) = (f(l),q_1,\ldots,q_n)$ and $f(y) = (f(l'),q_1',\ldots,q_n')$.
    %
    From the construction of PG, we know that $\sigma_i(q_k, l) = q_k'$. 
    Also from the construction of the abstract automata, we also know that $\sigma_i(q_k, l) = q_k' \iff \sigma^A_i(q_k, f(l)) = q_k'$. Therefore, we can conclude that $\sigma^A_i(q_k, f(l)) = q_k'$. However, from the definition of $PG^A$, this means that there must be an edge in $PG^A$ for ($f(x),f(y)$).
  \end{proof}
\end{lem}


\begin{lem}
  If $f_{pg}(n) = N$, then the product graph preference of these nodes is equal: $\Rank(n) = \Rank^A(N)$.

  \begin{proof}
    Assume $n = (l,q_1,\dots,q_k)$. From Lemma 6, we know $f_{pg}(n) = (f(l),q_1,\dots,q_k)$. 
    We also know that $q_i \in F \iff q_i \in F^A$. 
    By the definition of the ranking function $\Rank$, then 
    $\Rank(n) = \{ i ~\vert~ q_i \in F \} = \{ i ~\vert~ q_i \in F^A \} = \Rank^A(N)$.
  \end{proof}

\end{lem}


%\begin{lem}
%  For every state $N = (L, q_1, \dots, q_n)$ in $PG^A$ for which there is no edge $(start^A, N)$, there exists a state $n = (l,q_1, \ldots, q_n)$ in $PG$
%  such that $f_{pg}(n) = N$.
%  \begin{proof}
%    By assumption, we know that that $f$ is surjective. That is, every location $L$ in the original abstract topology $G^A$ is mapped to by at least one location $l$ in the concrete topology $G$: $f(l) = L$. %

%    Since there exists an $l$ such that $f(l) = L$, there must be the concrete node $(l, q_1, \ldots, q_n)$ in $PG$.%
%

%    %If $N$ is a node in $PG^A$ that is is not connected to the $start^A$ node, then no automata state is the initial state $q_i \neq q_{0_i}$. This means that that N must have at least one inbound edge that is not $start^A$, otherwise the node would not exist. Without loss of generality, assume there is an edge $(M,N)$ for $M = (L', s_1, \ldots, s_n)$.
%  \end{proof}
%\end{lem}


\vspace{1em}

Next, we show that whenever there is a transition in $PG^A$, there is a corresponding step in the concrete product graph $PG$. This will allows to show that, if the preference inference succeeds for the abstract product graph, then it will also succeed for the concrete product graph while inferring the same preferences.

\vspace{1em}

\begin{lem}
  If, for $PG$ and $PG^A$ we have the following:

  \[ \begin{array}{ll}
    1. & (a,b) ~\text{is an edge in the concrete topology G} \\
    2. & \Topo(m) = a \\
    3. & f_{pg}(m) = M \\
    4. & (M,N) ~ \text{is an edge in}~ PG^A \\
    5. & \Topo(N) = f(b) \\
  \end{array} \]

  then there exists a node $n$ in $PG$ where:

  \[ \begin{array}{ll}
    1. & \Topo(n) = b \\
    2. & f_{pg}(n) = N \\
    3. & (m,n) ~ \text{is an edge in the product graph}~ PG \\
  \end{array} \]

  \begin{proof}
    $ $
    \vspace{1em}
    
    \noindent
    Since $\Topo(m) = a$, suppose that $m = (a, q_1, \dots, q_k)$. We know that $f_{pg}(m) = M = (f(a), q_1, \dots, q_k)$. By assumption $N = (f(b), s_1, \dots, s_k)$. Let us take the node $n = (b, s_1, \dots, s_k)$. 

    \vspace{.8em}
    \begin{easylist}
      & Clearly $\Topo(n) = b$
      & Clearly $f_{pg}(n) = (f(b), s_1, \dots, s_k) = N$
      & Since $(M,N)$ is an edge in $PG^A$, we know that, for each automata transition function: $\sigma^A(q_i, f(b)) = s_i$. From the automata construction, this means that for each regular expression, $\sigma(q_i, b) = s_i$ if $q_i \neq q_{0_i}$. We know that $q_i \neq q_{0_i}$ due to the side condition for automaton construction that ensures no transitions to the initial state. It follows that $(m,n)$ is an edge in the product graph since $(a,b)$ is a valid topology edge by assumption, and $\sigma(q_i, b) = s_i$. 
    \end{easylist}

  \end{proof}
\end{lem}


\newcommand{\trans}[3]{\ensuremath{#1 \overset{#3}{\rightarrow} #2}}


\begin{lem}
  For any labelled transition $\trans{m}{m'}{l}$ in $PG$, there is a corresponding transition $\trans{f(m)}{f(m')}{f(l)}$ in $PG^A$.
  \begin{proof}
    if $m' = (l, q_1, \ldots, q_n)$, then $f(m') = (f(l), q_1, \ldots, q_n)$. Since there is the edge $(m,m')$ in $PG$, then there is the edge $(f(m),f(m'))$ in $PG^A$ by the homomorphism. Because $\Topo(f(m')) = f(l)$, there must be a transition $\trans{f(m)}{f(m')}{f(l)}$.
  \end{proof}
\end{lem}



\vspace{.4em}
\begin{lem}
  In the concrete product graph $PG$, $m \leq m' \iff f_{pg}(m) \leq f_{pg}(m')$ in the abstract product graph $PG^A$.
  \begin{proof}
    $ $

    \vspace{1em}
    \noindent
    We show that $\leq$ forms a simulation relation for the subgraph reachable from $m$ and $m'$ in $PG$ iff $\leq$ forms a simulation relation for the subgraph reachable from $f(m)$ and $f(m')$ for $PG^A$. This involves showing that $m \geq_{rank} m' \iff f(m) \geq_{rank} f(m')$, and that 
    for every transition $\trans{m}{n}{l}$ in $PG$ there is a transition $\trans{m'}{n'}{l}$ iff for every transition $\trans{f(m)}{f(n)}{f(l)}$ in $PG^A$ there is a transition $\trans{f(m')}{f(n')}{f(l)}$.

    \vspace{1em}
    \noindent
    \emph{Case} $(\Rightarrow)$

    \vspace{.4em}
    Consider the subgraph of $PG$ reachable from $m$ and $m'$. From $m \leq m'$ and the definition of ($\leq$), we know that $m' \geq_{rank} m$. 

    \noindent
    From Lemma 7, and $m' \geq_{rank} m$ we know that $f_{pg}(m') \geq_{rank} f_{pg}(m)$. 
    From Lemma 9, there is a transition $\trans{f(n)}{f(n')}{f(l)}$.

    \vspace{1.2em}
    \noindent
    \emph{Case} $(\Leftarrow)$

    \vspace{.4em}
    Let $M = f(m)$ and let $M' = f(m')$.
    Suppose that $M \leq M'$, which means that with $M' \geq_{rank} M$ in the abstract product graph. It also means that, for each neighbor $N'$, if we have the transition: $\trans{M'}{N'}{L}$ then we also have a transition: $\trans{M}{N}{L}$ where $N' \geq_{rank} N$. We must show that the same relation holds for $m$ and $m'$. 
    %
    Assume that $\Topo(M) = f(a)$ and $\Topo(N) = f(b)$. Also assume that $m'$ has a neighbor $n'$. We know that $\Topo(m) = a$ and $\Topo(m') = b$. Clearly $(a,b)$ is a valid concrete topology edge since it is a transition in the product graph between $m$ and $m'$. We now apply Lemma 7 with the following facts:

    \[ \begin{array}{ll}
      1. & (a,b) ~\text{is a concrete topology edge} \\
      2. & \Topo(m) = a \\
      3. & f_{pg}(m) = M \\
      4. & (M,N) ~\text{is an edge in}~ PG^A \\
      5. & \Topo(N) = f(b) \\
    \end{array} \]

    \noindent
    Lemma 7 lets us conclude that there exists a node $n$ such that:

    \[ \begin{array}{ll}
      1. & \Topo(n) = b \\
      2. & f_{pg}(n) = N \\
      3. & (m,n) ~\text{is a concrete edge in}~ PG \\
      4. & \Rank(n) = \Rank(N) \\
    \end{array} \] 

    \noindent
    Thus if there is transition $\trans{m'}{n'}{b}$, then there is also a transition $\trans{m}{n}{b}$. 
    Lemma 7 together with the assumption $N' \geq_{rank} N$ and the fact that $\Rank(n) = \Rank(N)$ lets us conclude that $n' \geq_{rank} n$.

  \end{proof}

\end{lem}


\vspace{1em}
Lemma 10 tells us that the total ordering between node preferences is preserved under the lifted graph homomorphism $f_{pg}$. 
We use this fact to define the local preference function ($\Pref : V \rightarrow \mathbb{N}$) that maps product graph nodes to numbers reflecting the total ordering such that $\Pref(m) = \Pref(f(m))$ for all product graph nodes $m$.

\vspace{1em}
\begin{defn}
  Assign $\Pref(m) = \Pref^A(f_{pg}(m))$ as increasing integers starting from 0 according to the total ordering for $\leq$.
  From Lemma 10, we know that $\Pref$ and $\Pref^A$ preserve the total ordering since: $\Pref(m) \leq \Pref(m') \iff m \leq m'$ and $\Pref(f_{pg}(m)) \leq \Pref(f_{pg}(m')) \iff f_{pg}(m) \leq f_{pg}(m')$.
\end{defn}





\vspace{3em}
\subsection{Constraint Substitution (Part 2)}

In this section, we aim to prove that concretization and compilation commute for individual \sysname constraints. Since a policy is simply an ordered sequence of constraints, it is then straightfoward to show that compilation and concretization commute for entire policies. In particular, we are interested in showing:
%
$$\Con(\Compile(p, G^A), \Gamma, f, G) = \Compile(\Con(p,\Gamma,f), G)$$
%
The proof goes by case analysis on the test $t$ in the constraint $p$, and makes heavy use of the lemmas about the product graphs from the previous section. We use one helper lemma here that relates sets of neighbors:

\begin{lem}

  For concrete ($PG$) and abstract ($PG^A$) product graphs related by $f_{pg}$, if $f(\ell) = \Topo(M)$, then

  \[ \begin{array}{l}
     ~~~~~~~~~ [~ pfx \rightarrow [~ ma~\vert~ \\
     ~~~~~~~~~~~~~~~~~~ M \leftarrow (l,q_M) \in PG^A, \\
     ~~~~~~~~~~~~~~~~~~ pin = \mathrm{adjIn}(PG^A,M), \\
     ~~~~~~~~~~~~~~~~~~ (in,q_N) \in \{(BS,q_N) ~\vert~ BS=\{b ~\vert~ b \in f^{-1}(B),~ (b,\ell) \in G.E,~ (B,q_N) \in pin \}, BS \neq \emptyset  \}, \\
     ~~~~~~~~~~~~~~~~~~ out \leftarrow \{ c ~\vert~ c \in f^{-1}(C), (c,\ell) \in G.E, (C,\_) \in \mathrm{adjOut}(PG^A,M) \}, \\
     ~~~~~~~~~~~~~~~~~~ ma = ord^A(M) : (in,q_N) \rightarrow (out,q_M) ~] ~] \\
  \end{array} \]%

  Is equivalent to

  \[ \begin{array}{l}
     ~~~~~~~~~ [~ pfx \rightarrow [~ ma ~\vert~ \\
     ~~~~~~~~~~~~~~~~~~ m \leftarrow (l,q_m) \in PG, \\
     ~~~~~~~~~~~~~~~~~~ pin \leftarrow \mathrm{adjIn}(PG,m), \\
     ~~~~~~~~~~~~~~~~~~ (in,q_n) \leftarrow \{ (bs,q_n) ~\vert~ bs=\{ b ~\vert~ (b,q_n) \in pin\}, bs \neq \emptyset \}), \\
     ~~~~~~~~~~~~~~~~~~ out \leftarrow \{ c ~\vert~ (c,\_) \in \mathrm{adjOut}(PG,m) \}, \\
     ~~~~~~~~~~~~~~~~~~ ma = ord^A(f_{pg}(m)) : (in,q_n) \rightarrow (out,q_m) ~] ~] \\
  \end{array} \]%

  \begin{proof}
    $ $
    \vspace{.4em}

    Suppose for node $M$, there exists a node $m=(l,q_m)$ such that $f_{pg}(m) = M$. 
    We want to show the following:
    %
    %$$\{ b ~\vert~ (b,q_n) \in \text{adjIn}(PG,m)\} \subseteq \{ b ~\vert~ (b,l) \in G.E \}$$
    %
    %This is trivially true from the definition of the product graph. Any product graph edge will correspond to a topology edge. The following inequality will also hold:
    %
    %$$ \{ b ~\vert~ (b,q_N) \in \text{adjIn}(PG,m)\} \subseteq \{b ~\vert~ b \in f^{-1}(B),~ (B,q_N) \in \text{adjIn}(PG^A,f_{pg}(m)) \}$$
    %
    %Since whenever $(b,q_N) \in adjIn(PG,m)$ it must be the case that $(B,q_N) \in adjIn(PG^A, f_{pg}(m))$ by the homomorphism, and because $f^{-1}(B) \supseteq \{ b \}$. By combining these observations, we can conclude the following:
    %
    $$\{b ~\vert~ b \in f^{-1}(B),~ (b,\ell) \in G.E,~ (B,q_N) \in \mathrm{adjIn}(PG^A,f_{pg}(m)) \}$$
    is equivalent to
    $$\{ b ~\vert~ (b,q_N) \in \mathrm{adjIn}(PG,m)\}$$
    %
    Suppose that an element $x \in \{ b ~\vert~ (b,q_N) \in \mathrm{adjIn}(PG,m)\}$. Then $(b,q_N) \in \mathrm{adjIn}(PG,m)$ and there is an edge $(b,\ell)$ in the topology between $b$ and $\Topo(m)$. From the homomorphism, this means $(f(b),q_N) \in \mathrm{adjIn}(PG^A,f(m))$. It follows that $x \in \{b ~\vert~ b \in f^{-1}(B),~ (b,\ell) \in G.E,~ (B,q_N) \in \mathrm{adjIn}(PG^A,f_{pg}(m)) \}$. 

    \vspace{1em}
    \noindent
    Now suppose the other direction. There is an element $x \in \{b ~\vert~ b \in f^{-1}(B),~ (b,\ell) \in G.E,~ (B,q_N) \in \mathrm{adjIn}(PG^A,f_{pg}(m)) \}$. We know that $f(x) = B$, and that there is a topology edge between $b$ and $\ell$. Lemma 7 together with the fact that $f(\ell) = \Topo(m)$ lets us conclude that there is an edge in the concrete $PG$ between $(b,q_N)$ and $m$. It follows then that $x \in \{ b ~\vert~ (b,q_N) \in \mathrm{adjIn}(PG,m)\}$.

    \vspace{1em}
    \noindent
    The same reasoning can be applied to adjOut as well. Further, note that because we are looking at a particular location $l$, there can only be at most one such $m = (l,q_N)$ such that $f_{pg}(m) = M = (f(l), q_N)$ since the automata are deterministic. 
    %
    This means that $M \leftarrow (l,q_M) \in PG^A$ can be replaced with $m \leftarrow (l,q_m) \in PG$ since for each $M$ we will either have some $m$ such that $f_{pg}(m) = M$ and the above equivalence holds, or else there is no such $M$, in which case the set is filtered by the condition: $BS \neq \emptyset$.

  \end{proof}


\end{lem}




\begin{thm}
  For all \sysname constraints $p$, contexts $\Gamma$, topologies $G$ and $G^A$ related by homomorphism $f : G \rightarrow G^A$:
  $$\Con(\Compile(p,G^A),\Gamma,f,G) = \Compile(\Con(p,\Gamma,f),G)$$

  \begin{proof} From the grammar, we know that $p = (t \Path~ r_1 ~\Prefer~ \ldots ~\Prefer~ r_n)$. The proof proceeds by cases on $t$. In each case, we expand the definition of $\Compile$ and $\Con$ until they no longer appear in the term. We then appeal to graph properties of $PG$ and $PG^A$ to rewrite the terms into equivalent forms.

  \vspace{.4em}
  \noindent
  \textbf{Case} ($t = pfx$)
  \vspace{.4em}

    For the right side:

    \[
    \begin{array}{llll}
      & & \Compile(\Con(p,\Gamma,f),G) \\
      &=& \Compile(\Con(pfx \Path~ r_1 ~\Prefer~ \ldots ~\Prefer~ r_n, \Gamma,f), G) 
            & \text{Substitution} \\
      &=& \Compile(pfx \Path~ \Con(r_1,\Gamma,f) ~\Prefer~ \ldots ~\Prefer~ \Con(r_n, \Gamma,f), G) 
            & \text{Definition of con} \\
      &=& \Compile(pfx \Path~ \Con(r_1,\Gamma,f) \cap \EndR(\Sigma) ~\Prefer~ \ldots ~\Prefer~ \Con(r_n, \Gamma,f) \cap \EndR(\Sigma), G) 
            & \text{Regex Equivalence}\\
      &=& \CompileMbgp([\CompilePg(pfx \Path~ \Con(r_1,\Gamma,f) \cap \EndR(\Sigma) ~\Prefer~ \ldots ~\Prefer~ \Con(r_n, \Gamma,f) \cap \EndR(\Sigma),G)]) 
            & \text{Definition of compile} \\

      &=& \CompileMbgp([(pfx, PG, \Pref)]) 
            & \text{Assumption} \\

    \end{array}
    \]

    Similarly, for the left side:

        \[
    \begin{array}{llll}
      & & \Con(\Compile(p,G^A),\Gamma,f,G) \\
      &=& \Con(\Compile(pfx \Path~ r_1 ~\Prefer~ \ldots ~\Prefer~ r_n,G^A),\Gamma,f,G)
            & \text{Substitution} \\
      &=& \Con(\CompileMbgp([\CompilePg(pfx \Path~ r_1 ~\Prefer~ \ldots ~\Prefer~ r_n,G^A)]),\Gamma,f,G)
            & \text{Definition of Compile} \\
      &=& \Con(\CompileMbgp([(pfx,PG^A,\Pref^A)]),\Gamma,f,G)
            & \text{Assumption}\\
    \end{array}
    \]

    Both sides of the equality are now in a form where we can apply the lemmas from the previous section.
    This allows us to relate $PG$ and $PG^A$ as well as $\Pref$ and $\Pref^A$.
    Continuing to expand the right side by substituting the definition of $\CompileMbgp$ we get: 

    \vspace{1em}
    \noindent
    \textbf{(Right-hand side)}

  \[ \begin{array}{l}
     ~~~~~ [~ l \rightarrow rc ~\vert~ \\
     ~~~~~~~~~~~~ l \in internal(G.V), ~rc =  \\
     ~~~~~~~~~~~~~~~ [~ pfx \rightarrow [~ ma ~\vert~ \\
     ~~~~~~~~~~~~~~~~~~~~~ m \leftarrow (l,q_m) \in PG, \\
     ~~~~~~~~~~~~~~~~~~~~~ pin \leftarrow \text{adjIn}(PG,m), \\
     ~~~~~~~~~~~~~~~~~~~~~ (in,q_n) \leftarrow \{ (bs,q_n) ~\vert~ bs=\{b ~\vert~ (b,q_n) \in pin \}, bs \neq \emptyset \}, \\
     ~~~~~~~~~~~~~~~~~~~~~ out \leftarrow \{ c ~\vert~ (c,\_) \in \text{adjOut}(PG_i,m) \}, \\
     ~~~~~~~~~~~~~~~~~~~~~ ma = \Pref(m) : (in,q_n) \rightarrow (out,q_m) ~] ~] ~]\\
  \end{array} \]%

  Next we further expand on the left side for the abstract topology to show it is equivalent:

    \vspace{1em}
    \noindent
    \textbf{(Left-hand side)}

  \[ \begin{array}{l}
     ~~~~~ \Con([~ l \rightarrow rc ~\vert~ \\
     ~~~~~~~~~~~~ l \in internal(G^A.V), ~rc =  \\
     ~~~~~~~~~~~~~~~ [~ pfx \rightarrow [~ ma ~\vert~ \\
     ~~~~~~~~~~~~~~~~~~~~~ M \leftarrow (l,q_M) \in PG^A, \\
     ~~~~~~~~~~~~~~~~~~~~~ pin \leftarrow \text{adjIn}(PG^A,M), \\
     ~~~~~~~~~~~~~~~~~~~~~ (in,q_N) \leftarrow \{ (BS,q_N) ~\vert~ BS=\{B ~\vert~ (B,q_N) \in pin \}, BS \neq \emptyset \}, \\
     ~~~~~~~~~~~~~~~~~~~~~ out \leftarrow \{ C ~\vert~ (C,\_) \in \text{adjOut}(PG^A,M) \}, \\
     ~~~~~~~~~~~~~~~~~~~~~ ma = \Pref^A(M) : (in,q_N) \rightarrow (out,q_M) ~] ~] ~], \Gamma, f, G) \\
  \end{array} \]%

  We apply the definition of $\Con$ to push it inside the list:

    \[ \begin{array}{l}
     ~~~~~ [~ \ell \rightarrow \Con(rc, \ell, \Gamma, f, G) ~\vert~ \\
     ~~~~~~~~~~~~ \ell \in f^{-1}(l), \\
     ~~~~~~~~~~~~ l \in internal(G^A.V), ~rc =  \\
     ~~~~~~~~~~~~~~~ [~ pfx \rightarrow [~ ma ~\vert~ \\
     ~~~~~~~~~~~~~~~~~~~~~ M \leftarrow (l,q_M) \in PG^A, \\
     ~~~~~~~~~~~~~~~~~~~~~ pin \leftarrow \text{adjIn}(PG^A,M), \\
     ~~~~~~~~~~~~~~~~~~~~~ (in,q_N) \leftarrow \{ (BS,q_N) ~\vert~ BS=\{B ~\vert~ (B,q_N) \in pin \}, BS \neq \emptyset \}, \\
     ~~~~~~~~~~~~~~~~~~~~~ out \leftarrow \{ C ~\vert~ (C,\_) \in \text{adjOut}(PG^A,M) \}, \\
     ~~~~~~~~~~~~~~~~~~~~~ ma = \Pref^A(M) : (in,q_N) \rightarrow (out,q_M) ~] ~] ~] \\
  \end{array} \]%

  We now apply the definition of $\Con$ to push it further inside:

      \[ \begin{array}{l}
     ~~~~~ [~ \ell \rightarrow rc ~\vert~ \\
     ~~~~~~~~~~~~ \ell \in f^{-1}(l), \\
     ~~~~~~~~~~~~ l \in internal(G^A.V), ~rc =  \\
     ~~~~~~~~~~~~~~~ \Con([~ pfx \rightarrow [~ ma ~\vert~ \\
     ~~~~~~~~~~~~~~~~~~~~~ M \leftarrow (l,q_M) \in PG^A, \\
     ~~~~~~~~~~~~~~~~~~~~~ pin \leftarrow \text{adjIn}(PG^A,M), \\
     ~~~~~~~~~~~~~~~~~~~~~ (in,q_N) \leftarrow \{ (BS,q_N) ~\vert~ BS=\{B ~\vert~ (B,q_N) \in pin \}, BS \neq \emptyset \}, \\
     ~~~~~~~~~~~~~~~~~~~~~ out \leftarrow \{ C ~\vert~ (C,\_) \in \text{adjOut}(PG^A,M) \}, \\
     ~~~~~~~~~~~~~~~~~~~~~ ma = \Pref^A(M) : (in,q_N) \rightarrow (out,q_M) ~] ~], \Gamma, f, G) ~] \\
  \end{array} \]%

  Once again, we apply the definition of $\Con$

      \[ \begin{array}{l}
     ~~~~~ [~ \ell \rightarrow rc ~\vert~ \\
     ~~~~~~~~~~~~ \ell \in f^{-1}(l), \\
     ~~~~~~~~~~~~ l \in internal(G^A.V), ~rc =  \\
     ~~~~~~~~~~~~~~~ [~ pfx \rightarrow [~ ma ~\vert~ \\
     ~~~~~~~~~~~~~~~~~~~~~ M \leftarrow (l,q_M) \in PG^A, \\
     ~~~~~~~~~~~~~~~~~~~~~ pin \leftarrow \text{adjIn}(PG^A,M), \\
     ~~~~~~~~~~~~~~~~~~~~~ (in,q_N) \leftarrow \{ (BS,q_N) ~\vert~ BS=\{B ~\vert~ (B,q_N) \in pin \}, BS \neq \emptyset \}, \\
     ~~~~~~~~~~~~~~~~~~~~~ out \leftarrow \{ C ~\vert~ (C,\_) \in \text{adjOut}(PG^A,M) \}, \\
     ~~~~~~~~~~~~~~~~~~~~~ ma = \Con(\Pref^A(M) : (in,q_N) \rightarrow (out,q_M), true, \ell, \Gamma, f, G) ~] ~] ~] \\
    \end{array} \]% 

    Next, we rewrite the sets $in$ and $out$ according to $\Con$:

      \[ \begin{array}{l}
     ~~~~~ [~ \ell \rightarrow rc ~\vert~ \\
     ~~~~~~~~~~~~ \ell \in f^{-1}(l), \\
     ~~~~~~~~~~~~ l \in internal(G^A.V), ~rc =  \\
     ~~~~~~~~~~~~~~~ [~ pfx \rightarrow [~ ma ~\vert~ \\
     ~~~~~~~~~~~~~~~~~~~~~ M \leftarrow (l,q_M) \in PG^A, \\
     ~~~~~~~~~~~~~~~~~~~~~ pin \leftarrow \text{adjIn}(PG^A,M), \\
     ~~~~~~~~~~~~~~~~~~~~~ (\Con(in,\ell,\Gamma,f,G),q_N) \leftarrow \{ (BS,q_N) ~\vert~ BS=\{B ~\vert~ (B,q_N) \in pin \}, BS \neq \emptyset \}, \\
     ~~~~~~~~~~~~~~~~~~~~~ out \leftarrow \Con(\{ C ~\vert~ (C,\_) \in \text{adjOut}(PG^A,M) \}, \ell,\Gamma,f,G), \\
     ~~~~~~~~~~~~~~~~~~~~~ ma = \Pref^A(M) : (in,q_N) \rightarrow (out,q_M) ~] ~] ~] \\
  \end{array} \]%

  Rewrite $\Con$ in the set $in$:

    \[ \begin{array}{l}
     ~~~~~ [~ \ell \rightarrow rc ~\vert~ \\
     ~~~~~~~~~~~~ \ell \in f^{-1}(l), \\
     ~~~~~~~~~~~~ l \in internal(G^A.V), ~rc =  \\
     ~~~~~~~~~~~~~~~ [~ pfx \rightarrow [~ ma ~\vert~ \\
     ~~~~~~~~~~~~~~~~~~~~~ M \leftarrow (l,q_M) \in PG^A, \\
     ~~~~~~~~~~~~~~~~~~~~~ pin \leftarrow \text{adjIn}(PG^A,M), \\
     ~~~~~~~~~~~~~~~~~~~~~ (in,q_N) \leftarrow \{ (BS,q_N) ~\vert~ BS=\Con(\{B ~\vert~ (B,q_N) \in pin \}, \ell, \Gamma, f, G), BS \neq \emptyset \}, \\
     ~~~~~~~~~~~~~~~~~~~~~ out \leftarrow \Con(\{ C ~\vert~ (C,\_) \in \text{adjOut}(PG^A,M) \}, \ell,\Gamma,f,G), \\
     ~~~~~~~~~~~~~~~~~~~~~ ma = \Pref^A(M) : (in,q_N) \rightarrow (out,q_M) ~] ~] ~] \\
  \end{array} \]%

  Apply the definition of $\Con$ on the inner set of $in$ and $out$:

    \[ \begin{array}{l}
     ~~~~~ [~ \ell \rightarrow rc ~\vert~ \\
     ~~~~~~~~~~~~ \ell \in f^{-1}(l), \\
     ~~~~~~~~~~~~ l \in internal(G^A.V), ~rc =  \\
     ~~~~~~~~~~~~~~~ [~ pfx \rightarrow [~ ma ~\vert~ \\
     ~~~~~~~~~~~~~~~~~~~~~ M \leftarrow (l,q_M) \in PG^A, \\
     ~~~~~~~~~~~~~~~~~~~~~ pin \leftarrow \text{adjIn}(PG^A,M), \\
     ~~~~~~~~~~~~~~~~~~~~~ (in,q_N) \leftarrow \{ (BS,q_N) ~\vert~ BS=\{b ~\vert~ b \in f^{-1}(B), (b,\ell)\in G.E, (B,q_N) \in pin \}, BS \neq \emptyset \}, \\
     ~~~~~~~~~~~~~~~~~~~~~ out \leftarrow \{ c ~\vert~ c \in f^{-1}(C), (c,\ell)\in G.E, (C,\_) \in \text{adjOut}(PG^A,M) \}, \\
     ~~~~~~~~~~~~~~~~~~~~~ ma = \Con(\Pref^A(M) : (in,q_N) \rightarrow (out,q_M), true, \ell, \Gamma, f, G) ~] ~] ~] \\
  \end{array} \]%

  Applying Lemma 10 with the fact that $f(\ell) = l = \Topo(M)$ this is equivalent to the following:

    \[ \begin{array}{l}
     ~~~~~ [~ l \rightarrow rc ~\vert~ \\
     ~~~~~~~~~~~~ l \in internal(G.V), ~rc =  \\
     ~~~~~~~~~~~~~~~ [~ pfx \rightarrow [~ ma ~\vert~ \\
     ~~~~~~~~~~~~~~~~~~~~~ m \leftarrow (l,q_m) \in PG, \\
     ~~~~~~~~~~~~~~~~~~~~~ pin \leftarrow \text{adjIn}(PG,m), \\
     ~~~~~~~~~~~~~~~~~~~~~ (in,q_n) \leftarrow \{ (bs,q_n) ~\vert~ bs=\{b ~\vert~ (b,q_n) \in pin \}, bs \neq \emptyset \}, \\
     ~~~~~~~~~~~~~~~~~~~~~ out \leftarrow \{ c ~\vert~ (c,\_) \in \text{adjOut}(PG,m) \}, \\
     ~~~~~~~~~~~~~~~~~~~~~ ma = \Pref^A(f_{pg}(m)) : (in,q_) \rightarrow (out,q_m) ~] ~] ~]\\
  \end{array} \]%

  From Definition 2, we know that the $\Pref(m) = \Pref(f_{pg}(m))$:

    \[ \begin{array}{l}
     ~~~~~ [~ l \rightarrow rc ~\vert~ \\
     ~~~~~~~~~~~~ l \in internal(G.V), ~rc =  \\
     ~~~~~~~~~~~~~~~ [~ pfx \rightarrow [~ ma ~\vert~ \\
     ~~~~~~~~~~~~~~~~~~~~~ m \leftarrow (l,q_m) \in PG, \\
     ~~~~~~~~~~~~~~~~~~~~~ pin \leftarrow \text{adjIn}(PG,m), \\
     ~~~~~~~~~~~~~~~~~~~~~ (in,q_n) \leftarrow \{ (bs,q_n) ~\vert~ bs=\{b ~\vert~ (b,q_n) \in pin \}, bs \neq \emptyset \}, \\
     ~~~~~~~~~~~~~~~~~~~~~ out \leftarrow \{ c ~\vert~ (c,\_) \in \text{adjOut}(PG,m) \}, \\
     ~~~~~~~~~~~~~~~~~~~~~ ma = \Pref(m) : (in,q_n) \rightarrow (out,q_m) ~] ~] ~]\\
  \end{array} \]%

  This is exactly the result we obtained from expanding the right hand side of the equality.

  \vspace{.4em}
  \noindent
  \textbf{Case} ($t = \$x$)
  \vspace{.4em}

    \noindent
    The case for $t = \$x$ follows a similar line of reasoning. We start by evaluating the right-hand side:

    \vspace{1em}
    \noindent
    \textbf{(Right-hand side)}
    %
    \[
    \begin{array}{llll}
      & & \Compile(\Con(p,\Gamma,f),G) \\
      &=& \Compile(\Con(\$x \Path~ r_1 ~\Prefer~ \ldots ~\Prefer~ r_n, \Gamma,f), G) 
            & \text{Substitution} \\
      &=& \Compile([pfx \Path~ \Con(r_1,\Gamma,f) \cap \EndR(l) ~\Prefer~ \ldots ~\Prefer~ \Con(r_n, \Gamma,f) \cap \EndR(l) ~\vert~ (pfx,l) \in \Gamma(x)], G) 
            & \text{Definition of con} \\
      &=& \CompileMbgp([\CompilePg(pfx \Path~ \Con(r_1,\Gamma,f) \cap \EndR(l) ~\Prefer~ \\
      & & ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ \ldots ~\Prefer~ \\ 
      & & ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ \Con(r_n, \Gamma,f) \cap \EndR(l),G) ~\vert~ (pfx,l) \in \Gamma(x)]) 
            & \text{Definition of compile} \\

      &=& \CompileMbgp([(pfx_1, PG_1, \Pref_1), \ldots, (pfx_k, PG_k, \Pref_k)]) 
            & \text{Assumption} \\

    \end{array}
    \]

    \noindent
    Expanding further, this becomes:

      \[ \begin{array}{l}
     ~~~~~ [~ l \rightarrow rc ~\vert~ \\
     ~~~~~~~~~~~~ l \in internal(G.V), ~rc = append_i \\
     ~~~~~~~~~~~~~~~ [~ pfx_i \rightarrow [~ ma ~\vert~ \\
     ~~~~~~~~~~~~~~~~~~~~~ (pfx_i, \_) \in \Gamma(x), \\
     ~~~~~~~~~~~~~~~~~~~~~ m \leftarrow (l,q_m) \in PG_i, \\
     ~~~~~~~~~~~~~~~~~~~~~ pin \leftarrow \text{adjIn}(PG_i,m), \\
     ~~~~~~~~~~~~~~~~~~~~~ (in,q_n) \leftarrow \{ (bs,q_n) ~\vert~ bs=\{b ~\vert~ (b,q_n) \in pin \}, bs \neq \emptyset \}, \\
     ~~~~~~~~~~~~~~~~~~~~~ out \leftarrow \{ c ~\vert~ (c,\_) \in \text{adjOut}(PG_i,m) \}, \\
     ~~~~~~~~~~~~~~~~~~~~~ ma = \Pref_i(m) : (in,q_n) \rightarrow (out,q_m) ~] ~] ~]\\
  \end{array} \]%

    \noindent
    As before, we now show that the left hand side is equivalent by applying the definitions of $\Con$ and $\Compile$:

    \vspace{1em}
    \noindent
    \textbf{(Left-hand side)}
    %
    \[
    \begin{array}{llll}
      & & \Con(\Compile(p,G^A),\Gamma,f,G) \\
      &=& \Con(\Compile(\$x \Path~ r_1 ~\Prefer~ \ldots ~\Prefer~ r_n,G^A),\Gamma,f,G)
            & \text{Substitution} \\
      &=& \Con(\CompileMbgp([\CompilePg(\$x \Path~ r_1 ~\Prefer~ \ldots ~\Prefer~ r_n,G^A)]),\Gamma,f,G)
            & \text{Definition of Compile} \\
      &=& \Con(\CompileMbgp([(\$x,PG^A,\Pref^A)]),\Gamma,f,G)
            & \text{Assumption}\\
    \end{array}
    \]

  \noindent
  Note that $PG_i$ and $PG^A$, as well as $\Pref$ and $\Pref^A$ are related by the lemmas from the previous section. Next we further expand on the left side for the abstract topology to show it is equivalent:

  \[ \begin{array}{l}
     ~~~~~ \Con([~ l \rightarrow rc ~\vert~ \\
     ~~~~~~~~~~~~ l \in internal(G^A.V), ~rc =  \\
     ~~~~~~~~~~~~~~~ [~ \$x \rightarrow [~ ma ~\vert~ \\
     ~~~~~~~~~~~~~~~~~~~~~ M \leftarrow (l,q_M) \in PG^A, \\
     ~~~~~~~~~~~~~~~~~~~~~ pin \leftarrow \text{adjIn}(PG^A,M), \\
     ~~~~~~~~~~~~~~~~~~~~~ (in,q_N) \leftarrow \{ (BS,q_N) ~\vert~ BS=\{B ~\vert~ (B,q_N) \in pin \}, BS \neq \emptyset \}, \\
     ~~~~~~~~~~~~~~~~~~~~~ out \leftarrow \{ C ~\vert~ (C,\_) \in \text{adjOut}(PG^A,M) \}, \\
     ~~~~~~~~~~~~~~~~~~~~~ ma = \Pref^A(M) : (in,q_N) \rightarrow (out,q_M) ~] ~] ~], \Gamma, f, G) \\
  \end{array} \]%

  \noindent
  We apply the definition of $\Con$ to push it inside the list:

  \[ \begin{array}{l}
     ~~~~~ [~ \ell \rightarrow \Con(rc, \ell, \Gamma, f, G) ~\vert~ \\
     ~~~~~~~~~~~~ \ell \in f^{-1}(l), \\
     ~~~~~~~~~~~~ l \in internal(G^A.V), ~rc = \\
     ~~~~~~~~~~~~~~~ [~ \$x \rightarrow [~ ma ~\vert~ \\
     ~~~~~~~~~~~~~~~~~~~~~ M \leftarrow (l,q_M) \in PG^A, \\
     ~~~~~~~~~~~~~~~~~~~~~ pin \leftarrow \text{adjIn}(PG^A,M), \\
     ~~~~~~~~~~~~~~~~~~~~~ (in,q_N) \leftarrow \{ (BS,q_N) ~\vert~ BS=\{B ~\vert~ (B,q_N) \in pin \}, BS \neq \emptyset \}, \\
     ~~~~~~~~~~~~~~~~~~~~~ out \leftarrow \{ C ~\vert~ (C,\_) \in \text{adjOut}(PG^A,M) \}, \\
     ~~~~~~~~~~~~~~~~~~~~~ ma = \Pref^A(M) : (in,q_N) \rightarrow (out,q_M) ~] ~] ~] \\
  \end{array} \]%

  \noindent
  We now apply the definition of $\Con$ to push it further inside:

  \[ \begin{array}{l}
     ~~~~~ [~ \ell \rightarrow rc ~\vert~ \\
     ~~~~~~~~~~~~ \ell \in f^{-1}(l), \\
     ~~~~~~~~~~~~ l \in internal(G^A.V), ~rc = \\
     ~~~~~~~~~~~~~~~ \Con([~ \$x \rightarrow [~ ma ~\vert~ \\
     ~~~~~~~~~~~~~~~~~~~~~ M \leftarrow (l,q_M) \in PG^A, \\
     ~~~~~~~~~~~~~~~~~~~~~ pin \leftarrow \text{adjIn}(PG^A,M), \\
     ~~~~~~~~~~~~~~~~~~~~~ (in,q_N) \leftarrow \{ (BS,q_N) ~\vert~ BS=\{B ~\vert~ (B,q_N) \in pin \}, BS \neq \emptyset \}, \\
     ~~~~~~~~~~~~~~~~~~~~~ out \leftarrow \{ C ~\vert~ (C,\_) \in \text{adjOut}(PG^A,M) \}, \\
     ~~~~~~~~~~~~~~~~~~~~~ ma = \Pref^A(M) : (in,q_N) \rightarrow (out,q_M) ~] ~], \Gamma, f, G) ~] \\
  \end{array} \]%

  \noindent
  Once again, we apply the definition of $\Con$

  \[ \begin{array}{l}
     ~~~~~ [~ \ell \rightarrow rc ~\vert~ \\
     ~~~~~~~~~~~~ \ell \in f^{-1}(l), \\
     ~~~~~~~~~~~~ l \in internal(G^A.V), ~rc = append_i \\
     ~~~~~~~~~~~~~~~ [~ pfx_i \rightarrow [~ ma ~\vert~ \\
     ~~~~~~~~~~~~~~~~~~~~~ (pfx_i, l') \in \Gamma(x), \\
     ~~~~~~~~~~~~~~~~~~~~~ M \leftarrow (l,q_M) \in PG^A, \\
     ~~~~~~~~~~~~~~~~~~~~~ pin \leftarrow \text{adjIn}(PG^A,M), \\
     ~~~~~~~~~~~~~~~~~~~~~ (in,q_N) \leftarrow \{ (BS,q_N) ~\vert~ BS=\{B ~\vert~ (B,q_N) \in pin \}, BS \neq \emptyset \}, \\
     ~~~~~~~~~~~~~~~~~~~~~ out \leftarrow \{ C ~\vert~ (C,\_) \in \text{adjOut}(PG^A,M) \}, \\
     ~~~~~~~~~~~~~~~~~~~~~ ma = \Con(\Pref^A(M) : (in,q_N) \rightarrow (out,q_M), \Gamma, f, G) ~] ~] ~] \\
  \end{array} \]%

  \noindent
  Once again, we apply the definition of $\Con$

  \[ \begin{array}{l}
     ~~~~~ [~ \ell \rightarrow rc ~\vert~ \\
     ~~~~~~~~~~~~ \ell \in f^{-1}(l), \\
     ~~~~~~~~~~~~ l \in internal(G^A.V), ~rc = append_i \\
     ~~~~~~~~~~~~~~~ [~ pfx_i \rightarrow [~ ma ~\vert~ \\
     ~~~~~~~~~~~~~~~~~~~~~ (pfx_i, l') \in \Gamma(x), \\
     ~~~~~~~~~~~~~~~~~~~~~ M \leftarrow (l,q_M) \in PG^A, \\
     ~~~~~~~~~~~~~~~~~~~~~ pin \leftarrow \text{adjIn}(PG^A,M), \\
     ~~~~~~~~~~~~~~~~~~~~~ (in,q_N) \leftarrow \{ (BS,q_N) ~\vert~ BS=\{B ~\vert~ (B,q_N) \in pin \}, BS \neq \emptyset \}, \\
     ~~~~~~~~~~~~~~~~~~~~~ out \leftarrow \{ C ~\vert~ (C,\_) \in \text{adjOut}(PG^A,M) \}, \\
     ~~~~~~~~~~~~~~~~~~~~~ ma = \textbf{if } in = \{ G.start \} \text{ and } l'=\ell \textbf{ then } \bullet \\
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ \textbf{else } \Pref^A(M) : (\Con(in, \ell, \Gamma, f, G),q_N) \rightarrow (\Con(out, \ell, \Gamma, f, G), q_M) ~] ~] ~]\\
  \end{array} \]%

  After filtering the cases where $in = \{ G.start \}$ and $l' \neq \ell$, we have the same situation as the previous case. 
  However, we know that each $PG_{i}$ was constructed from $con(r_{i}, \ell, \Gamma, f, G) \cap end(l_{i})$. This means that the only state in $PG_{i}$ connected to the start node ($\mathit{start}$) is a node for $l_{i}$. This was ensured by the fact that the transition function for each regular expression $\sigma_{i}(q_0,l) = q$ is defined only for locations $l \in L$ where $L = \{ l_{i} \}$ from the construction of the automata. We apply Lemma 10 with the fact that $f(\ell) = \Topo(M)$:

    \[ \begin{array}{l}
     ~~~~~ [~ \ell \rightarrow rc ~\vert~ \\
     ~~~~~~~~~~~~ l \in internal(G.V), ~rc = append_i \\
     ~~~~~~~~~~~~~~~ [~ pfx_i \rightarrow [~ ma ~\vert~ \\
     ~~~~~~~~~~~~~~~~~~~~~ (pfx_i, l') \in \Gamma(x), \\
     ~~~~~~~~~~~~~~~~~~~~~ m \leftarrow (l,q_m) \in PG_i, \\
     ~~~~~~~~~~~~~~~~~~~~~ pin \leftarrow \text{adjIn}(PG_i,m), \\
     ~~~~~~~~~~~~~~~~~~~~~ (in,q_n) \leftarrow \{ (bs,q_n) ~\vert~ bs=\{b ~\vert~ (b,q_n) \in pin \}, bs \neq \emptyset \}, \\
     ~~~~~~~~~~~~~~~~~~~~~ out \leftarrow \{ C ~\vert~ (C,\_) \in \text{adjOut}(PG_i,m) \}, \\
     ~~~~~~~~~~~~~~~~~~~~~ ma = \Pref_i(m) : (in,q_n) \rightarrow (out,q_m)  ~] ~] ~]\\
  \end{array} \]%



  \end{proof}

\end{thm}


\vspace{2em}
\begin{thm}
  For all \sysname policies $pol$, contexts $\Gamma$, topologies $G$ and $G^A$ related by homomorphism $f : G \rightarrow G^A$:
  $$\Con(\Compile(pol,G^A),\Gamma,f,G) = \Compile(\Con(pol,\Gamma,f),G)$$

  \begin{proof} 
    $ $

    \vspace{.5em}
    \noindent
    The proof simply uses Theorem 11 after rewriting the policy according to $\Con$ and $\Compile$.
    Given a policy $pol = p_1, \ldots, p_n$ we apply Theorem 11 after rewriting the policy. For the left side:
    \[
    \begin{array}{llll}
      & & \Con(\Compile(pol,G^A),\Gamma,f,G) \\
      &=& \Con(\Compile(p_1, \ldots, p_n, G^A),\Gamma,f,G) & \text{Substitution} \\
      &=& \Con(\CompileMbgp([\CompilePg(p_1, G^A), \ldots, \CompilePg(p_n, G^A)]),\Gamma,f,G)
            & \text{Definition of Compile} \\
      &=& \Con(\CompileMbgp([(t_1,PG^A_1,\Pref^A_1), \ldots, (t_n,PG^A_n,\Pref^A_n)]),\Gamma,f,G)
            & \text{Assumption}\\
    \end{array}
    \]

    \vspace{.5em}
    \noindent
    For the right side of the equation:
    \[
    \begin{array}{llll}
      & & \Compile(\Con(pol,\Gamma,f),G) \\
      &=& \Compile(\Con(p1,\dots,p_n, \Gamma,f), G) 
            & \text{Substitution} \\
      &=& \Compile(\Con(p1, \Gamma, f),\dots, \Con(p_n, \Gamma,f), G) 
            & \text{Definition of con} \\
      &=& \CompileMbgp([\CompilePg(\Con(p1, \Gamma, f),G), \ldots, \CompilePg(\Con(p_n, \Gamma, f),G)]) 
            & \text{Definition of compile} \\

      &=& \CompileMbgp([(t'_1, PG_1, \Pref_1), \ldots, (t'_n, PG_n, \Pref_n)])
            & \text{Assumption} \\

    \end{array}
    \]


    \vspace{1em}
    \noindent
    \textbf{(Given)}

    \noindent
    First, we observe that, for each $p_i$, Theorem 11 and $\CompilePg$ give us that, for each $i$:

    \[
    \begin{array}{lll}
    &   \Con([~ l \rightarrow rc ~\vert~ l \in internal(G^A.V), rc = 
        [\CompilePred((t_i, PG^A_i, \Pref^A_i))] ~~], \Gamma,f,G)     & \text{Left side} \\
    = & [~ l \rightarrow rc ~\vert~ l \in internal(G.V), rc = 
        [\Con(\CompilePred((t_i, PG^A_i, \Pref^A_i)), \Gamma,f,G)] ~~] & \text{Definition of con} \\
    = & [~ l \rightarrow rc ~\vert~ l \in internal(G.V), rc = [\CompilePred((t'_i, PG_i, \Pref_i))] ~~]
        & \text{Right side} \\
    \end{array}
    \]
 
    \vspace{1em}
    \noindent
    \textbf{(To Show)}

    \vspace{.4em}
    \noindent
    By applying the definition of $\CompileMbgp$, we start with the left hand side:

    \[ \begin{array}{l}
     ~~~~~ \Con([~ l \rightarrow rc ~\vert~ \\
     ~~~~~~~~~~~~~~~~ l \in internal(G^A.V), \\ 
     ~~~~~~~~~~~~~~~~ rc = append_{i \in \{1..n\}}(\CompilePred((t_i, PG^A_i, \Pref^A_i))) ~], \Gamma,f,G) \\
    \end{array} \]%

    \noindent
    By applying the definition of $\Con$ to the left-hand side, we get:

    \[ \begin{array}{l}
     ~~~~~ [~ l \rightarrow rc ~\vert~ \\
     ~~~~~~~~~~~~ l \in internal(G.V), \\ 
     ~~~~~~~~~~~~ rc = \Con(append_{i \in \{1..n\}}(\CompilePred((t_i, PG^A_i, \Pref^A_i))), \Gamma,f,G)  ~]\\
    \end{array} \]%

    \noindent
    Applying the definition of $\Con$ one more time:

    \[ \begin{array}{l}
     ~~~~~ [~ l \rightarrow rc ~\vert~ \\
     ~~~~~~~~~~~~ l \in internal(G.V), \\ 
     ~~~~~~~~~~~~ rc = append_{i \in \{1..n\}}\Con((\CompilePred((t_i, PG^A_i, \Pref^A_i)), \Gamma,f,G) ) ~]\\
    \end{array} \]%

    \noindent
    From the definition of list $\mathrm{append}$ and the given equality from Theorem 11 shown above, we obtain the right hand side.

    \[ \begin{array}{l}
     ~~~~~ [~ l \rightarrow rc ~\vert~ \\
     ~~~~~~~~~~~~ l \in internal(G.V), \\ 
     ~~~~~~~~~~~~ rc = append_{i \in \{1..n\}}(\CompilePred((t'_i, PG_i, \Pref_i))) ~] \\
    \end{array} \]%


  \end{proof}

\end{thm}


\end{document}