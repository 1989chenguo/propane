\documentclass[twocolumn, openany]{sig-alternate-10pt}
%\documentclass[twocolumn]{article}
%\documentclass[10pt]{sigalternate052015}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{xcolor}
\usepackage{url}
\usepackage{times}
\usepackage{xspace}
\usepackage{listings}
\usepackage{code}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\usepackage{tikz}
\usetikzlibrary{arrows,automata,positioning}
\let\proof\relax
\let\endproof\relax
\usepackage{amsthm}
\usepackage{subcaption}
\usepackage{balance}
\usepackage[ampersand]{easylist}
\usepackage{textcomp}
\usepackage{pifont}
\newcommand{\cmark}{\ding{51}}
\newcommand{\xmark}{\ding{55}}

\definecolor{princetonorange}{RGB}{255,143,0}
\definecolor{tmlblue}{RGB}{0,58,120}  % tmlblue == Toronto Maple Leafs Blue!

\newcommand{\todo}[1]{\textcolor{red}{[TODO: #1]}}
\newcommand{\ratul}[1]{\textcolor{blue}{[ratul: #1]}}
\newcommand{\ryan}[1]{\textcolor{green}{[ryan: #1]}}
\newcommand{\dpw}[1]{\textcolor{tmlblue}{[dpw: #1]}}
\newcommand{\todd}[1]{\textcolor{princetonorange}{[todd: #1]}}

\newcommand{\EG}{\emph{e.g.}}
\newcommand{\IE}{\emph{i.e.}}
\newcommand{\ETC}{\emph{etc.}}
\newcommand{\ETAL}{\emph{et al.}}

\newcommand{\sysname}{{\small \sf Methane}\xspace}
\newcommand{\sysnamesec}{{\sf Methane}\xspace}
\newcommand{\propane}{{\small \sf Propane}\xspace}

\newcommand{\para}[1]{\paragraph*{\textbf{#1}}}

\newcommand{\set}[1]{\ensuremath{\{ #1 \} }}
\newcommand{\abs}[1]{\ensuremath{ \lvert #1 \rvert }}

\newcommand{\CD}[1]{\texttt{\small #1}}  % code font
\newcommand{\KW}[1]{\texttt{\small\bfseries{#1}}}

\newcommand{\True}{\CD{true}}
\newcommand{\Define}{\KW{define}}
\newcommand{\Prefer}{\texttt{>>}}
\newcommand{\Path}{\texttt{=>}}
\newcommand{\Link}{\texttt{->}}
\newcommand{\Agg}{\KW{agg}}
\newcommand{\Any}{\KW{any}}
\newcommand{\None}{\KW{drop}}
\newcommand{\In}{\KW{in}}
\newcommand{\Out}{\KW{out}}
\newcommand{\AND}{\texttt{\&}}
\newcommand{\OR}{\texttt{|}}
\newcommand{\NOT}{\texttt{!}}
\newcommand{\Intersect}{\ensuremath{\cap}}
\newcommand{\Union}{\ensuremath{\cup}}

\newcommand{\Exit}{\KW{exit}}
\newcommand{\End}{\KW{end}}
\newcommand{\Start}{\KW{start}}
\newcommand{\Enter}{\KW{enter}}
\newcommand{\Eventually}{\KW{eventually}}
\newcommand{\Already}{\KW{already}}
\newcommand{\Internal}{\KW{internal}}
\newcommand{\Never}{\KW{never}}
\newcommand{\Always}{\KW{always}}
\newcommand{\Through}{\KW{through}}
\newcommand{\LinkKW}{\KW{link}}
\newcommand{\PathKW}{\KW{path}}
\newcommand{\Novalley}{\KW{novalley}}

\renewcommand{\path}[2]{ #1 \mapsto \ensuremath{#2} }

%% grammar
\newcommand{\BNFALT}{\;\;|\;\;}
\newcommand{\hdr}[2]{\flushleft \chdr{\hspace{5mm}#1}{#2}}
\newcommand{\chdr}[2]{\textbf{#1} {#2} \\ \centering}%

\newtheorem{thm}{Theorem}
\newtheorem{defn}{Definition}
\newtheorem{lem}[thm]{Lemma}
\newtheorem*{cor}{Corollary}


\begin{document}

\special{papersize=8.5in,11in}
\setlength{\pdfpageheight}{\paperheight}
\setlength{\pdfpagewidth}{\paperwidth}

\onecolumn

\appendix

\section{Definitions}

\subsection{Methane}

The full \sysname syntax as well as expansions from constraints into regular expressions are shown in Figure~\ref{fig:syntax}. The language includes constraints of the form $\CD{\Agg(pfx, \ensuremath{r_1 \rightarrow r_2})}$ that say that aggregation for summary prefix $\CD{pfx}$ will occur from any single location matching $\CD{\ensuremath{r_1}}$ to any location matching $\CD{\ensuremath{r_2}}$. For simplicity, we prove the substitution property for \sysname for the fragment without aggregation.


\begin{figure*}[h!]\small
  \begin{minipage}[t]{.45\linewidth}
  \hdr{Syntax}{}
  \vspace*{-1\baselineskip}
  %
  \[ \begin{array}{rclr}
    \hline%

     pol     &::=& p_1, \dots, p_n & \textit{policies} \\
     p       &::=& t \hspace{.3em} \Path \hspace{.3em} r_1 \Prefer \dots \Prefer r_m \BNFALT cc & \textit{constraints} \\
     pfx     &::=& d.d.d.d/[d..d] & \textit{prefix} \\
     t       &::=& \$x & \textit{template variable} \\
         &\BNFALT& pfx & \textit{prefix test} \\
     r       &::=& l & \textit{location} \\
         &\BNFALT& \emptyset & \textit{empty set} \\
         &\BNFALT& \In & \textit{internal loc} \\
         &\BNFALT& \Out & \textit{external loc} \\
         &\BNFALT& r_1 \cup r_2 & \textit{union} \\
         &\BNFALT& r_1 \cap r_2 & \textit{intersection} \\
         &\BNFALT& r_1 \cdot r_2 & \textit{concatenation} \\
         &\BNFALT& \NOT r & \textit{path negation} \\
         &\BNFALT& r^* & \textit{iteration} \\
     cc     &::=& agg(pfx, r_1 \rightarrow r_2)  & \textit{control constraints} \\
  \end{array} \]%

  \end{minipage}
  %
  ~~
  \vrule
  ~~
  %
  \begin{minipage}[t]{.5\linewidth}\small
  \hdr{Expansions}{}
  \vspace*{-1\baselineskip}
  %
  \[\begin{array}{rcl}
    \hline
    \Any               & = & \Sigma^* \\
    \None              & = & \emptyset \\
    \Internal          & = & \In^+ \\
    \Always(X)         & = & X^* \\
    \Never(X)          & = & (!X)^* \\
    \Through(X)        & = & \Sigma^* \cdot X \cdot \Sigma^* \\
    \End(X)            & = & \Sigma^* \cdot X \\
    \Start(X)          & = & X \cdot \Sigma^* \\
    \Enter(X)          & = & \Sigma^* \cdot \Out \cdot (X \cap \In) \cdot \Sigma^* ~ \cup \\
                       &   & \Sigma^* \cdot (X \cap \Out) \cdot \In \cdot \Sigma^* \\
    \Exit(X)           & = & \Sigma^* \cdot \In \cdot (X \cap \Out) \cdot \Sigma^* ~ \cup \\
                       &   & \Sigma^* \cdot (X \cap \In) \cdot \Out \cdot \Sigma^* \\
    \LinkKW(X,Y)       & = & \Sigma^* \cdot X \cdot Y \cdot \Sigma^* \\
    \PathKW(\vec{X})   & = & \Sigma^* \cdot X_1 \dots X_n \cdot \Sigma^* \\
    \Novalley(\vec{X}) & = & \NOT\PathKW(X_2,X_1,X_2) ~ \cap \dots \cap \\
                       &   & \NOT\PathKW(X_n,X_{n-1},X_n) \\
  \end{array} \]%

  \end{minipage}%

  \hrulefill%
  \vspace{1em}

  \caption{Methane syntax and expansions.}
  \label{fig:syntax}
  %\vspace{-1em}
\end{figure*}%



\subsection{BGP Configuration}

\para{Syntax}


\newcommand{\Con}{\text{con}}
\newcommand{\Pfx}{\mathit{pfx}}%

\vspace{2em}
\begin{figure*}[t!]\small%
  
  \hrulefill%

  \vspace{1em}%
  \begin{minipage}[t]{.46\linewidth}
  \hdr{ABGP Syntax}{}
  \vspace*{-1\baselineskip}
  %
  \[ \begin{array}{rclr}
     d    &   & & \textit{integer} \\
     c    &   & & \textit{community} \\
     t    &::=& \$x \BNFALT d.d.d.d/[d..d] & \textit{predicate} \\
     ns   &::=& \{ l_1, ~\dots,~ l_k \} & \textit{peers} \\
     ma   &::=& d : ({ns}_1, c_1) \rightarrow ({ns}_2, c_2) & \textit{match action} \\
     pc   &::=& ma_1, \dots, ma_k & \textit{prefix config} \\
     rc   &::=& t_1 \rightarrow {pc}_1, ~\dots,~ t_k \rightarrow {pc}_k & \textit{router config} \\
     abgp &::=& l_1 \rightarrow {rc}_1, ~\dots,~ l_k \rightarrow {rc}_k & \textit{abgp policy} \\%
  \end{array} \]%%

  \end{minipage}
  %
  %
  \begin{minipage}[t]{.5\linewidth}
  \hdr{Compilation}{}
  \vspace*{-1\baselineskip}
  %
  \[ \begin{array}{l}
     \text{compile}_\text{ABGP}( (t_1,PG_1,ord_1), \dots, (t_k,PG_k,ord_k), G ) = \\
     ~~~~~ [~ l \rightarrow rc ~\vert~ \\
     ~~~~~~~~~ l \in internal(G.V), \\
     ~~~~~~~~~ rc = \mathit{append}_i~  \\
     ~~~~~~~~~~~~~~~ [~ t_i \rightarrow ma_1, \dots, ma_k ~\vert~ \\
     ~~~~~~~~~~~~~~~~~~~~~ m = (l,q_m) \in PG_i, \\
     ~~~~~~~~~~~~~~~~~~~~~ pin = \text{adjIn}(PG_i,m), \\
     ~~~~~~~~~~~~~~~~~~~~~ (in,q_n) = \{ (bs,q_n) ~\vert~ (\_,q_n) \in pin, bs=\{b ~\vert~ (b,q_n) \in pin \} \} \\
     ~~~~~~~~~~~~~~~~~~~~~ out = \{ c ~\vert~ (c,\_) \in \text{adjOut}(PG_i,m) \} \\
     ~~~~~~~~~~~~~~~~~~~~~ ma_j = ord_i(m) : (in,q_n) \rightarrow (out,q_m) ~] ~] \\
     \\
     \text{compile}( p_1, \dots, p_k, G) = \\
     ~~~~~~ \text{compile}_\text{ABGP}(\text{compile}_\text{PG}(p_1,G), \dots, \text{compile}_\text{PG}(p_k,G), G) \\
  \end{array} \]%
  \end{minipage}%

  \vspace{1em}
  \vspace{1em}%

  \vspace*{-2\baselineskip}
  \begin{minipage}[t]{1.01\linewidth}
  \hdr{Policy Concretization}{}
  \vspace*{-2\baselineskip}
  %
  \[ \begin{array}{lcl}
     \\
     \Con(\emptyset, \Gamma, f)      &=& \emptyset \\
     \Con(l, \Gamma, f)              &=& \Sigma_i ~ f_i^{-1}(l) \\
     \Con(r_1 \cup r_2, \Gamma, f)   &=& \Con(r_1,\Gamma,f) \cup \Con(r_2,\Gamma,f) \\
     \Con(r_1 \cap r_2, \Gamma, f)   &=& \Con(r_1,\Gamma,f) \cap \Con(r_2,\Gamma,f) \\
     \Con(!r, \Gamma, f)             &=& !\Con(r,\Gamma,f) \\
     \Con(r^*, \Gamma, f)            &=& \Con(r,\Gamma,f)^* \\%
     \Con(\Pfx ~\Path~ r_1, ~\dots~, r_k, \Gamma, f) &=&
          \Pfx ~\Path~ \Con(r_1,\Gamma,f), ~\dots~, \Con(r_k,\Gamma,f)  \\%
     \Con(\$x ~\Path~ r_1, ~\dots~, r_k, \Gamma, f) &=&%
         [~ \Pfx ~\Path~ \Con(r_1,\Gamma,f) \cap \text{end}(l), ~\dots~, \\%
         & & ~~~~~~~~~~~~~~~ \Con(r_k,\Gamma,f) \cap \text{end}(l) ~\vert~ (\Pfx,l) \in \Gamma(x) ~]  \\%
     \Con(p_1, \dots, p_n, \Gamma,f) &=& \Con(p_1, \Gamma,f), \dots, \Con(p_n, \Gamma,f) \\%

  \end{array} \]%
  \end{minipage}%

  \vspace{1em}
  \vspace{1em}%

  \begin{minipage}[t]{\linewidth}
  \hdr{ABGP Concretization}{}
  \vspace*{-2\baselineskip}
  %
  \[ \begin{array}{lcl}
     \\
     \Con(l_1 \rightarrow {rc}_1, ~\dots,~ l_k \rightarrow {rc}_k,\Gamma,f,G)
        & = &
        \mathit{append}_i~ [~ \ell \rightarrow con(rc_i,\ell,\Gamma,f,G)  ~\vert~ \ell \in f^{-1}(l_i) ~]
        \\
     \Con(t_1 \rightarrow {pc}_1, ~\dots,~ t_k \rightarrow {pc}_k,\ell,\Gamma,f,G)
        & = &
        \Con(t_1 \rightarrow {pc}_1,\ell,\Gamma,f,G), \dots, \Con(t_k \rightarrow {pc}_k,\ell,\Gamma,f,G)
        \\
     \Con(\Pfx \rightarrow {pc},\ell,\Gamma,f,G)
        & = &
        \Pfx \rightarrow \Con(pc,\text{true},\ell,\Gamma,f,G)
        \\
     \Con(\$x \rightarrow {pc},\ell,\Gamma,f,G)
        & = &
        [~ \Pfx \rightarrow \Con(pc, l=\ell, \ell,\Gamma,f,G) ~\vert~ (\Pfx, l) \in \Gamma(x) ~]
        \\
     \Con(ma_1, \dots, ma_k,o,\ell,\Gamma,f,G)
        & = &
        \Con(ma_1,o,\ell,\Gamma,f,G), \dots, \Con(ma_k,o,\ell,\Gamma,f,G)
        \\%
     \Con(n_1 : ({ns}_1, n_2) \rightarrow ({ns}_2, n_3),o,\ell,\Gamma,f,G)
        & = & \textbf{if}~ ns_1 = \{\text{start}\} ~\text{and}~ o = \text{false} ~\textbf{then}~ \bullet \\
        &   & \textbf{else}~ n_1 : ( \Con({ns}_1,\ell,\Gamma,f,G), n_2) \rightarrow (\Con({ns}_2,\ell,\Gamma,f,G),n_3)%

        \\
     \Con(\{ l_1, ~\dots,~ l_k \}, \ell, \Gamma,f,G)
        & = &
        \bigcup_i ~ \{ x ~\vert~ x \in f^{-1}(l_i),~ (x,\ell) \in G.E \}
        \\
  \end{array} \]%
  \end{minipage}%

  \vspace{1em}
  \hrulefill%
  \vspace{1em}%

  \caption{ABGP syntax, compilation from product graphs, policy concretization, and ABGP concretization.}
  \label{fig:concretization}
\end{figure*}%


\para{ABGP language}

We introduct a simple language for BGP configurations called ABGP. Figure~\ref{fig:concretization} shows the syntax for an ABGP policy. An ABGP policy maps topology locations $l$ to router configurations $rc$. Each router configuration $rc$ is a sequence of predicates $t$ and their corresponding configuration $pc$. A prefix configuration $pc$ is a sequence of match actions. Each match action $ma$ consists of a preference value $d$, followed by a set of imports from neighbors $ns_1$ and community value (\IE, state of the product graph) $c_1$ expected from those neighbors, as well as export neighbors $ns_2$ and the community value $c_2$ to attach before sending to those neighbors.%


\para{Compilation}

Figure~\ref{fig:concretization} defines compilation from a \sysname policy to an ABGP policy. It starts by compiling ($\text{compile}_\text{PG}$) separately each constraint of the form $p_i = (t_i ~\Path~ r_{i1} ~\Prefer~ r_{ik})$ to a product graph $PG = (G', s, P)$. The function $\text{compile}_\text{PG}$ returns the test $t_i$, product graph $PG_i$, and the preference ordering $ord_i$.
%
The function $\text{compile}_\text{ABGP}$ then takes a sequence of tuples $(t_i, PG_i, ord_i)$ and returns an ABGP policy. For each internal router, it looks at each set of neighbor with the same community state $q_n$ and matches any of those neighbors with the preference provided by the ordering $ord$. It then exports this advertisement to each adjacent peer along an outgoing edge and adds the community value for the current state $q_m$.%

We assume a particular router $l$ appears at most once in any abgp specification.
We build configs using list-comprehension notation. For instance,
$[~ l \rightarrow rc ~\vert~ l \in V \wedge p(l,rc) ~]$ denotes the abgp policy
%
\[ \begin{array}{c}
  l_1 \rightarrow rc_{1},... \\
  ...           \\
  l_k \rightarrow rc_{k},... \\
\end{array} \]

where $l_1, ..., l_k$ are the nodes in the topology
and each $rc_{i}$ satisfies $p(l_i,rc_{i})$. We also use the $\mathit{append}$ operator to denote sequence concatenation.%


\subsection{Concretization}

Concretization for a \sysname policy takes as input, the policy and a context
$\Gamma : Var \rightarrow 2^{Prefix \times V}$,
which maps from a template prefix to a set of pairs of a concrete prefix and a concrete location that "owns" the prefix.
%
For each regular expression $r$, we replace each abstract location with the sum over its corresponding concrete locations under the inverse homomorphism $f^{-1}$. For each template variable, we replace it with a new entry for each of its corresponding concrete prefixes under the supplied mapping $\Gamma$. We also intersect the resulting concretized regular expression with $\text{end}(l)$ to capture the fact that this traffic is owned by the concrete location $l$.%

We also define concretization over the ABGP policy in a similar manner. We replace each abstract router configuration $l \rightarrow rc$ a new entry for each concrete location $\ell \in f^{-1}(l)$. The concrete location $\ell$ is passed as a parameter to $con$ to remember the current router.
%
To concretize a prefix policy with a template ($\$x \rightarrow pc$) we replace it with a sequence of policies, one for each prefix in context ($(pfx,l) \in \Gamma(x)$). Match action statements where the set of import neighbors is the singleton set containing the product graph start node $\{ start \}$ and we are not currently at looking at the router configuration for the location specified in the context $l$, then we drop the match action. This is denoted with the $\bullet$ symbol. Finally, to concretize a set of neighbors, we again use $f^{-1}$ to find the set of concrete neighbors under the inverse homomorphism, but then restrict it to those that are actually connected in the underlying concrete topology with $G.E$.



\subsection{Abstraction}

A network topology is a graph $G$ = ($V, E$), where $V$ is a set of vertices and $E \colon V \times V$ a set of directed edges. A role-based abstraction is a graph homomorphism from $G$ to an abstract graph $G^A$ = ($V^A$,$E^A$). A graph homorphism $f : G \rightarrow G^A$ is a function that maps each node in the concrete graph to a node in the abstract graph such that, whenever $(u,v) \in E$, then $(f(u),f(v)) \in E^A$. We write $f^{-1}(v)$ to denote the set of concrete nodes mapping to the abstract node $v$. Given a path as a sequence of locations $p = l_1, \dots, l_k$ we define $f(p) = f(l_1), \dots, f(l_k)$.


\subsection{Notation}

Throughout the remainder of the appendix, we use the following convention for metavariables:

\[ \begin{array}{ll}
  \text{Product Graph nodes} & n,m,o \\
  \text{Topology locations} & a,b,c \\
  \text{Automata states} & q_i \\
  \text{Topologies} & G, G^A \\
  \text{Product Graph} & PG, PG^A \\
  \text{Automata} & M, M^A \\
\end{array} \]

We use capital letters for abstract topology/product graph nodes and we use lower case letters for concrete topology nodes. By default, product graph nodes with different subscripts refer to nodes that share the same topology location (\IE, $n_1 \approx n_2$). A superscript $G^A$ refers to the abstract version (in this case of the topology), while the non-superscripted value refers to the concrete version.


\section{Substitution Theorem}

The goal of this section is to prove that the concretization and compilation functions commute: 
$$con(compile(pol,G^A),\Gamma,f,G) = compile(con(pol,\Gamma,f), G)$$ 
That is -- we can perform compilation directly over the abstraction and only substitute for the concrete values on after compilation is complete. Note that the theorem states that the resulting ABGP policies are actually syntactically equivalent and not semantically equivalent. First we need a few helper theorems about compilation.

\subsection{Automata}

\newcommand{\Lang}{\ensuremath{\mathcal{L}}}

We compile regular expressions to automata. As a side condition, we ensure that there are no transitions from some state $q$ to the initial state: $\sigma(q,x) = q_0$. This is done by creating another state $q_0'$ with the same transition function as $q_0$ and all other states transition to $q_0'$ instead of $q_0$.

\vspace{1em}
\begin{lem}
  For any $\Gamma$, $f$, and $r$, path $p \in \Lang(con(r,\Gamma,f)) \iff f(p) \in \Lang(r)$.
\end{lem}
\begin{proof}
By induction on the structure of $r$

\emph{Case $\emptyset$:}
  \[ \begin{array}{lll}
    p \in \Lang(con(\emptyset,\Gamma,f)) &\iff& f(p) \in \Lang(\emptyset) \\
    p \in \emptyset &\iff& f(p) \in \emptyset \\
  \end{array} \]

\emph{Case $l$:}
  \[ \begin{array}{lll}
    p \in \Lang(con(l,\Gamma,f)) &\iff& f(p) \in \Lang(l) \\
    p \in \Lang(\Sigma_i ~ f_i^{-1}(l)) &\iff& f(p) \in \Lang(l) \\
    p \in \bigcup_i f_i^{-1}(l) &\iff& f(p) \in \Lang(l) \\
    p \in f^{-1}(l) &\iff& f(p) \in \{ l \} \\
    p \in f^{-1}(l) &\iff& f(p) = l \\
    \text{by homomorphism} & & \\
  \end{array} \]

\emph{Case $r_1 \cup r_2$:}
  \[ \begin{array}{lll}
    p \in \Lang(con(r_1 \cup r_1,\Gamma,f)) &\iff& f(p) \in \Lang(r_1 \cup r_2) \\
    p \in \Lang(con(r_1,\Gamma,f) \cup con(r_1,\Gamma,f)) &\iff& f(p) \in \Lang(r_1 \cup r_2) \\
    p \in \Lang(con(r_1,\Gamma,f)) \cup \Lang(con(r_1,\Gamma,f)) &\iff& f(p) \in \Lang(r_1 \cup r_2) \\
    p \in \Lang(con(r_1,\Gamma,f)) \vee p \in \Lang(con(r_1,\Gamma,f)) 
       &\iff& 
       f(p) \in \Lang(r_1) \vee f(p) \in \Lang(r_2) \\
    \text{by cases + IH} & & \\
  \end{array} \]

\emph{Case $r_1 \cap r_2$:} 
  \[ \begin{array}{c}
    \text{symmetric to } \cup \text{ case with } \wedge \text{ instead of } \vee
  \end{array} \]

\emph{Case $!r$:}
  \[ \begin{array}{lll}
    p \in \Lang(con(!r,\Gamma,f)) &\iff& f(p) \in \Lang(!r) \\
    p \in \Lang(!con(r,\Gamma,f)) &\iff& f(p) \in \Lang(!r) \\
    p \in \Sigma^* - \Lang(con(r,\Gamma,f)) &\iff& f(p) \in \Sigma^* - \Lang(r) \\
    \text{by IH} & & \\
  \end{array} \]

\emph{Case $r^*$:}
  \[ \begin{array}{lll}
    p \in \Lang(con(r^*,\Gamma,f)) &\iff& f(p) \in \Lang(r^*) \\
    p \in \Lang(con(r,\Gamma,f)^*) &\iff& f(p) \in \Lang(r^*) \\
    p \in \bigcup_{i \in \mathbb{N}} \Lang(con(r,\Gamma,f))^i &\iff& f(p) \in \bigcup_{i \in \mathbb{N}} \in \Lang(r)^i \\
    \text{Follows from IH and definition of } \Lang(r)^i & & \\
  \end{array} \]

\end{proof}



%\begin{defn}
%If $r$ complies to state machine $M^A$, then we compile the policy $con(r)$ in the following way:%

%  \[ \begin{array}{ll}
%    1. & \sigma^A(q,f(l)) = q' \iff \sigma(q,l) = q' \\
%    2. & q \in F^A \iff q \in F \\
%  \end{array} \]%

%That is, we construct a new automata over the same states and final states, but with a different transition function $\sigma$. This ensures that there is a bisimulation between the two state machines.%

%\end{defn}%
%

%\begin{lem}
%  $M^A$ matches $f(p)$ $\iff$ $M$ matches $p$.
%\end{lem}%

%\begin{proof}
%  Suppose $M^A$ matches $f(p) = A_1, \dots, A_k$, then there exists a trace through $M^A$ of the form:%

%  $$q_0, q_1, \dots, q_{k+1}$$%

%  where $\sigma^A(q_i, A_i) = q_{i+1}$ and $q_{k+1} \in F^A$. We must show that $M$ matches $p = a_1, \dots, a_k$. %

%  From the construction of the automaton, we know that $\sigma(q_i, a_i) = q_{i+1}$ and $q_{k+1} \in F \iff q_{k+1} \in F^A$. Therefore, the trace $q_0, q_1, \dots, q_{k+1}$ is accepted by $M$. 
%  %
%  The same proof is symmetric for the other direction.
%\end{proof}%
%

%\begin{lem}
%  $M$ matches $p$ $\iff$ $p \in \Lang(con(r))$
%  \begin{proof}
%    \[ \begin{array}{lllr}
%      M ~\text{matches}~ p &\iff& M^A ~\text{matches}~ f(p) & \textit{previous lemma} \\
%                         &\iff& f(p) \in \Lang(r) & \textit{automaton construction} \\
%                         &\iff& p \in \Lang(con(r)) & \textit{first lemma} \\
%    \end{array} \]%

%  \end{proof}
%\end{lem}


\begin{lem}
  Consider the PG created from compiling the constraint $p = (t ~\Path~ r_1 ~\Prefer~,\dots, ~\Prefer~ r_k)$ with state machine $M^A_i$ for each $r_i$. We know that, for each $(pfx ~\Path~ r'_1 ~\Prefer~,\dots, ~\Prefer~ r'_k) \in con(p,\Gamma,f)$ where $r'_i$ is of the form $r \cap \text{end}(L)$ we can constuct state machine $M_i$ for $r'_i$ over the same states in the following way:
    
    \[ \begin{array}{lll}
      1. & \sigma(q_0,l) = q' \iff \sigma^A(q,f(l)) = q' & \textbf{for each}~~ l \in L \\
      2. & \sigma(q,l) = q' \iff \sigma^A(q,f(l)) = q' & \textbf{for each}~~ l \in \Sigma \\
      3. & q \in F \iff q \in F^A & \\
    \end{array} \]

  then $M_i$ matches $p$ $\iff$ $p \in \Lang(r_i')$
  
  \vspace{1em}
  \begin{proof} by cases on $t$

    \vspace{1em}

    \textbf{Case} $(\$x ~\Path~ r_1 ~\Prefer~,\dots, ~\Prefer~ r_k)$

    \[ \begin{array}{lcl}
      con(p) &=& pfx_1 ~\Path~ con(r_1,\Gamma,f) \cap \text{end}(l_1), ~\Prefer~ \dots ~\Prefer~ con(r_k,\Gamma,f) \cap \text{end}(l_1)  \\
             & & \dots, \\
             & & pfx_n ~\Path~ con(r_1,\Gamma,f) \cap \text{end}(l_n), ~\Prefer~ \dots ~\Prefer~ con(r_k,\Gamma,f) \cap \text{end}(l_n)
    \end{array} \]

    Case ($\Rightarrow$)

    Assume $M_i$ matches $p$. Then this means that $M^A_i$ matches $f(p)$. If we have a trace of string of the form $ p = x_1 \cdot \dots \cdot x_n$, then $f(p) = f(x_1) \cdot \dots \cdot f(x_n)$. For each transition $\sigma(q,l) = q'$ in the concrete automaton, we have transition $\sigma(q,f(l)) = q'$ in the abstract automaton, and they have the same final states, so this trace is accepting for $M^A_i$. Because $M^A_i$ matches $f(p)$, this means that $f(p) \in \Lang(r_i)$. From our above lemma, this means that $p \in \Lang(con(r_i,\Gamma,f))$. We also know that, since $L = \{ l_i \}$, the first transition $\sigma(q_0,l_i)$ is the only transition allowed from the initial state for $M_i$. So this means that $p \in \Lang(\text{end}(l_i))$. Since we know that $p \in \Lang(con(r_i,\Gamma,f))$ and $p \in \Lang(\text{end}(l_i))$, we know that $p \in \Lang(con(r_i,\Gamma,f) \cap \text{end}(l_i))$ and thus $p \in \Lang(r'_i)$.

    \vspace{1em}
    Case ($\Leftarrow$)

    Assume $p \in \Lang(r'_i)$. This means that $p \in \Lang(con(r_i) \cap \text{end}(l_i))$. In turn, this means that $p \in \Lang(con(r_i))$ and $p \in \Lang(\text{end}(l_i))$. From the above lemma, we know that $f(p) \in \Lang(r_i)$, which means that $M^A_i$ matches $f(p)$. 
    %
    Consider any string of the form $p = l_i \cdot x_2 \cdot \dots \cdot x_n$ such that $p \in \Lang(con(r_i) \cap \text{end}(l_i))$. Clearly there is a transition defined for $\sigma(q_0,l_i) = q_1$.
    %
    This means that $M^A_i$ matches $f(l_i) \cdot f(x_2) \cdot \dots \cdot f(x_n)$
    %
    For each transition $\sigma^A(q,f(x_i)) = q'$, we have $\sigma(q,x_i) = q'$ in $M_i$.
    %
    Thus the string $l_i \cdot x_2 \cdot \dots \cdot x_n$ is accepted along the same path of automaton states.

  \vspace{1em}

  \textbf{Case} $(pfx ~\Path~ r_1 ~\Prefer~,\dots, ~\Prefer~ r_k)$

    \[ \begin{array}{lcl}
      con(p,\Gamma,f) &=& pfx_1 ~\Path~ con(r_1,\Gamma,f) \cap \text{end}(\Sigma^*), ~\Prefer~ \dots ~\Prefer~ con(r_k,\Gamma,f) \cap \text{end}(\Sigma^*) \\
    \end{array} \]

    First we observe that: $M^A_i$ matches $f(p)$ $\iff$ $M_i$ matches $p$.
    %
    Suppose $M^A_i$ matches $f(p) = A_1, \dots, A_k$, then there exists a trace through $M^A_i$ of the form:%
    %
    $q_0, q_1, \dots, q_{k+1}$
    %
    where $\sigma^A_i(q_i, A_i) = q_{i+1}$ and $q_{k+1} \in F^A$. We must show that $M_i$ matches $p = a_1, \dots, a_k$. %
    %
    From the construction of the automaton, we know that $\sigma_i(q_i, a_i) = q_{i+1}$ and $q_{k+1} \in F \iff q_{k+1} \in F^A_i$. Therefore, the trace $q_0, q_1, \dots, q_{k+1}$ is accepted by $M_i$. 
    %
    The same proof is symmetric for the other direction. It follows that:

    \[ \begin{array}{lll}
      M ~\text{matches}~ p &\iff& M^A ~\text{matches}~ f(p) \\
                         &\iff& f(p) \in \Lang(r) \\
                         &\iff& p \in \Lang(con(r,\Gamma,f)) \\
    \end{array} \]%

  \end{proof}

\end{lem}

\vspace{1em}
\subsection{Product Graph}

\begin{defn}
  Because compilation guarantees that the automata states are the same under the concretization function, we can lift the graph homomorphism $f$ to a new homomorphism $f_{pg}$ over the product graph in the following way:
  \[ \begin{array}{rcl}
    f_{pg}( s ) & = & s^A  \\
    f_{pg}( (l,q_1,\ldots,q_n) ) & = & (f(l),q_1,\ldots,q_n) \\
  \end{array} \]
\end{defn}

\vspace{1em}
\begin{lem}
  If $f_{pg}(n) = N$, then $P(n) = P^A(N)$.

  \begin{proof}
    Assume $n = (a,q_1,\dots,q_k)$. We know that $f_{pg}(n) = (f(a),q_1,\dots,q_k)$. 
    We also know that $q_i \in F_i \iff q_i \in F^A_i$. 
    By the definition of the preference function $P$, then $P(n) = P^A(N)$.
  \end{proof}

\end{lem}

\vspace{1em}
\begin{lem}
  If, for abstract product graph $PG$, if we have the following:

  \[ \begin{array}{ll}
    1. & (a,b) ~\text{is an edge in the concrete topology} \\
    2. & \tilde{m} = a \\
    3. & f_{pg}(m) = M \\
    4. & (M,N) ~ \text{is an edge in the product graph}~ PG^A \\
    5. & \tilde{N} = f(b) \\
  \end{array} \]

  then there exists a node $n$ in the concrete product graph $PG$ where:

  \[ \begin{array}{ll}
    1. & \tilde{n} = b \\
    2. & f_{pg}(n) = N \\
    3. & (m,n) ~ \text{is an edge in the product graph}~ PG \\
  \end{array} \]

  \begin{proof}

    suppose that $m = (a, q_1, \dots, q_k)$. Then we know that $M = (f(a), q_1, \dots, q_k)$. Also suppose there is some $b$ such that $N = (f(b), s_1, \dots, s_k)$ since $f^{-1}(N) \neq \emptyset$. This means that, since $(a,b)$ is an edge in the concrete topology, $(f(a),f(b))$ is an edge in the abstract topology. Also we know that $\tilde{N} = f(b)$.

    Let us take the node $n = (b, s_1, \dots, s_k)$. 

    \begin{easylist}
      & Clearly $\tilde{n} = b$
      & Clearly $f_{pg}(n) = (f(b), s_1, \dots, s_k) = N$
      & For each regular expression $\sigma^A(q_i, f(b)) = s_i$. This means that for each regular expression, $\sigma(q_i, b) = s_i$ if $q_i \neq q_{0_i}$. We know that $q_i \neq q_{0_i}$ due to the side condition for automaton construction. It follows that $(m,n)$ is an edge in the product graph by definition.
    \end{easylist}

  \end{proof}
\end{lem}

\begin{lem}
  $m \leq m'$ in the concrete product graph iff $f_{pg}(m) \leq f_{pg}(m')$ in the abstract product graph under the lifted graph homomorphism $f_{pg}$.

  \begin{proof}
    $(\Leftarrow)$

    Suppose we have a simulation relation from the subgraphs rooted at nodes $M$ and $M'$ with $M' \geq_{rank} M$ in the abstract product graph. Assume that $\tilde{M} = f(a)$ and $\tilde{N} = f(b)$. For each neighbor $N'$, if we can make a move from $M'$:

    $$M' \overset{\tilde{N'}}{\rightarrow} N'$$

    then we also make a similar move for $M$ for some $N$ where $N \approx N'$ and $N' \geq_{rank} N$:

    $$M \overset{\tilde{N}}{\rightarrow} N$$

    We must show that the same relation holds for $m$ and $m'$. 

    Now assume $m'$ has a neighbor $n'$ where $\tilde{m} = a$ and $\tilde{n} = b$. Then clearly $(a,b)$ is a valid topology edge since it is a transition in the product graph. We now apply the previous lemma with the following facts:

    \[ \begin{array}{ll}
      1. & (a,b) ~\text{is a topology edge} \\
      2. & \tilde{m} = a \\
      3. & f_{pg}(m) = M \\
      4. & (M,N) ~\text{is an edge in}~ PG^A \\
      5. & \tilde{N} = f(b) \\
    \end{array} \]

    This lets us conclude that there exists a node $n'$ such that:

    \[ \begin{array}{ll}
      1. & \tilde{n} = b \\
      2. & f_{pg}(n) = N \\
      3. & (m,n) ~\text{is an edge in}~ PG \\
      4. & P(n) = P(N) \\
    \end{array} \] 

    Thus if we have $m' \overset{b}{\rightarrow} n'$, then we also have $m \overset{b}{\rightarrow} n$. The previous lemma can also be used to show that $P(n') = P(N')$ in a symmetric fashion, so we are guaranteed that $n' \geq_{rank} n$ from the fact that $N' \geq_{rank} N$.

  \end{proof}

  \begin{proof}
    $(\Rightarrow)$

    This is the simpler case. We assume we have $m' \overset{b}{\rightarrow} n'$ implies $m \overset{b}{\rightarrow} n$.
    Simply take $N = f_{pg}(n)$ and $N' = f_{pg}(n')$. If we know that $M' \overset{b}{\rightarrow} N'$ then we already know that $M \overset{b}{\rightarrow} N$ from the homomorphism. All that's required is to show that $N' \geq_{rank} N$. This follows trivially from the fact that $P(n) = P(N)$ and $P(n') = P(N')$.
  \end{proof}

\end{lem}

\vspace{1em}
\begin{defn}
  Assign $ord(m) = ord^A(f_{pg}(m))$ as increasing integers according to the total ordering for $\leq$.
  Clearly $ord(m) \leq ord(m') \iff m \leq m'$ and $ord(f_{pg}(m)) \leq ord(f_{pg}(m')) \iff f_{pg}(m) \leq f_{pg}(m')$
\end{defn}

\vspace{1em}
\begin{defn}
  The previous theorem tells us that the total ordering between node preferences is preserved under the lifted graph homomorphism $f_{pg}$. 
  We use this fact to define an ordering ($ord : V \rightarrow \mathbb{N}$) that maps product graph nodes to numbers reflecting the total ordering such that $ord(m) = ord(f(m))$ for all product graph nodes $m$.
\end{defn} 


\vspace{1em}
\subsection{Substitution}


\begin{lem}

  For concrete ($PG$) and abstract ($PG^A$) product graphs related by $f_{pg}$

  \[ \begin{array}{l}
     ~~~~~~~~~ [~ pfx \rightarrow ma_1, \dots, ma_k ~\vert~ \\
     ~~~~~~~~~~~~~~~~~~ M = (l,q_M) \in PG^A, \\
     ~~~~~~~~~~~~~~~~~~ I = \text{adjIn}(PG^A,M), \\
     ~~~~~~~~~~~~~~~~~~ (in,q_N) \in \{(\{b\in f^{-1}(B), (b,\ell) \in G.E, B \in BS\},q_N) ~\vert~ (\_,q_N) \in I, BS=\{B~\vert~ (B,q_N) \in I \} \}) \\
     ~~~~~~~~~~~~~~~~~~ out = \{ c \in f^{-1}(C), (c,\ell) \in G.E, (C,\_) \in \text{adjOut}(PG^A,M) \} \\
     ~~~~~~~~~~~~~~~~~~ ma_h = ord^A(M) : (in,q_N) \rightarrow (out,q_M) ~] \\
  \end{array} \]%

  Is equivalent to

  \[ \begin{array}{l}
     ~~~~~~~~~ [~ pfx \rightarrow ma_1, \dots, ma_k ~\vert~ \\
     ~~~~~~~~~~~~~~~~~~ m = (l,q_M) \in PG, \\
     ~~~~~~~~~~~~~~~~~~ I = \text{adjIn}(PG,m), \\
     ~~~~~~~~~~~~~~~~~~ (in,q_N) = \{ (bs,q_N) ~\vert~ (\_,q_N) \in I, bs=\{ b ~\vert~ (b,q_N) \in I\} \}) \\
     ~~~~~~~~~~~~~~~~~~ out = \{ c ~\vert~ (c,\_) \in \text{adjOut}(PG,m) \} \\
     ~~~~~~~~~~~~~~~~~~ ma_h = ord^A(f_{pg}(m)) : (in,q_N) \rightarrow (out,q_M) ~] \\
  \end{array} \]%

  \begin{proof}
    For each $M$ there exists at least one $m$ such that $f_{pg}(m) = M$. Note that $f_{pg}$ overapproximates the connectivity of the product graph, by virtue of being a graph homomorphism. For each concrete node $n$ such that $n = (b,q_n) \in adjIn(PG,m)$ we know that if $f_{pg}(n) = N$ where $N = (f(b),q_N)$, then $N \in adjIn(PG^A,M)$ and $q_n = q_N$ from the homomorphism. Thus by taking $\bigcup f^{-1}(f(b))$, for each such $f(b)$ for node $N$ that shares the same state $q_N$, we get a superset of the locations from the concrete graph. However, by restricting those locations to only those that appear in the topology $(b,\ell)$, we get exactly the set that appears in the concrete product graph. This is because we know $q_n \rightarrow q_m$ from the abstract product graph is a valid transition and the topology edge exists.
  \end{proof}

\end{lem}


\vspace{2em}
\begin{thm}
  For any $\Gamma$, $f$, $G$ such that $\Gamma$ is well-formed with respect to $G$,
  $$con(compile(pol),\Gamma,f,G) = compile(con(pol,\Gamma,f))$$

  \begin{proof} \text{ }

    Suppose that $pol = p_1, \dots, p_n$. Each $p_i$ has the form $(t_i ~\Path~ r_{i1} ~\Prefer~,\dots, ~\Prefer~ r_{ik})$. Then by evaulating:

    \[ \begin{array}{lcl}
      con(pol,\Gamma,f) & = & con(p_1,\dots,p_n,\Gamma,f) \\
                        & = & con(p_1,\Gamma,f), \dots, con(p_n,\Gamma,f) \\
                        & = & con(t_1 ~\Path~ r_{11} ~\Prefer~,\dots, ~\Prefer~ r_{1k},\Gamma,f), \\
                        &   & \dots, \\
                        &   & con(t_n ~\Path~ r_{n1} ~\Prefer~,\dots, ~\Prefer~ r_{nk},\Gamma,f) \\
    \end{array} \]

    For each test $t_i$, if $t_i = pfx$, then we get 

    \[ \begin{array}{ll}
          & con({pfx}_{i1} ~\Path~ r_{i1} ~\Prefer~,\dots, ~\Prefer~ r_{ik},\Gamma,f) \\
        = & {pfx}_{i1} ~\Path~ con(r_{i1},\Gamma,f) ~\Prefer~,\dots, ~\Prefer~ con(r_{ik},\Gamma,f) \\
    \end{array} \]

    For each test $t_i$, if $t_i = \$x$, then we get

    \[ \begin{array}{lcl}
        con(\$x_{i} ~\Path~ r_{i1} ~\Prefer~,\dots, ~\Prefer~ r_{ik},\Gamma,f) 
            & = & {pfx}_{i1} ~\Path~ con(r_{i1},\Gamma,f) \cap \text{end}(l_{i1}) ~\Prefer~,\dots, ~\Prefer~ con(r_{ik},\Gamma,f) \cap \text{end}(l_{i1}), \\
            &   & \dots, \\ 
            &   & {pfx}_{ij} ~\Path~ con(r_{i1},\Gamma,f) \cap \text{end}(l_{ij}) ~\Prefer~,\dots, ~\Prefer~ con(r_{ik},\Gamma,f) \cap \text{end}(l_{ij}), \\
            &   & \\
            &   & \text{for each } (pfx_{ij}, l_{ij}) \in \Gamma(x) \\
    \end{array} \]

    Next we compute $compile(con(pol,\Gamma,f))$:

    \[ \begin{array}{ll}
        & compile(con(pol,\Gamma,f))  \\
                          & \\
                         =& compile_{ABGP}( \\
                          &  ~~~~ compile_{PG}(pfx_{11} ~\Path~ r'_{111} ~\Prefer~,\dots, ~\Prefer~ r'_{11k} ), \\
                          &  ~~~~ \dots, \\
                          &  ~~~~ compile_{PG}(pfx_{1j} ~\Path~ r'_{1j1} ~\Prefer~,\dots, ~\Prefer~ r'_{1jk} ), \\
                          &  ~~~~ \dots, \\
                          &  ~~~~ compile_{PG}(pfx_{i1} ~\Path~ r'_{i11} ~\Prefer~,\dots, ~\Prefer~ r'_{i1k} ), \\
                          &  ~~~~ \dots, \\
                          &  ~~~~ compile_{PG}(pfx_{ij} ~\Path~ r'_{ij1} ~\Prefer~,\dots, ~\Prefer~ r'_{ijk} ) \\
                          &  ) \\
    \end{array} \]
 
    \vspace{.5em}
    This results in a series of prefixes, product graphs, and orderings of the form: $(pfx_{ij}, PG_{ij}, ord_{ij})$.

    \vspace{1em}
    Similarly, we can compute $compile(pol)$:

    \[ \begin{array}{ll}
        & compile(pol)  \\
                      & \\
                     =& compile_{ABGP}( \\
                      & ~~~~ compile_{PG}(t_1 ~\Path~ r_{11} ~\Prefer~,\dots, ~\Prefer~ r_{1k} ), \\
                      & ~~~~ \dots, \\
                      & ~~~~ compile_{PG}(t_i ~\Path~ r_{i1} ~\Prefer~,\dots, ~\Prefer~ r'_{ik} ), \\
                      & ) \\
    \end{array} \]

    This results in a series of prefixes, product graphs, and orderings of the form $(t_i, PG^A_i, ord^A_i)$.

    We know the follwing:

    \begin{itemize}
      \item each $PG^A_i$ and $PG_ij$ are related by $f_{pg}$
      \item each $ord^A_i$ and $ord_{ij}$ have the property that $ord^A(f_{pg}(m)) = ord_{ij}(m)$
    \end{itemize}
    


  \[ \begin{array}{l}
     con(\textbf{compile}( (t_1,PG^A_1,ord^A_1), \dots, (t^A_i,PG^A_i,ord^A_i) ), \Gamma,f,G) \\
  \end{array} \]%

Unfold definition of compile

  \[ \begin{array}{l}
     ~~~~~ con(\{ l \rightarrow rc ~\vert~ \\
     ~~~~~~~~~ l \in internal(V^A), \\
     ~~~~~~~~~ rc = \bigcup_i~ \{ t_i \rightarrow ma_1, \dots, ma_k ~\vert~ \\
     ~~~~~~~~~~~~~~~~~~~~~ M = (l,q_M) \in PG^A_i, \\
     ~~~~~~~~~~~~~~~~~~~~~ in = \{ B ~\vert~ (B,q_N) \in \text{adjIn}(PG^A_i,M) \} \\
     ~~~~~~~~~~~~~~~~~~~~~ out = \{ C ~\vert~ (C,\_) \in \text{adjOut}(PG^A_i,M) \} \\
     ~~~~~~~~~~~~~~~~~~~~~ ma_h = ord^A_i(M) : (in,q_n) \rightarrow (out,q_M) \} \}, \Gamma,f,G) \\
  \end{array} \]%

  Apply the definition of $con$

  \[ \begin{array}{l}
     ~~~~~ \{ \ell \rightarrow con(rc,\ell,\Gamma,f,G)) ~\vert~ \\
     ~~~~~~~~~ \ell \in f^{-1}(l), \\
     ~~~~~~~~~ l \in internal(V^A), \\
     ~~~~~~~~~ rc = \bigcup_i~ \{ t_i \rightarrow ma_1, \dots, ma_k ~\vert~ \\
     ~~~~~~~~~~~~~~~~~~~~~ M = (l,q_M) \in PG^A_i, \\
     ~~~~~~~~~~~~~~~~~~~~~ in = \{ B ~\vert~ (B,q_n) \in \text{adjIn}(PG^A_i,M) \} \\
     ~~~~~~~~~~~~~~~~~~~~~ out = \{ C ~\vert~ (C,\_) \in \text{adjOut}(PG^A_i,M) \} \\
     ~~~~~~~~~~~~~~~~~~~~~ ma_h = ord^A_i(M) : (in,q_N) \rightarrow (out,q_M) \} \} \\
  \end{array} \]%

  Rewrite $con$ on $rc$

  \[ \begin{array}{l}
     ~~~~~ \{ \ell \rightarrow rc ~\vert~ \\
     ~~~~~~~~~ \ell \in f^{-1}(l), \\
     ~~~~~~~~~ l \in internal(V^A), \\
     ~~~~~~~~~ rc = con(\bigcup_i~ \{ t_i \rightarrow ma_1, \dots, ma_k ~\vert~ \\
     ~~~~~~~~~~~~~~~~~~~~~ M = (l,q_M) \in PG^A_i, \\
     ~~~~~~~~~~~~~~~~~~~~~ in = \{ B ~\vert~ (B,q_N) \in \text{adjIn}(PG^A_i,M) \} \\
     ~~~~~~~~~~~~~~~~~~~~~ out = \{ C ~\vert~ (C,\_) \in \text{adjOut}(PG^A_i,M) \} \\
     ~~~~~~~~~~~~~~~~~~~~~ ma_h = ord^A_i(M) : (in,q_N) \rightarrow (out,q_M) \}, \ell,\Gamma,f,G) \} \\
  \end{array} \]%

  Apply definition of $con$

  \[ \begin{array}{l}
     ~~~~~ \{ \ell \rightarrow rc ~\vert~ \\
     ~~~~~~~~~ \ell \in f^{-1}(l), \\
     ~~~~~~~~~ l \in internal(V^A), \\
     ~~~~~~~~~ rc = \bigcup_i~ con(\{ t_i \rightarrow ma_1, \dots, ma_k ~\vert~ \\
     ~~~~~~~~~~~~~~~~~~~~~ M = (l,q_M) \in PG^A_i, \\
     ~~~~~~~~~~~~~~~~~~~~~ in = \{ B ~\vert~ (B,q_N) \in \text{adjIn}(PG^A_i,M) \} \\
     ~~~~~~~~~~~~~~~~~~~~~ out = \{ C ~\vert~ (C,\_) \in \text{adjOut}(PG^A_i,M) \} \\
     ~~~~~~~~~~~~~~~~~~~~~ ma_h = ord^A_i(M) : (in,q_N) \rightarrow (out,q_M) \}, \ell,\Gamma,f,G) \} \\
  \end{array} \]%

  \vspace{1em}
  \textbf{Case 1}: Assume $t_i = pfx$. Look at:

  \[ \begin{array}{l}
     ~~~~~~~~~ con(\{ pfx \rightarrow ma_1, \dots, ma_k ~\vert~ \\
     ~~~~~~~~~~~~~~~~~~ M = (l,q_M) \in PG^A_i, \\
     ~~~~~~~~~~~~~~~~~~ in = \{ B ~\vert~ (B,q_N) \in \text{adjIn}(PG^A_i,M) \} \\
     ~~~~~~~~~~~~~~~~~~ out = \{ C ~\vert~ (C,\_) \in \text{adjOut}(PG^A_i,M) \} \\
     ~~~~~~~~~~~~~~~~~~ ma_h = ord^A_i(M) : (in,q_N) \rightarrow (out,q_M) \},\ell,\Gamma,f,G) \\
  \end{array} \]%

  Apply definition of $con$

  \[ \begin{array}{l}
     ~~~~~~~~~ \{ pfx \rightarrow con(ma_1, \dots, ma_k,\text{true},\ell,\Gamma,f,G) ~\vert~ \\
     ~~~~~~~~~~~~~~~~~~ M = (l,q_M) \in PG^A_i, \\
     ~~~~~~~~~~~~~~~~~~ in = \{ B ~\vert~ (B,q_N) \in \text{adjIn}(PG^A_i,M) \} \\
     ~~~~~~~~~~~~~~~~~~ out = \{ C ~\vert~ (C,\_) \in \text{adjOut}(PG^A_i,M) \} \\
     ~~~~~~~~~~~~~~~~~~ ma_h = ord^A_i(M) : (in,q_N) \rightarrow (out,q_M) \} \\
  \end{array} \]%

  Apply definition of $con$

  \[ \begin{array}{l}
     ~~~~~~~~~ \{ pfx \rightarrow con(ma_1,\text{true},\ell,\Gamma,f,G), \dots, con(ma_k,\text{true},\ell,\Gamma,f,G) ~\vert~ \\
     ~~~~~~~~~~~~~~~~~~ M = (l,q_M) \in PG^A_i, \\
     ~~~~~~~~~~~~~~~~~~ in = \{ B ~\vert~ (B,q_N) \in \text{adjIn}(PG^A_i,M) \} \\
     ~~~~~~~~~~~~~~~~~~ out = \{ C ~\vert~ (C,\_) \in \text{adjOut}(PG^A_i,M) \} \\
     ~~~~~~~~~~~~~~~~~~ ma_h = ord^A_i(M) : (in,q_N) \rightarrow (out,q_M) \}) \\
  \end{array} \]%

  Apply definition of $con$

  \[ \begin{array}{l}
     ~~~~~~~~~ \{ pfx \rightarrow ma_1, \dots, ma_k ~\vert~ \\
     ~~~~~~~~~~~~~~~~~~ M = (l,q_M) \in PG^A_i, \\
     ~~~~~~~~~~~~~~~~~~ in = \{ B ~\vert~ (B,q_N) \in \text{adjIn}(PG^A_i,M) \} \\
     ~~~~~~~~~~~~~~~~~~ out = \{ C ~\vert~ (C,\_) \in \text{adjOut}(PG^A_i,M) \} \\
     ~~~~~~~~~~~~~~~~~~ ma_h = con(ord^A_i(M) : (in,q_N) \rightarrow (out,q_M), \text{true},\ell,\Gamma,f,G) \}) \\
  \end{array} \]%

  Apply definition of $con$

  \[ \begin{array}{l}
     ~~~~~~~~~ \{ pfx \rightarrow ma_1, \dots, ma_k ~\vert~ \\
     ~~~~~~~~~~~~~~~~~~ M = (l,q_M) \in PG^A_i, \\
     ~~~~~~~~~~~~~~~~~~ in = \{ B ~\vert~ (B,q_N) \in \text{adjIn}(PG^A_i,M) \} \\
     ~~~~~~~~~~~~~~~~~~ out = \{ C ~\vert~ (C,\_) \in \text{adjOut}(PG^A_i,M) \} \\
     ~~~~~~~~~~~~~~~~~~ ma_h = ord^A_i(M) : (con(in,\ell,\Gamma,f,G),q_N) \rightarrow (con(out,\ell,\Gamma,f,G),q_M) \} \\
  \end{array} \]%

  Rewrite on $in$ and $out$

  \[ \begin{array}{l}
     ~~~~~~~~~ \{ pfx \rightarrow ma_1, \dots, ma_k ~\vert~ \\
     ~~~~~~~~~~~~~~~~~~ M = (l,q_M) \in PG^A_i, \\
     ~~~~~~~~~~~~~~~~~~ in = con(\{ B ~\vert~ (B,q_N) \in \text{adjIn}(PG^A_i,M) \},\ell,\Gamma,f,G) \\
     ~~~~~~~~~~~~~~~~~~ out = con(\{ C ~\vert~ (C,\_) \in \text{adjOut}(PG^A_i,M) \},\ell,\Gamma,f,G) \\
     ~~~~~~~~~~~~~~~~~~ ma_h = ord^A_i(M) : (in,q_N) \rightarrow (out,q_M) \} \\
  \end{array} \]%

  Apply definition of $con$

  \[ \begin{array}{l}
     ~~~~~~~~~ \{ pfx \rightarrow ma_1, \dots, ma_k ~\vert~ \\
     ~~~~~~~~~~~~~~~~~~ M = (l,q_M) \in PG^A_i, \\
     ~~~~~~~~~~~~~~~~~~ in = \bigcup_B~ \{ b \in f^{-1}(B), (b,\ell) \in G.E, (B,q_N) \in \text{adjIn}(PG^A_i,M) \}) \\
     ~~~~~~~~~~~~~~~~~~ out = \bigcup_C~ \{ c \in f^{-1}(C), (c,\ell) \in G.E, (C,\_) \in \text{adjOut}(PG^A_i,M) \} \\
     ~~~~~~~~~~~~~~~~~~ ma_h = ord^A_i(M) : (in,q_N) \rightarrow (out,q_M) \} \\
  \end{array} \]%

  From the relation between concrete ($PG$) and abstract ($PG^A$) product graphs given by the previous lemma

  \[ \begin{array}{l}
     ~~~~~~~~~ \{ pfx \rightarrow ma_1, \dots, ma_k ~\vert~ \\
     ~~~~~~~~~~~~~~~~~~ m = (l,q_M) \in PG_{i1}, \\
     ~~~~~~~~~~~~~~~~~~ in = \{ b ~\vert~ (b,q_N) \in \text{adjIn}(PG_{i1},m) \}) \\
     ~~~~~~~~~~~~~~~~~~ out = \{ c ~\vert~ (c,\_) \in \text{adjOut}(PG_{i1},m) \} \\
     ~~~~~~~~~~~~~~~~~~ ma_h = ord^A_i(f_{pg}(m)) : (in,q_N) \rightarrow (out,q_M) \} \\
  \end{array} \]%

  Since $ord^A_i(f_{pg}(m)) = ord_{i1}(m)$

  \[ \begin{array}{l}
     ~~~~~~~~~ \{ pfx \rightarrow ma_1, \dots, ma_k ~\vert~ \\
     ~~~~~~~~~~~~~~~~~~ m = (l,q_M) \in PG_{i1}, \\
     ~~~~~~~~~~~~~~~~~~ in = \{ b ~\vert~ (b,q_N) \in \text{adjIn}(PG_{i1},m) \}) \\
     ~~~~~~~~~~~~~~~~~~ out = \{ c ~\vert~ (c,\_) \in \text{adjOut}(PG_{i1},m) \} \\
     ~~~~~~~~~~~~~~~~~~ ma_h = ord_{i1}(m) : (in,q_N) \rightarrow (out,q_M) \} \\
  \end{array} \]%

  Since product graphs have equivalent states

  \[ \begin{array}{l}
     ~~~~~~~~~ \{ pfx \rightarrow ma_1, \dots, ma_k ~\vert~ \\
     ~~~~~~~~~~~~~~~~~~ m = (l,q_m) \in PG_{i1}, \\
     ~~~~~~~~~~~~~~~~~~ in = \{ b ~\vert~ (b,q_n) \in \text{adjIn}(PG_{i1},m) \}) \\
     ~~~~~~~~~~~~~~~~~~ out = \{ c ~\vert~ (c,\_) \in \text{adjOut}(PG_{i1},m) \} \\
     ~~~~~~~~~~~~~~~~~~ ma_h = ord_{i1}(m) : (in,q_n) \rightarrow (out,q_m) \} \\
  \end{array} \]%

  \vspace{1em}
  \textbf{Case 2}: Assume $t_i = \$x$

  \[ \begin{array}{l}
     ~~~~~~~~~ con(\{ \$x \rightarrow ma_1, \dots, ma_k ~\vert~ \\
     ~~~~~~~~~~~~~~~~~~ M = (l,q_M) \in PG^A_i, \\
     ~~~~~~~~~~~~~~~~~~ in = \{ B ~\vert~ (B,q_N) \in \text{adjIn}(PG^A_i,M) \} \\
     ~~~~~~~~~~~~~~~~~~ out = \{ C ~\vert~ (C,\_) \in \text{adjOut}(PG^A_i,M) \} \\
     ~~~~~~~~~~~~~~~~~~ ma_h = ord^A_i(M) : (in,q_N) \rightarrow (out,q_M) \},\ell,\Gamma,f,G) \\
  \end{array} \]%

  Apply the definition of $con$

  \[ \begin{array}{l}
     ~~~~~~~~~ \{ pfx_{ij} \rightarrow con(ma_1, \dots, ma_k,l_{ij} = \ell,\ell,\Gamma,f,G) ~\vert~ \\
     ~~~~~~~~~~~~~~~~~~ (pfx_{ij}, l_{ij}) \in \Gamma(x), \\
     ~~~~~~~~~~~~~~~~~~ M = (l,q_M) \in PG^A_i, \\
     ~~~~~~~~~~~~~~~~~~ in = \{ B ~\vert~ (B,q_N) \in \text{adjIn}(PG^A_i,M) \} \\
     ~~~~~~~~~~~~~~~~~~ out = \{ C ~\vert~ (C,\_) \in \text{adjOut}(PG^A_i,M) \} \\
     ~~~~~~~~~~~~~~~~~~ ma_h = ord^A_i(M) : (in,q_N) \rightarrow (out,q_M) \} \\
  \end{array} \]%

  Apply definition $con$

  \[ \begin{array}{l}
     ~~~~~~~~~ \{ pfx_{ij} \rightarrow con(ma_1,l_{ij} = \ell,\ell,\Gamma,f,G), \dots, \\ 
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~ con(ma_k,l_{ij} = \ell,\ell,\Gamma,f,G) ~\vert~ \\
     ~~~~~~~~~~~~~~~~~~ (pfx_{ij}, l_{ij}) \in \Gamma(x), \\
     ~~~~~~~~~~~~~~~~~~ M = (l,q_M) \in PG^A_i, \\
     ~~~~~~~~~~~~~~~~~~ in = \{ B ~\vert~ (B,q_N) \in \text{adjIn}(PG^A_i,M) \} \\
     ~~~~~~~~~~~~~~~~~~ out = \{ C ~\vert~ (C,\_) \in \text{adjOut}(PG^A_i,M) \} \\
     ~~~~~~~~~~~~~~~~~~ ma_h = ord^A_i(M) : (in,q_N) \rightarrow (out,q_M) \} \\
  \end{array} \]%

  Rewrite $con$ on $ma_h$.

  \[ \begin{array}{l}
     ~~~~~~~~~ \{ pfx_{ij} \rightarrow ma_1, \dots, ma_k ~\vert~ \\
     ~~~~~~~~~~~~~~~~~~ (pfx_{ij}, l_{ij}) \in \Gamma(x), \\
     ~~~~~~~~~~~~~~~~~~ M = (l,q_M) \in PG^A_i, \\
     ~~~~~~~~~~~~~~~~~~ in = \{ B ~\vert~ (B,q_N) \in \text{adjIn}(PG^A_i,M) \} \\
     ~~~~~~~~~~~~~~~~~~ out = \{ C ~\vert~ (C,\_) \in \text{adjOut}(PG^A_i,M) \} \\
     ~~~~~~~~~~~~~~~~~~ ma_h = con(ord^A_i(M) : (in,q_N) \rightarrow (out,q_M),l_{ij} = \ell,\ell,\Gamma,f,G) \} \\
  \end{array} \]%

  Apply definition of $con$

  \[ \begin{array}{l}
     ~~~~~~~~~ \{ pfx_{ij} \rightarrow ma_1, \dots, ma_k ~\vert~ \\
     ~~~~~~~~~~~~~~~~~~ (pfx_{ij}, l_{ij}) \in \Gamma(x), \\
     ~~~~~~~~~~~~~~~~~~ M = (l,q_M) \in PG^A_i, \\
     ~~~~~~~~~~~~~~~~~~ in = \{ B ~\vert~ (B,q_N) \in \text{adjIn}(PG^A_i,M) \} \\
     ~~~~~~~~~~~~~~~~~~ out = \{ C ~\vert~ (C,\_) \in \text{adjOut}(PG^A_i,M) \} \\
     ~~~~~~~~~~~~~~~~~~ ma_h = \textbf{if}~ in=\{ G.s \} \text{ and } l_{ij} \neq \ell ~\textbf{then}~ \bullet \\ 
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ \textbf{else}~ ord^A_i(M) : (con(in,\ell,\Gamma,f,G),q_N) \rightarrow (con(out,\ell,\Gamma,f,G),q_M) \} \\
  \end{array} \]%

  \textbf{Observation}: 
  By filtering the cases where $in = \{ G.s \}$ and $l_{ij} \neq \ell$ we get the same thing as before after applying the definition of $con$, however for each $(pfx_{ij}, l_{ij}) \in \Gamma(x)$.

 \[ \begin{array}{l}
     ~~~~~~~~~ \{ pfx_{ij} \rightarrow ma_1, \dots, ma_k ~\vert~ \\
     ~~~~~~~~~~~~~~~~~~ (pfx_{ij}, l_{ij}) \in \Gamma(x), \\
     ~~~~~~~~~~~~~~~~~~ m = (l,q_m) \in PG_{ij}, \\
     ~~~~~~~~~~~~~~~~~~ in = \{ b ~\vert~ (b,q_n) \in \text{adjIn}(PG_{ij},m) \}) \\
     ~~~~~~~~~~~~~~~~~~ out = \{ c ~\vert~ (c,\_) \in \text{adjOut}(PG_{ij},m) \} \\
     ~~~~~~~~~~~~~~~~~~ ma_h = ord_{ij}(m) : (in,q_n) \rightarrow (out,q_m) \} \\
  \end{array} \]%

  This works because each $PG_{ij}$ was constructed from $con(r_{ijk}) \cap end(l_{ij})$. This means that the only state in $PG_{ij}$ connected to the start node $G.s$ is a node for $l_{ij}$. This was ensured by the fact that the transition function for each regular expression $\sigma_{ijk}(q_0,l) = q$ is defined only for locations $l \in L$ where $L = \{ l_{ij} \}$ from the construction of the automata.

  \vspace{1em}
  \textbf{Merging Cases}:

  In the first case, we got a result of the form:

  \[ \begin{array}{l}
     ~~~~~~~~~ \{ pfx \rightarrow ma_1, \dots, ma_k ~\vert~ \\
     ~~~~~~~~~~~~~~~~~~ m = (l,q_m) \in PG_{i1}, \\
     ~~~~~~~~~~~~~~~~~~ in = \{ b ~\vert~ (b,q_n) \in \text{adjIn}(PG_{i1},m) \}) \\
     ~~~~~~~~~~~~~~~~~~ out = \{ c ~\vert~ (c,\_) \in \text{adjOut}(PG_{i1},m) \} \\
     ~~~~~~~~~~~~~~~~~~ ma_h = ord_{i1}(m) : (in,q_n) \rightarrow (out,q_m) \} \\
  \end{array} \]%

  In the second case, we got a result of the form:

 \[ \begin{array}{l}
     ~~~~~~~~~ \{ pfx_{ij} \rightarrow ma_1, \dots, ma_k ~\vert~ \\
     ~~~~~~~~~~~~~~~~~~ (pfx_{ij}, l_{ij}) \in \Gamma(x), \\
     ~~~~~~~~~~~~~~~~~~ m = (l,q_m) \in PG_{ij}, \\
     ~~~~~~~~~~~~~~~~~~ in = \{ b ~\vert~ (b,q_n) \in \text{adjIn}(PG_{ij},m) \}) \\
     ~~~~~~~~~~~~~~~~~~ out = \{ c ~\vert~ (c,\_) \in \text{adjOut}(PG_{ij},m) \} \\
     ~~~~~~~~~~~~~~~~~~ ma_h = ord_{ij}(m) : (in,q_n) \rightarrow (out,q_m) \} \\
  \end{array} \]%

  Putting these together, we get the following:

  \[ \begin{array}{l}
     ~~~~~ \{ \ell \rightarrow rc ~\vert~ \\
     ~~~~~~~~~ \ell \in f^{-1}(l), \\
     ~~~~~~~~~ l \in internal(V^A), \\
     ~~~~~~~~~ rc = \bigcup_{ij}~ \{ pfx_{ij} \rightarrow ma_1, \dots, ma_k ~\vert~ \\
     ~~~~~~~~~~~~~~~~~~~~~ m = (l,q_m) \in PG_{ij}, \\
     ~~~~~~~~~~~~~~~~~~~~~ in = \{ b ~\vert~ (b,q_n) \in \text{adjIn}(PG_{ij},m) \}) \\
     ~~~~~~~~~~~~~~~~~~~~~ out = \{ c ~\vert~ (c,\_) \in \text{adjOut}(PG_{ij},m) \} \\
     ~~~~~~~~~~~~~~~~~~~~~ ma_h = ord_{ij}(m) : (in,q_n) \rightarrow (out,q_m) \} \\
  \end{array} \]%


  Finally, we observe that this is equivalent to the following:

  \[ \begin{array}{l}
     ~~~~~ \{ l \rightarrow rc ~\vert~ \\
     ~~~~~~~~~ l \in internal(V), \\
     ~~~~~~~~~ rc = \bigcup_{ij}~ con(\{ pfx_{ij} \rightarrow ma_1, \dots, ma_k ~\vert~ \\
     ~~~~~~~~~~~~~~~~~~~~~ m = (l,q_m) \in PG_{ij}, \\
     ~~~~~~~~~~~~~~~~~~~~~ in = \{ b ~\vert~ (b,q_n) \in \text{adjIn}(PG_{ij},m) \}) \\
     ~~~~~~~~~~~~~~~~~~~~~ out = \{ c ~\vert~ (c,\_) \in \text{adjOut}(PG_{ij},m) \} \\
     ~~~~~~~~~~~~~~~~~~~~~ ma_h = ord_{ij}(m) : (in,q_n) \rightarrow (out,q_m) \} \\
  \end{array} \]%

  This is exactly the definition of compilation for the concretized policy

  \[ \begin{array}{l}
     = \textbf{compile}( (pfx_{11},PG_{11},ord_{11}), \dots, (pfx_{ij},PG_{ij},ord_{ij}) ) \\
  \end{array} \]%


  \end{proof}

\end{thm}

\end{document}