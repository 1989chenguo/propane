\section{Introduction}
\label{sec:introduction}

It is well-known that network configuration is hard and error prone~\cite{x,y,z}; many studies of network incidents point to configuration errors as the leading cause.
%
One reason is that device configuration languages are low-level and several configuration elements must be kept consistent (e.g., interface addresses) for the device to behave as intended.
%

Another, more fundamental reason is the semantic mismatch between intended policies and configuring individual devices.
%
Many policies are network-wide (e.g., such as prefer certain external neighbors over others, never announce certain destination prefixes externally, use a certain path only if another fails), but configurations describe the behavior of individual devices.
%
Operators must manually decompose network-wide policy into device-level behaviors, such that their interactions produce the desired policy.
%
Ensuring policy-compliance through this manual decomposition is hard and error-prone, especially in the face of failures. Certain decompositions that work correctly otherwise, violate policies when failures occur.
%
As a result, many configuration errors manifest only during failures~\cite{batfish}.

To reduce configuration errors, the practitioner community is adopting a template-based approach~\cite{x,y}, in which common configuration constructs are captured as parameterized templates.
 While templates help with the low-level nature of configuration languages, they do not bridge the semantic divide between network policies and device-level configuration (\S\ref{sec:motivation}).

Software-defined networking (SDN) was, in part, the research community's response to the difficulty of maintaining policy compliance through distributed interaction of individual devices~\cite{xx}. It eliminates distributed control planes altogether. Instead of devices computing  forwarding tables through mutual interactions, they are told by a centralized controller exactly how to forward packets. The controller is responsible for ensuring policy compliance at all times. To program centralized control planes, researchers have developed increasingly sophisticated languages that let operators directly express network policies~\cite{x,y,z} that are then translated to forwarding tables at runtime.

Centralized control planes, however, are not a panacea. 
%They face significant challenges related to scaling and failure robustness. 
They require careful design and engineering to be robust to failures at scale---one must ensure that all devices can communicate with the controller at all times, even under arbitrary combinations of failure~\cite{x,y,z}. For this challenge, researchers are exploring multi-controller networks, with interacting controllers, thus bringing back distributed control planes~\cite{x,y,z} and their current programming difficulties.

In this paper, we ask if it is possible to centrally program distributed control planes.
Operators should be able to directly express network-wide policies, which are automatically decomposed into individual device configurations. The resulting forwarding behavior, which emerges through device interactions, must be policy-compliant under all possible failures.
If successful, this approach would combine easy programmability of centralized control planes and failure robustness of distributed control planes. 
%
More pragmatically, it would help many networks that, for the foreseeable future, will continue to use a distributed control plane, due to the difficulty of migrating to SDN or the inherent scalability and failure-robustness of distributed control.


Through our system, called \sysname, we demonstrate the feasibility of centrally programming distributed control planes. We focus on BGP, a common and highly flexible way to implement distributed control planes, and show how to automatically generate router BGP configurations from a program that directly expresses network policies.

\todo{new intro is not complete}

\todo{OLD TEXT IS BELOW}

%% Word vommit
Why network configuration is hard:
\begin{itemize}
	\item Wide variety of considerations: Have preferences for certain routes over others, failure resistance, backups etc
	\item Configurations are implemented locally and in a distributed fashion even though network intent is global
	\item Often achieve intent through indirect means (i.e., backups through aggregation, preferences through MED, AS PATH length, local-pref values, filtering through communities)
	\item Networks are distributed, asynchronous systems where the environment can be unknown, failures can occur ... which makes it difficult to consider all scenarios
	\item Problems are compounded in inter-domain setting where factors like peering agreements and bad peer behavior need to be taken into account.
	\item Protocol-specific issues such as lack of convergence in BGP
\end{itemize}

We present a new language that allows operators to directly express and compile high-level routing policies (both inter and intra-domain) from a centralized point of view.

The language provides the operator with the abstraction that they can control the routes that all traffic through their network can take, even if the routes start and/or end in a different autonomous system.

The core language consists of regular expression constraints on the set of allowed routes along with a preference operator between routes, which is used to specify both routing preferences and backup paths.
On top of the core language, we provide a higher-level macro language to talk only about constraints on routes without specifying any particular route details.
	
A compiler takes a routing policy written in our language and synthesizes concrete, per-device configurations running BGP. Although the language is independent of any particular routing protocol, we target BGP due to its expressiveness, scalability, and use for both inter-domain and intra-domain routing.
The compiler either guarantees that the resulting configurations correctly implement the policy and remain correct under all possible network failure scenarios, or it returns a counterexample.
(Similar to SDN, you get centralized control, yet a distributed implementation that uses an existing, scalable, fault-tolerant protocol.)

To allow for more fine-grained control over control-plane details, our language permits additional constraints on control protocol details (e.g., maximum number of allowed routes, whether to use multipath etc).


Summary:
	 (1) Centralized: (simpler reasoning, no copy paste error, more concise),
	 (2) Synthesis: (no need for gory details, e.g., community values, local-pref, MED, ...),
	 (3) Expressive: (backup routing, preferences, waypointing, directly say things like no transit or cold-potato routing),
	 (4) Correct: (implement the policy, even under all failure scenarios)


