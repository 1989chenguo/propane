\documentclass[sigchi]{acmart}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{xcolor}
\usepackage{url}
\usepackage{xspace}
\usepackage{code}

\newcommand{\EG}{\emph{e.g.}}
\newcommand{\IE}{\emph{i.e.}}
\newcommand{\ETC}{\emph{etc.}}
\newcommand{\ETAL}{\emph{et al.}}
\newcommand{\sysname}{{\small \sf Propane}\xspace}
\newcommand{\para}[1]{\paragraph*{\textbf{#1}}}

\settopmatter{printacmref=false} % Removes citation information below abstract
\renewcommand\footnotetextcopyrightpermission[1]{} % removes footnote with conference information in first column
\pagestyle{plain} % removes running headers

\begin{document}
\title{Propane: Programming Distributed Control Planes}
\subtitle{Extended Abstract (demo)}

\author{Ryan Beckett}
\affiliation{%
  \institution{Princeton University}
}
\email{rbeckett@cs.princeton.edu}

\author{Ratul Mahajan}
\affiliation{%
  \institution{Microsoft Research}
}
\email{ratul@microsoft.com}

\author{Todd Millstein}
\affiliation{%
  \institution{University of California, Los Angeles}
}
\email{todd@cs.ucla.edu}

\author{Jitendra Padhye}
\affiliation{
  \institution{Microsoft Research}
}
\email{padhye@microsoft.com}

\author{David Walker}
\affiliation{%
  \institution{Princeton University}
}
\email{dpw@princeton.edu}

\begin{abstract} 

We describe \sysname, a new system with a language for specifying the end-to-end routing behavior of the network and a compiler for implementing the policies using the a collection of device configurations for the BGP routing protocol that run on unmodified vendor hardware. Propane allows operators to describe their policy through high-level constraints on both the shape and relative preferences of paths for different types of traffic. Constraints can describe paths both through the user's network, as well as through other networks that are not directly under the user's control.
When \sysname compiles a policy, the resulting BGP configurations are guaranteed to 
%remain policy-compliant
correctly implement the centralized policy in a distributed fashion -- without any centralized coordination and regardless of any number of network failures. We will demo \sysname by showing how to write and compile a simple data center routing configuration.


%%\textbf{Abstract---}
%Networks are notoriously difficult to configure correctly.
%Operators typically rely on local configuration of individual devices running
%distributed control plane protocols to achieve network-wide objectives.
%Managing implicit dependencies between device configurations and properly accounting for failures makes
%a network operator's work particularly difficult.
%%% %
%The recent move towards software-defined networking has been motivated, in part,
%by the simplicity of the centralized model, where a controller directly manages
%individual devices rather than letting them manage themselves. However distributed
%protocols have many important advantages in scalability,
%latency and fault tolerance over the completely centralized approach.
%%% %
%In this paper, we describe a new system -- \sysname, which allows an operator to specify a high-level,
%centralized routing policy declaratively, but then to compile it to a purely distributed
%implementation, which uses the BGP routing protocol to run on existing, commodity hardware.
%%% %
%Propane allows operators to describe the types of paths traffic may (or may not) take
%through the network, as well as relative preferences (or backups) between paths.
%%% %
%Network policies compiled with \sysname are guaranteed to implement the correct routing policy regardless of the number of failures, if possible.  If this is not possible, the compiler notifies the user at compile time rather than as the network is in operation.
%%% %
%\sysname also takes the centralized model one step further by unifying inter and intra-domain routing. Operators can specify routing policy for an autonomous system by programming against the abstraction that they can control any route in the wider internet.
%%% %
%%% We have implemented a compiler for \sysname and evaluated it against several real-world configurations for datacenters and core backbone networks. We demonstrate the \sysname compiler can scale to
%%% topologies with thousands of routers.

\end{abstract}

\maketitle


\section{Introduction}

Operators of traditional networks have a difficult job: They are charged
with achieving a wide variety of network-wide objectives, but they must do so by
managing and configuring many individual, separate devices, each of which runs
complex distributed control plane protocols. However, existing languages
for network configuration provided by vendors are too low level, requiring operators to work with assembly-language-like configuration primitives such as route-filters, community tags, and local-preference among routes. Further, the distributed nature of the network makes implementing network-wide policy more difficult. Many policies involve network-wide properties, for example to prefer a certain neighbor, keep certain traffic in a geographic region, or use a particular path only as a backup -- yet configurations describe the behavior of individual devices.

%
It is up to the operator then to perform the intellectually challenging task of decomposing a network-wide policy into a collection of distributed device policies such that their distributed interactions emulate the original policy.

To make matters worse, the possibility for network failures is an 
ever-present concern that significantly complicates the operator's task. 
Reasoning about all possible combinations of failures
and their potential impact on a distributed system is simply too hard for most humans. 
It is not surprising then that configurations that work correctly in fault-free 
environments, have been found to result in incorrect behavior when network 
elements go down~\cite{batfish}.
%
%
As a consequence of the difficulty of achieving network-wide objectives through device-level configuration, in practice, configuration errors are responsible for a large fraction of highly disruptive network outages~\cite{juniper-study,yankee-study,mahajan+:bgp-misconfiguration,feamster+:rcc,batfish,dc-failure-study,time-warner}.

%For instance, a recent misconfiguration led to an hour-long, nation-wide outage for Time Warner's backbone network~\cite{time-warner}; and a major BGP-related incident makes international news every few months~\cite{bgpmon}.

%To combat misconfiguration, operators have adopted several

%To reduce configuration errors, operators are increasingly adopting an
%approach in which common tasks are captured as parameterized templates~\cite{hatch,thwack}.

%
%More powerful still are systems like
%ConfigAssure~\cite{narain:lisa05,narain+:configassure}, which use SAT solving
%and model finding tools to fill in parameters in configurations while
%ensuring key correctness constraints are satisfied.
%One step further, systems like
%ConfigAssure~\cite{narain:lisa05,narain+:configassure} use SAT solving
%and model finding tools to correctly and consistently fill in some parameters.
%

%While templates help ensure certain kinds of consistency across devices,
%they do not provide fundamentally different abstractions from existing configuration languages
%or bridge the semantic divide between network-wide policies and device-level configuration.

%They do not provide fundamentally different abstractions
%from existing configuration languages and

%Thus, they still require operators to
%manually decompose policies into device behaviors.

%As a complementary approach, configuration analysis tools can help reduce misconfigurations by checking if low-level configurations match high-level policy~\cite{batfish,feamster+:rcc}. However, such tools cannot help operators with the challenging task of generating configurations in the first place.

%Further, today's tools cannot verify correctness under concrete failure scenarios, rather than under all possible failures.

In recent years, Software-defined networking (SDN) has emerged as an alternative 
approach to traditional network configuration. Rather than organizing routing policy
around a collection of configurations that compute routes via well-known distributed
protocols, users can directly program the forwarding tables of SDN-enabled switches via
a centralized controller. It is the job of the controller then, which has a centralized view
of the network to make sure that the routing policy is implemented correctly.

However, the SDN approach comes with its own set of challenges. For one, centralized SDN systems introduce a potential single point of failure and thus must be carefully designed with robustness in mind. The controller(s) must always be able to communicate with every switch even when failures occur, or if the network is large and geographically-distributed. Furthermore, such systems must also be carefully engineered for low-latency and scalability since the centralized controller can quickly become a potential performance bottleneck. For many of these challenges, researchers have looked at systems with multiple, interacting controllers, thus bringing back some aspects of distributed
control planes~\cite{mccauley2013extending,onos}.
Second, current SDN systems focus only on configuration of intra-domain routing policy, forcing users to fall back to traditional methods for configuring inter-domain routing policy.
More pragmatically, many networks will continue to use a distributed control plane for the foreseeable future, due to the difficulty of migrating to SDN or the inherent scalability and failure-robustness of distributed control.

\para{Language Overview}
We will demo our recent efforts to design and
implement a new language called \sysname, which greatly simplifies the task of
network management by allowing operators to specify their objectives
using high-level, \emph{end-to-end} constraints on forwarding paths rather than writing explicit device-by-device configurations.

The \sysname compiler rather than a human is responsible for bridging the gap
between high-level goals and the low-level mechanisms.  More
specifically, \sysname allows operators to describe the kinds of paths
traffic may or may not follow, as well as the relative preferences of such paths.
Paths can reference both devices in the network as well as other networks that are not under the control of the operator. 

Taken together, these constraints allow users to write rich routing policies for the network. For example, then can require that two nodes be reachable, that traffic never leaves a particular part of the network, or that traffic is waypointed through middleboxes.
Preferences allow operators to write policies that describe desired behavior after network failures occur, such as preferring to use routes through one neighboring network over another, or using particular paths only as backups for other paths.

The \sysname language also supports network operators by defining a
set of common abbreviations for entering, leaving, and traversing
the user network and provides abstractions for managing common features of
control plane algorithms such as route aggregation.  
Operators use familiar logical operations to build routes in a modular and 
compositional manner from these primitives. 

\para{Compiler Overview}

\sysname analyzes these user specifications and
then compiles them to a collection of BGP configurations, so they may
exploit existing distributed policy and fault tolerance mechanisms and
execute on existing commodity hardware. During the compilation
process, the compiler automatically synthesizes low-level configuration 
primitives such as per-device import and export
filters as well as BGP local preferences, MED attributes, and community tags.
The compiler accomplishes this by first transforming the policy into a graph-based intermediate 
representation that is more amenable to compilation and analysis.

An important feature of the language is that if possible, compiled
configurations are guaranteed to implement the correct routing policy,
regardless of any number of failures that might occur in the network.  
If correct compilation is impossible, the compiler notifies the user 
at compile time rather than waiting until the system is deployed in operation
and failures have occurred in the network.

This guarantee does not mean that the implementation is always
able to send traffic to its ultimate destination
(e.g., in the case of a network partition), but rather that it always respects the
centralized policy, which may include dropping traffic when there is no route.

Overall, we believe the approach \sysname combines easy programmability of centralized control planes with the failure robustness and scalability of distributed control planes.


\para{Demo Overview}
The \sysname demo will give a brief overview of the language and compiler by demonstrating how to write and compile a simple \sysname policy for a data center network. We will then demonstrate how the generated configurations can be emulated using Quagga router software with the open-source CORE network emulator.
An overview of what the demo can look like can be found here:

\vspace{1em}
\begin{sloppypar}
\url{https://drive.google.com/open?id=0B-rjACAtTwE_c0JGczdNRFBYcEE}
\end{sloppypar}

\para{Acknowledgments}
We thank R. Aditya, George Chen, and Lihua Yuan for feedback on the work and the SIGCOMM reviewers for comments on the paper. This work is supported in part by the National Science Foundation awards CNS-1161595 and CNS-1111520 as well as a gift from Cisco.



\bibliographystyle{abbrv}
\bibliography{references}

\end{document}