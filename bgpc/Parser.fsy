%{
open System
open Ast
open Microsoft.FSharp.Collections

exception EmptyFile
exception NoScope
exception NoPathConstraints

let addScope s (ds, ps, cs) = 
    {Name=s;
    Defs=ds;
    PConstraints=ps;
    CConstraints=cs}

%}

%start start
%type <Ast.T> start

%token <string> ID
%token <System.Int32> INT

%token EQUAL 
%token LPAREN 
%token RPAREN 
%token LBRACKET 
%token RBRACKET 
%token LBRACE 
%token RBRACE 
%token COMMA 
%token SLASH 
%token COLON 
%token SEMICOLON 
%token RARROW 
%token ROCKET 
%token DOT 
%token EOF

%token INTERSECT 
%token UNION 
%token NOT 
%token STAR 
%token SHR 
%token AND 
%token OR 
%token TRUE 
%token FALSE

%token DEFINE 
%token SCOPE
%token PATHS 
%token ORDERED 
%token UNORDERED

%nonassoc EQUALS
%left UNION INTERSECT
%left SEMICOLON
%left AND OR
%right NOT
%left STAR
%left SHR

%%

start:
	| scopes EOF							{ $1 }

scopes:
	| SCOPE ID LBRACE scope RBRACE			{ [addScope $2 $4] }
	| SCOPE ID LBRACE scope RBRACE scopes	{ (addScope $2 $4) :: $6 }

scope:
	| pconstrs								{ ([], $1, []) }
	| pconstrs cconstrs						{ ([], $1, $2) }
	| definitions pconstrs					{ ($1, $2, []) }
	| definitions pconstrs cconstrs			{ ($1, $2, $3) }

cconstrs:
	| cconstr								{ [$1] }
	| cconstr cconstrs						{ $1 :: $2 }

cconstr:
	| ID									{ ($1, []) }
	| ID LPAREN exprs RPAREN				{ ($1, $3) }

exprs:
	| expr									{ [$1] }
	| expr COMMA exprs						{ $1 :: $3 }

expr:
    | ID									{ Ast.IdentExpr $1 }
    | INT									{ Ast.IntLiteral $1 }
    | predicate								{ Ast.PredicateExpr $1 }
    | regex RARROW regex					{ Ast.LinkExpr ($1, $3) }

pconstrs:
	| pconstr								{ [$1] }
	| pconstr pconstrs						{ $1 :: $2 }

pconstr:
	| predicate ROCKET regexes				{ ($1, $3) }

regexes:
	| regex									{ [$1] }
	| regex COMMA regexes					{ $1 :: $3 }

regex:
	| ID									{ Ast.Ident ($1, []) }
	| ID LPAREN regexes RPAREN				{ Ast.Ident ($1, $3) }
	| LBRACKET RBRACKET						{ Ast.Empty }
	| regex SEMICOLON regex					{ Ast.Concat ($1, $3) }
	| regex INTERSECT regex					{ Ast.Inter ($1, $3) }
	| regex UNION regex						{ Ast.Union ($1, $3) }
	| NOT regex								{ Ast.Negate $2 }
	| regex STAR							{ Ast.Star $1 }
	| LPAREN regex RPAREN					{ $2 }

predicate:
	| INT DOT INT DOT INT DOT INT			{ Ast.Prefix($1, $3, $5, $7, None) }
	| INT DOT INT DOT INT DOT INT SLASH INT	{ Ast.Prefix($1, $3, $5, $7, Some $9) }
	| TRUE									{ Ast.True }
	| FALSE									{ Ast.False }
	| predicate OR predicate				{ Ast.Or($1, $3) }
	| predicate AND predicate				{ Ast.And($1, $3) }
	| NOT predicate							{ Ast.Not $2 }
	| LPAREN predicate RPAREN				{ $2 }

definitions:
	| definition							{ [$1] }
	| definition definitions				{ $1 :: $2 }

definition:
	| DEFINE ID								{ $2 }