%{
open System
open Ast
open Microsoft.FSharp.Collections

exception EmptyFile
exception NoScope
exception NoPathConstraints

let addScope s (ds, ps, cs) = 
    {Name=s;
    Defs=ds;
    PConstraints=ps;
    CConstraints=cs}

let loc l = 
    if l = "in" then Ast.Inside 
    else if l = "out" then Ast.Outside 
    else Ast.Loc l
%}

%start start
%type <Ast.T> start

%token <string> ID
%token <System.Int32> INT

%token EQUAL 
%token LPAREN 
%token RPAREN 
%token LBRACKET 
%token RBRACKET 
%token LBRACE 
%token RBRACE 
%token COMMA 
%token SLASH 
%token COLON 
%token SEMICOLON 
%token RARROW 
%token ROCKET 
%token DOT 
%token EOF

%token INTERSECT 
%token UNION 
%token NOT 
%token STAR 
%token SHR 
%token AND 
%token OR 
%token TRUE 
%token FALSE

%token DEFINE 
%token SCOPE 
%token OWNS 
%token PATHS 
%token ORDERED 
%token UNORDERED 
%token AGGREGATE 
%token COMMUNITY 
%token MAXROUTES 
%token MULTIPATH 
%token INCLUDE

%nonassoc EQUALS
%left UNION INTERSECT
%left SEMICOLON
%left AND OR
%right NOT
%left STAR
%left SHR


%%

start:
	| scopes EOF							{ $1 }

scopes:
	| SCOPE ID LBRACE scope RBRACE			{ [addScope $2 $4] }
	| SCOPE ID LBRACE scope RBRACE scopes	{ (addScope $2 $4) :: $6 }

scope:
	| pconstrs								{ ([], $1, []) }
	| pconstrs cconstrs						{ ([], $1, $2) }
	| definitions pconstrs					{ ($1, $2, []) }
	| definitions pconstrs cconstrs			{ ($1, $2, $3) }

cconstrs:
	| cconstr								{ [$1] }
	| cconstr cconstrs						{ $1 :: $2 }

cconstr:
	| MULTIPATH								{ Ast.Multipath }
	| MAXROUTES LPAREN INT RPAREN			{ Ast.MaxRoutes $3 }
	| AGGREGATE LPAREN predicate COMMA regex RARROW regex RPAREN { Ast.RouteAggregate($3, $5, $7) }
	| COMMUNITY LPAREN predicate COMMA regex RARROW regex RPAREN { Ast.CommunityTag($3, $5, $7) }
	| OWNS LPAREN predicate COMMA regex	RPAREN	{ Ast.Ownership($3, $5) }

pconstrs:
	| pconstr								{ [$1] }
	| pconstr pconstrs						{ $1 :: $2 }

pconstr:
	| predicate ROCKET regexs				{ ($1, $3) }

regexs:
	| regex									{ [$1] }
	| regex SHR regexs						{ $1 :: $3 }

regex:
	| ID									{ loc $1 }
	| LBRACKET RBRACKET						{ Ast.Empty }
	| regex SEMICOLON regex					{ Ast.Concat ($1, $3) }
	| regex INTERSECT regex					{ Ast.Inter ($1, $3) }
	| regex UNION regex						{ Ast.Union ($1, $3) }
	| NOT regex								{ Ast.Negate $2 }
	| regex STAR							{ Ast.Star $1 }
	| LPAREN regex RPAREN					{ $2 }

predicate:
	| INT DOT INT DOT INT DOT INT			{ Prefix.Prefix($1, $3, $5, $7, None) }
	| INT DOT INT DOT INT DOT INT SLASH INT	{ Prefix.Prefix($1, $3, $5, $7, Some $9) }
	| TRUE									{ Prefix.True }
	| FALSE									{ Prefix.False }
	| predicate OR predicate				{ Prefix.Or($1, $3) }
	| predicate AND predicate				{ Prefix.And($1, $3) }
	| NOT predicate							{ Prefix.Not $2 }
	| LPAREN predicate RPAREN				{ $2 }


definitions:
	| definition							{ [$1] }
	| definition definitions				{ $1 :: $2 }

definition:
	| DEFINE ID								{ $2 }