%{
open System
open Ast
open Common.Error
open Microsoft.FSharp.Collections
open Microsoft.FSharp.Text.Lexing

type LineInfo = Position * Position

let pos ((p1, p2): Position * Position) : Ast.Position =
    {SLine = p1.Line; 
     SCol = p1.Column;
     ELine = p2.Line;
     ECol = p2.Column}

let fromStartEnd (p1: Ast.Position) (p2: Ast.Position) : Ast.Position =
    {SLine = p1.SLine; 
     SCol = p1.SCol;
     ELine = p2.ELine;
     ECol = p2.ECol}

let buildUnaryExpr left p x : Ast.Position * Expr = 
    let p1 = pos p
    let p2 = Ast.getPosition x in 
    if left then
        (fromStartEnd p1 p2, x)
    else (fromStartEnd p2 p1, x)

let buildBinaryExpr x y = 
    let p1 = Ast.getPosition x in 
    let p2 = Ast.getPosition y in
    (fromStartEnd p1 p2, x, y)

let buildDefinitions defs = 
    List.fold (fun acc (name, x) -> 
        match Map.tryFind name acc with
        | None -> Map.add name x acc
        | Some _ -> 
            error (sprintf "\nDuplicate definition of %s" name)
        ) Map.empty defs
%}

%start start
%type <Ast.T> start

%token <LineInfo> TRUE
%token <LineInfo> FALSE
%token <LineInfo * string> ID
%token <LineInfo * System.UInt32> INT

%token <LineInfo> NOT 
%token <LineInfo> STAR 
%token <LineInfo> DIFFERENCE
%token <LineInfo> SHR 
%token <LineInfo> AND 
%token <LineInfo> OR

%token <LineInfo> DEFINE
%token <LineInfo> CONTROL

%token <LineInfo> EQUAL
%token <LineInfo> LPAREN 
%token <LineInfo> RPAREN 
%token <LineInfo> LBRACKET 
%token <LineInfo> RBRACKET 
%token <LineInfo> LBRACE 
%token <LineInfo> RBRACE 
%token <LineInfo> COMMA 
%token <LineInfo> SLASH
%token <LineInfo> COLON 
%token <LineInfo> RARROW 
%token <LineInfo> ROCKET 
%token <LineInfo> DOT

%token EOF


%nonassoc EQUALS
%left RARROW
%left SHR
%left DIFFERENCE
%left OR
%left AND
%right NOT
%left STAR

%%

start: 
	| definitions EOF                            { {Defs=buildDefinitions $1; CConstraints=[]} }
	| definitions control EOF                    { {Defs=buildDefinitions $1; CConstraints=$2} }

control:
	| CONTROL LBRACE RBRACE                      { [] }
    | CONTROL LBRACE cconstrs RBRACE             { $3 }

pconstrs: 
    | pconstr                                    { [$1] }
	| pconstr COMMA                              { [$1] }
    | pconstr COMMA pconstrs                     { $1 :: $3 } 

pconstr:
    | expr ROCKET expr                           { ($1, $3) }

cconstrs:
    | cconstr                                    { [$1] }
	| cconstr COMMA                              { [$1] }
    | cconstr COMMA cconstrs                     { $1 :: $3 }

cconstr:
    | ID                                         { (snd $1, []) }
    | ID LPAREN exprs RPAREN                     { (snd $1, $3) }

exprs:
    | expr                                       { [$1] }
    | expr COMMA exprs                           { $1 :: $3 }

expr:
	| ID									     { Ast.Ident (pos (fst $1), (snd $1), []) }
	| ID LPAREN exprs RPAREN                     { Ast.Ident (pos (fst $1), (snd $1), $3) }
    | expr AND expr                              { Ast.AndExpr (buildBinaryExpr $1 $3) }
    | expr OR expr                               { Ast.OrExpr (buildBinaryExpr $1 $3) }
    | expr DIFFERENCE expr                       { Ast.DiffExpr (buildBinaryExpr $1 $3) }
	| expr SHR expr					             { Ast.ShrExpr (buildBinaryExpr $1 $3) }
    | NOT expr                                   { Ast.NotExpr (buildUnaryExpr true $1 $2) }
    | expr STAR                                  { Ast.StarExpr (buildUnaryExpr false $2 $1) }
    | LPAREN expr RPAREN                         { $2 }
	| expr RARROW expr                           { Ast.LinkExpr (buildBinaryExpr $1 $3) }
    | INT DOT INT DOT INT DOT INT                { let p = fromStartEnd (pos (fst $1)) (pos (fst $7)) in
                                                   Ast.PrefixLiteral (p, (snd $1, snd $3, snd $5, snd $7, None)) }
    | INT DOT INT DOT INT DOT INT SLASH INT      { let p = fromStartEnd (pos (fst $1)) (pos (fst $9)) in
                                                   Ast.PrefixLiteral (p,(snd $1, snd $3, snd $5, snd $7, Some (snd $9))) }
	| INT COLON INT						         { let p = fromStartEnd (pos (fst $1)) (pos (fst $3)) in
                                                   Ast.CommunityLiteral (p,(snd $1, snd $3)) }
	| INT                                        { Ast.IntLiteral (pos (fst $1), snd $1) }
    | TRUE                                       { Ast.True (pos $1) } 
    | FALSE                                      { Ast.False (pos $1) }
	| LBRACE RBRACE	                             { Ast.BlockExpr (fromStartEnd (pos $1) (pos $2), []) }
	| LBRACE pconstrs RBRACE                     { Ast.BlockExpr (fromStartEnd (pos $1) (pos $3), $2) }

ids:
	| ID                                         { [snd $1] }
	| ID COMMA ids                               { (snd $1) :: $3 }

definitions:
    | definition                                 { [$1] }
    | definition definitions                     { $1 :: $2 }

definition:
    | DEFINE ID EQUAL expr	                     { (snd $2, ([], $4)) }
    | DEFINE ID LPAREN ids RPAREN EQUAL expr     { (snd $2, ($4, $7)) }