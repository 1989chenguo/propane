%{
open System
open Ast
open Common.Error
open Microsoft.FSharp.Collections

let buildDefinitions defs = 
    List.fold (fun acc (name, x) -> 
        match Map.tryFind name acc with
        | None -> Map.add name x acc
        | Some _ -> 
            error (sprintf "\nDuplicate definition of %s" name)
        ) Map.empty defs
%}

%start start
%type <Ast.T> start

%token <string> ID
%token <System.UInt32> INT

%token EQUAL
%token LPAREN 
%token RPAREN 
%token LBRACKET 
%token RBRACKET 
%token LBRACE 
%token RBRACE 
%token COMMA 
%token SLASH
%token COLON 
%token RARROW 
%token ROCKET 
%token DOT 
%token EOF
 
%token DIFFERENCE
%token NOT 
%token STAR 
%token SHR 
%token AND 
%token OR 
%token TRUE 
%token FALSE

%token DEFINE
%token CONTROL

%nonassoc EQUALS
%left RARROW
%left SHR
%left DIFFERENCE
%left OR
%left AND
%right NOT
%left STAR

%%

start: 
	| definitions EOF                            { {Defs=buildDefinitions $1; CConstraints=[]} }
	| definitions control EOF                    { {Defs=buildDefinitions $1; CConstraints=$2} }

control:
	| CONTROL LBRACE RBRACE                      { [] }
    | CONTROL LBRACE cconstrs RBRACE             { $3 }

pconstrs: 
    | pconstr                                    { [$1] }
	| pconstr COMMA                              { [$1] }
    | pconstr COMMA pconstrs                     { $1 :: $3 } 

pconstr:
    | expr ROCKET expr                           { ($1, $3) }

cconstrs:
    | cconstr                                    { [$1] }
	| cconstr COMMA                              { [$1] }
    | cconstr COMMA cconstrs                     { $1 :: $3 }

cconstr:
    | ID                                         { ($1, []) }
    | ID LPAREN exprs RPAREN                     { ($1, $3) }

exprs:
    | expr                                       { [$1] }
    | expr COMMA exprs                           { $1 :: $3 }

expr:
	| ID									     { Ast.Ident ($1, []) }
	| ID LPAREN exprs RPAREN                     { Ast.Ident ($1, $3) }
    | expr AND expr                              { Ast.AndExpr ($1, $3) }
    | expr OR expr                               { Ast.OrExpr ($1, $3) }
    | expr DIFFERENCE expr                       { Ast.DiffExpr ($1, $3) }
    | NOT expr                                   { Ast.NotExpr $2 }
    | expr STAR                                  { Ast.StarExpr $1 }
	| expr SHR expr					             { Ast.ShrExpr ($1, $3) }
    | LPAREN expr RPAREN                         { $2 }
	| expr RARROW expr                           { Ast.LinkExpr ($1, $3) }
    | INT DOT INT DOT INT DOT INT                { Ast.PrefixLiteral($1, $3, $5, $7, None) }
    | INT DOT INT DOT INT DOT INT SLASH INT      { Ast.PrefixLiteral($1, $3, $5, $7, Some $9) }
	| INT COLON INT						         { Ast.CommunityLiteral ($1, $3) }
	| INT                                        { Ast.IntLiteral $1 }
    | TRUE                                       { Ast.True } 
    | FALSE                                      { Ast.False }
	| LBRACE RBRACE	                             { Ast.BlockExpr [] }
	| LBRACE pconstrs RBRACE                     { Ast.BlockExpr $2 }

ids:
	| ID                                         { [$1] }
	| ID COMMA ids                               { $1 :: $3 }

definitions:
    | definition                                 { [$1] }
    | definition definitions                     { $1 :: $2 }

definition:
    | DEFINE ID EQUAL expr	                     { ($2, ([], $4)) }
    | DEFINE ID LPAREN ids RPAREN EQUAL expr     { ($2, ($4, $7)) }