%{
open System
open Ast
open Microsoft.FSharp.Collections

exception EmptyFile
exception NoScope
exception NoPathConstraints

let addScope s (ds, ps, cs) = 
    {Name=s;
    Defs=ds;
    PConstraints=ps;
    CConstraints=cs}

let loc l = 
    if l = "in" then Ast.Inside 
    else if l = "out" then Ast.Outside 
    else Ast.Loc l
%}

%start start
%type <Ast.T> start

%token <string> ID
%token <System.Int32> INT

%token EQUAL LPAREN RPAREN LBRACKET RBRACKET LBRACE RBRACE COMMA SLASH COLON SEMICOLON RARROW ROCKET DOT EOF
%token INTERSECT UNION NOT STAR SHR AND OR TRUE FALSE
%token DEFINE SCOPE OWNS PATHS ORDERED UNORDERED AGGREGATE COMMUNITY MAXROUTES MULTIPATH INCLUDE

%nonassoc EQUALS
%left UNION INTERSECT
%left SEMICOLON
%left AND OR
%right NOT
%left STAR
%left SHR


%%

start:
	| SCOPE ID LBRACE scope RBRACE EOF		{ [addScope $2 $4] }
	| SCOPE ID LBRACE scope RBRACE start EOF{ (addScope $2 $4) :: $6 }

scope:
	| pconstrs								{ ([], $1, []) }
	| pconstrs cconstrs						{ ([], $1, $2) }
	| definitions pconstrs					{ ($1, $2, []) }
	| definitions pconstrs cconstrs			{ ($1, $2, $3) }

cconstrs:
	| cconstr								{ [$1] }
	| cconstr cconstrs						{ $1 :: $2 }

cconstr:
	| MULTIPATH								{ Ast.Multipath }
	| MAXROUTES LPAREN INT RPAREN			{ Ast.MaxRoutes $3 }
	| AGGREGATE LPAREN predicate COMMA regex RARROW regex RPAREN { Ast.RouteAggregate($3, $5, $7) }
	| COMMUNITY LPAREN predicate COMMA regex RARROW regex RPAREN { Ast.CommunityTag($3, $5, $7) }
	| OWNS LPAREN predicate COMMA regex		{ Ast.Ownership($3, $5) }

pconstrs:
	| pconstr								{ [$1] }
	| pconstr pconstrs						{ $1 :: $2 }

pconstr:
	| predicate ROCKET regexs				{ Ast.Path($1, $3) }

regexs:
	| regex									{ [$1] }
	| regex SHR regexs						{ $1 :: $3 }

regex:
	| ID									{ loc $1 }
	| LBRACKET RBRACKET						{ Ast.Empty }
	| regex SEMICOLON regex					{ Ast.Concat ($1, $3) }
	| regex INTERSECT regex					{ Ast.Inter ($1, $3) }
	| regex UNION regex						{ Ast.Union ($1, $3) }
	| NOT regex								{ Ast.Negate $2 }
	| regex STAR							{ Ast.Star $1 }
	| LPAREN regex RPAREN					{ $2 }

predicate:
	| INT DOT INT DOT INT DOT INT			{ Prefix.Prefix($1, $3, $5, $7, None) }
	| INT DOT INT DOT INT DOT INT SLASH INT	{ Prefix.Prefix($1, $3, $5, $7, Some $9) }
	| TRUE									{ Prefix.True }
	| FALSE									{ Prefix.False }
	| predicate OR predicate				{ Prefix.Or($1, $3) }
	| predicate AND predicate				{ Prefix.And($1, $3) }
	| NOT predicate							{ Prefix.Not $2 }
	| LPAREN predicate RPAREN				{ $2 }


definitions:
	| definition							{ [$1] }
	| definition definitions				{ $1 :: $2 }

definition:
	| DEFINE ID								{ $2 }