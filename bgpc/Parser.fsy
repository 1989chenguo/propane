%{
open System
open Ast
open Microsoft.FSharp.Collections

exception EmptyFile
exception NoTask
exception NoPathConstraints

let addTask s ps = 
    {Name=s;
    PConstraints=ps}

%}

%start start
%type <Ast.T> start

%token <string> ID
%token <System.UInt32> INT

%token EQUAL
%token AT 
%token LPAREN 
%token RPAREN 
%token LBRACKET 
%token RBRACKET 
%token LBRACE 
%token RBRACE 
%token COMMA 
%token SLASH
%token COLON 
%token SEMICOLON 
%token RARROW 
%token ROCKET 
%token DOT 
%token EOF

%token DIFFERENCE
%token NOT 
%token STAR 
%token SHR 
%token AND 
%token OR 
%token TRUE 
%token FALSE

%token DEFINE 
%token TASK
%token CONTROL

%nonassoc EQUALS
%left SHR
%left UNION INTERSECT
%left AND OR DIFFERENCE
%left SEMICOLON
%left STAR
%right NOT

%%

start:
    | tasks regex EOF                       { {Defs=Map.empty; CConstraints=[]; Tasks=$1; Policy=$2} }
    | control tasks regex EOF               { {Defs=Map.empty; CConstraints=$1; Tasks=$2; Policy=$3} }
    | definitions tasks regex EOF           { {Defs=Map.ofList $1; CConstraints=[]; Tasks=$2; Policy=$3} }
    | definitions control tasks regex EOF   { {Defs=Map.ofList $1; CConstraints=$2; Tasks=$3; Policy=$4} }

control:
    | CONTROL LBRACE cconstrs RBRACE        { $3 }


tasks:
    | TASK ID LBRACE task RBRACE			{ [addTask $2 $4] }
    | TASK ID LBRACE task RBRACE tasks	    { (addTask $2 $4) :: $6 }

task:
    | pconstrs                              { $1 }

pconstrs:
    | pconstr                               { [$1] }
    | pconstr pconstrs                      { $1 :: $2 }

pconstr:
    | predicate ROCKET regex                { ($1, $3) }

cconstrs:
    | cconstr                               { [$1] }
    | cconstr cconstrs                      { $1 :: $2 }

cconstr:
    | ID                                    { ($1, []) }
    | ID LPAREN exprs RPAREN                { ($1, $3) }

exprs:
    | expr                                  { [$1] }
    | expr COMMA exprs                      { $1 :: $3 }

expr:
    | ID                                    { Ast.IdentExpr $1 }
    | INT                                   { Ast.IntLiteral $1 }
    | predicate	                            { Ast.PredicateExpr $1 }
    | regex RARROW regex                    { Ast.LinkExpr ($1, $3) }

regexes:
    | regex                                 { [$1] }
    | regex COMMA regexes                   { $1 :: $3 }

regex:
    | ID                                    { Ast.Ident ($1, []) }
    | ID LPAREN regexes RPAREN              { Ast.Ident ($1, $3) }
    | LBRACKET RBRACKET                     { Ast.Empty }
    | regex SEMICOLON regex                 { Ast.Concat ($1, $3) }
    | regex AND regex                       { Ast.Inter ($1, $3) }
    | regex OR regex                        { Ast.Union ($1, $3) }
    | regex DIFFERENCE regex                { Ast.Difference ($1, $3) }
    | NOT regex                             { Ast.Negate $2 }
    | regex STAR                            { Ast.Star $1 }
	| regex SHR regex						{ Ast.Shr ($1, $3) }
    | LPAREN regex RPAREN                   { $2 }

predicate:
    | INT DOT INT DOT INT DOT INT           { Ast.Prefix($1, $3, $5, $7, None) }
    | INT DOT INT DOT INT DOT INT SLASH INT { Ast.Prefix($1, $3, $5, $7, Some $9) }
	| INT COLON INT						    { Ast.Community ($1, $3) }
    | TRUE                                  { Ast.True }
    | FALSE                                 { Ast.False }
    | predicate OR predicate                { Ast.Or($1, $3) }
    | predicate AND predicate               { Ast.And($1, $3) }
	| NOT predicate                         { Ast.Not $2 }
    | LPAREN predicate RPAREN               { $2 }

definitions:
    | definition                            { [$1] }
    | definition definitions                { $1 :: $2 }

definition:
    | DEFINE ID	EQUAL regex	                { ($2, $4) }