{
module Lexer
open System
open Parser
open Microsoft.FSharp.Text.Lexing

exception EofInComment

let newline (lexbuf: LexBuffer<_>) =
    lexbuf.EndPos <- lexbuf.EndPos.NextLine
}


let digits = ['0'-'9']+ 
let id = ['a'-'z' 'A'-'Z' '_'] ['a'-'z' 'A'-'Z' '0'-'9' '_']*
let whitespace = [ ' ' '\t' '\r' '\n' ]

rule tokenize = parse
	| "/*"                  { comments 0 lexbuf } 
	| "define"              { DEFINE }
	| "task"                { TASK }
	| "not"	                { NOT }
	| "and"                 { AND }
	| "or"                  { OR }
	| "true"                { TRUE }
	| "false"               { FALSE }
	| "control"             { CONTROL }
	| id                    { ID (LexBuffer<char>.LexemeString lexbuf) }
	| digits                { INT (UInt32.Parse (LexBuffer<char>.LexemeString lexbuf)) }
	| '='                   { EQUAL }
	| '('                   { LPAREN }
	| ')'                   { RPAREN }
	| "->"                  { RARROW }
	| "=>"                  { ROCKET }
	| '['                   { LBRACKET }
	| ']'                   { RBRACKET }
	| '{'                   { LBRACE }
	| '}'                   { RBRACE }
	| ','                   { COMMA }
	| '/'                   { SLASH }
	| '\\'                  { DIFFERENCE }
	| ':'                   { COLON }
	| ';'                   { SEMICOLON }
	| '.'                   { DOT }
	| '*'                   { STAR }
	| ">>"                  { SHR }
	| [' ' '\t' '\r']       { tokenize lexbuf }
	| '\n'                  { newline lexbuf; tokenize lexbuf }
	| eof                   { EOF }

and comments level = parse
	| "*/"                  { if level = 0 then tokenize lexbuf else comments (level-1) lexbuf }
	| "/*"                  { comments (level+1) lexbuf }
	| '\n'                  { newline lexbuf; comments level lexbuf }
	| _	                    { comments level lexbuf }
	| eof                   { raise EofInComment }