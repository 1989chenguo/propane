{
module Lexer
open System
open Parser
open Microsoft.FSharp.Text.Lexing

exception EofInComment

let newline (lexbuf: LexBuffer<_>) =
    lexbuf.EndPos <- lexbuf.EndPos.NextLine
}


let id = ['a'-'z' 'A'-'Z'] ['a'-'z' 'A'-'Z' '0'-'9']*
let whitespace = [ ' ' '\t' '\r' '\n' ]

rule tokenize = parse
	| "/*"					{ comments 0 lexbuf } 
	| "define"				{ DEFINE }
	| "scope"				{ SCOPE }
	| "paths"				{ PATHS }
	| "ordered"				{ ORDERED }
	| "unordered"			{ UNORDERED }
	| "inter"				{ INTERSECT }
	| "union"				{ UNION }
	| "not"					{ NOT }
	| "and"					{ AND }
	| "or"					{ OR }
	| "true"				{ TRUE }
	| "false"				{ FALSE }
	| id					{ ID (LexBuffer<char>.LexemeString lexbuf) }
	| ['0'-'9']+			{ INT (UInt32.Parse (LexBuffer<char>.LexemeString lexbuf)) }
	| '='					{ EQUAL }
	| '('					{ LPAREN }
	| ')'					{ RPAREN }
	| "->"					{ RARROW }
	| "=>"					{ ROCKET }
	| '['					{ LBRACKET }
	| ']'					{ RBRACKET }
	| '{'					{ LBRACE }
	| '}'					{ RBRACE }
	| ','					{ COMMA }
	| '/'					{ SLASH }
	| ':'					{ COLON }
	| ';'					{ SEMICOLON }
	| '.'					{ DOT }
	| '*'					{ STAR }
	| ">>"					{ SHR }
	| [' ' '\t' '\r']		{ tokenize lexbuf }
	| '\n'					{ newline lexbuf; tokenize lexbuf }
	| eof					{ EOF }

and comments level = parse
	| "*/"					{ if level = 0 then tokenize lexbuf else comments (level-1) lexbuf }
	| "/*"					{ comments (level+1) lexbuf }
	| '\n'					{ newline lexbuf; comments level lexbuf }
	| _						{ comments level lexbuf }
	| eof					{ raise EofInComment }